var jStat;
/******/ var __webpack_modules__ = ({

/***/ 789:
/***/ (function(module) {

(function (window, factory) {
    if (true) {
        module.exports = factory();
    } else {}
})(this, function () {
var jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(num) {
  return (typeof num === 'number') ? num - num === 0 : false;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (var i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


jStat._random_fn = Math.random;
jStat.setRandom = function setRandom(fn) {
  if (typeof fn !== 'function')
    throw new TypeError('fn is not a function');
  jStat._random_fn = fn;
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector or return a sub matrix by pick some rows
jStat.row = function row(arr, index) {
  if (isArray(index)) {
    return index.map(function(i) {
      return jStat.row(arr, i);
    })
  }
  return arr[index];
};


// return row as array
// rowa([[1,2],[3,4]],0) -> [1,2]
jStat.rowa = function rowa(arr, i) {
  return jStat.row(arr, i);
};


// Returns the specified column as a vector or return a sub matrix by pick some
// columns
jStat.col = function col(arr, index) {
  if (isArray(index)) {
    var submat = jStat.arange(arr.length).map(function() {
      return new Array(index.length);
    });
    index.forEach(function(ind, i){
      jStat.arange(arr.length).forEach(function(j) {
        submat[j][i] = arr[j][ind];
      });
    });
    return submat;
  }
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// return column as array
// cola([[1,2],[3,4]],0) -> [1,3]
jStat.cola = function cola(arr, i) {
  return jStat.col(arr, i).map(function(a){ return a[0] });
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Cumulatively combine the elements of an array or array of arrays using a function.
jStat.cumreduce = function cumreduce(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    if (ncol > 0)
      res[row][0] = arr[row][0];
    for (col = 1; col < ncol; col++)
      res[row][col] = func(res[row][col-1], arr[row][col]);
  }
  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, jStat._random_fn);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max && cnt < length;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// arange(5) -> [0,1,2,3,4]
// arange(1,5) -> [1,2,3,4]
// arange(5,1,-1) -> [5,4,3,2]
jStat.arange = function arange(start, end, step) {
  var rl = [];
  var i;
  step = step || 1;
  if (end === undefined) {
    end = start;
    start = 0;
  }
  if (start === end || step === 0) {
    return [];
  }
  if (start < end && step < 0) {
    return [];
  }
  if (start > end && step > 0) {
    return [];
  }
  if (step > 0) {
    for (i = start; i < end; i += step) {
      rl.push(i);
    }
  } else {
    for (i = start; i > end; i += step) {
      rl.push(i);
    }
  }
  return rl;
};


// A=[[1,2,3],[4,5,6],[7,8,9]]
// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]
// slice(A,1,{start:1}) -> [5,6]
// as numpy code A[:2,1:]
jStat.slice = (function(){
  function _slice(list, start, end, step) {
    // note it's not equal to range.map mode it's a bug
    var i;
    var rl = [];
    var length = list.length;
    if (start === undefined && end === undefined && step === undefined) {
      return jStat.copy(list);
    }

    start = start || 0;
    end = end || list.length;
    start = start >= 0 ? start : length + start;
    end = end >= 0 ? end : length + end;
    step = step || 1;
    if (start === end || step === 0) {
      return [];
    }
    if (start < end && step < 0) {
      return [];
    }
    if (start > end && step > 0) {
      return [];
    }
    if (step > 0) {
      for (i = start; i < end; i += step) {
        rl.push(list[i]);
      }
    } else {
      for (i = start; i > end;i += step) {
        rl.push(list[i]);
      }
    }
    return rl;
  }

  function slice(list, rcSlice) {
    var colSlice, rowSlice;
    rcSlice = rcSlice || {};
    if (isNumber(rcSlice.row)) {
      if (isNumber(rcSlice.col))
        return list[rcSlice.row][rcSlice.col];
      var row = jStat.rowa(list, rcSlice.row);
      colSlice = rcSlice.col || {};
      return _slice(row, colSlice.start, colSlice.end, colSlice.step);
    }

    if (isNumber(rcSlice.col)) {
      var col = jStat.cola(list, rcSlice.col);
      rowSlice = rcSlice.row || {};
      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
    }

    rowSlice = rcSlice.row || {};
    colSlice = rcSlice.col || {};
    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
    return rows.map(function(row) {
      return _slice(row, colSlice.start, colSlice.end, colSlice.step);
    });
  }

  return slice;
}());


// A=[[1,2,3],[4,5,6],[7,8,9]]
// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])
// A=[[1,2,3],[4,0,0],[7,0,0]]
jStat.sliceAssign = function sliceAssign(A, rcSlice, B) {
  var nl, ml;
  if (isNumber(rcSlice.row)) {
    if (isNumber(rcSlice.col))
      return A[rcSlice.row][rcSlice.col] = B;
    rcSlice.col = rcSlice.col || {};
    rcSlice.col.start = rcSlice.col.start || 0;
    rcSlice.col.end = rcSlice.col.end || A[0].length;
    rcSlice.col.step = rcSlice.col.step || 1;
    nl = jStat.arange(rcSlice.col.start,
                          Math.min(A.length, rcSlice.col.end),
                          rcSlice.col.step);
    var m = rcSlice.row;
    nl.forEach(function(n, i) {
      A[m][n] = B[i];
    });
    return A;
  }

  if (isNumber(rcSlice.col)) {
    rcSlice.row = rcSlice.row || {};
    rcSlice.row.start = rcSlice.row.start || 0;
    rcSlice.row.end = rcSlice.row.end || A.length;
    rcSlice.row.step = rcSlice.row.step || 1;
    ml = jStat.arange(rcSlice.row.start,
                          Math.min(A[0].length, rcSlice.row.end),
                          rcSlice.row.step);
    var n = rcSlice.col;
    ml.forEach(function(m, j) {
      A[m][n] = B[j];
    });
    return A;
  }

  if (B[0].length === undefined) {
    B = [B];
  }
  rcSlice.row.start = rcSlice.row.start || 0;
  rcSlice.row.end = rcSlice.row.end || A.length;
  rcSlice.row.step = rcSlice.row.step || 1;
  rcSlice.col.start = rcSlice.col.start || 0;
  rcSlice.col.end = rcSlice.col.end || A[0].length;
  rcSlice.col.step = rcSlice.col.step || 1;
  ml = jStat.arange(rcSlice.row.start,
                        Math.min(A.length, rcSlice.row.end),
                        rcSlice.row.step);
  nl = jStat.arange(rcSlice.col.start,
                        Math.min(A[0].length, rcSlice.col.end),
                        rcSlice.col.step);
  ml.forEach(function(m, i) {
    nl.forEach(function(n, j) {
      A[m][n] = B[i][j];
    });
  });
  return A;
};


// [1,2,3] ->
// [[1,0,0],[0,2,0],[0,0,3]]
jStat.diagonal = function diagonal(diagArray) {
  var mat = jStat.zeros(diagArray.length, diagArray.length);
  diagArray.forEach(function(t, i) {
    mat[i][i] = t;
  });
  return mat;
};


// return copy of A
jStat.copy = function copy(A) {
  return A.map(function(row) {
    if (isNumber(row))
      return row;
    return row.map(function(t) {
      return t;
    });
  });
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Cumulatively combine the elements of a matrix or vector using a function.
jProto.cumreduce = function cumreduce(func, toAlter) {
  return jStat(jStat.cumreduce(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};

// sum of an array in each row
jStat.sumrow = function sumrow(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};

// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// unique values of an array
jStat.unique = function unique(arr) {
  var hash = {}, _arr = [];
  for(var i = 0; i < arr.length; i++) {
    if (!hash[arr[i]]) {
      hash[arr[i]] = true;
      _arr.push(arr[i]);
    }
  }
  return _arr;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  var logs = arr.map(Math.log)
  var meanOfLogs = jStat.mean(logs)
  return Math.exp(meanOfLogs)
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a + b; });
};


// cumulative product of an array
jStat.cumprod = function cumprod(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a * b; });
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// ranks of an array
jStat.rank = function (arr) {
  var i;
  var distinctNumbers = [];
  var numberCounts = {};
  for (i = 0; i < arr.length; i++) {
    var number = arr[i];
    if (numberCounts[number]) {
      numberCounts[number]++;
    } else {
      numberCounts[number] = 1;
      distinctNumbers.push(number);
    }
  }

  var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
  var numberRanks = {};
  var currentRank = 1;
  for (i = 0; i < sortedDistinctNumbers.length; i++) {
    var number = sortedDistinctNumbers[i];
    var count = numberCounts[number];
    var first = currentRank;
    var last = currentRank + count - 1;
    var rank = (first + last) / 2;
    numberRanks[number] = rank;
    currentRank += count;
  }

  return arr.map(function (number) {
    return numberRanks[number];
  });
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag = true indicates sample instead of population
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};

// pooled variance of an array of arrays
jStat.pooledvariance = function pooledvariance(arr) {
  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);
  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);
  return sumsqerr / (count - arr.length);
};

// deviation of an array
jStat.deviation = function (arr) {
  var mean = jStat.mean(arr);
  var arrlen = arr.length;
  var dev = new Array(arrlen);
  for (var i = 0; i < arrlen; i++) {
    dev[i] = arr[i] - mean;
  }
  return dev;
};

// standard deviation of an array
// flag = true indicates sample instead of population
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};

// pooled standard deviation of an array of arrays
jStat.pooledstdev = function pooledstdev(arr) {
  return Math.sqrt(jStat.pooledvariance(arr));
};

// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var mean = jStat.mean(arr);
  var a = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    a.push(Math.abs(arr[i] - mean));
  }
  return jStat.mean(a);
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var median = jStat.median(arr);
  var a = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    a.push(Math.abs(arr[i] - median));
  }
  return jStat.median(a);
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.
// Passing true for the exclusive parameter excludes both endpoints of the range.
jStat.percentile = function percentile(arr, k, exclusive) {
  var _arr = arr.slice().sort(ascNum);
  var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
  var index = parseInt(realIndex);
  var frac = realIndex - index;
  if (index + 1 < _arr.length) {
    return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
  } else {
    return _arr[index - 1];
  }
}

// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};


// Histogram (bin count) data
jStat.histogram = function histogram(arr, binCnt) {
  binCnt = binCnt || 4;
  var first = jStat.min(arr);
  var binWidth = (jStat.max(arr) - first) / binCnt;
  var len = arr.length;
  var bins = [];
  var i;

  for (i = 0; i < binCnt; i++)
    bins[i] = 0;
  for (i = 0; i < len; i++)
    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;

  return bins;
};


// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};

  // (spearman's) rank correlation coefficient, sp
jStat.spearmancoeff =  function (arr1, arr2) {
  arr1 = jStat.rank(arr1);
  arr2 = jStat.rank(arr2);
  //return pearson's correlation of the ranks:
  return jStat.corrcoeff(arr1, arr2);
}


// statistical standardized moments (general form of skew/kurt)
jStat.stanMoment = function stanMoment(arr, n) {
  var mu = jStat.mean(arr);
  var sigma = jStat.stdev(arr);
  var len = arr.length;
  var skewSum = 0;

  for (var i = 0; i < len; i++)
    skewSum += Math.pow((arr[i] - mu) / sigma, n);

  return skewSum / arr.length;
};

// (pearson's) moment coefficient of skewness
jStat.skewness = function skewness(arr) {
  return jStat.stanMoment(arr, 3);
};

// (pearson's) (excess) kurtosis
jStat.kurtosis = function kurtosis(arr) {
  return jStat.stanMoment(arr, 4) - 3;
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums and products.
// This differs from the similar extension below as cumsum and cumprod should
// not be run again in the case fullbool === true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('cumsum cumprod').split(' '));


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        if (passfunc !== 'sumrow')
          tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +
    'geomean median diff rank mode range variance deviation stdev meandev ' +
    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);
      var callbackFunction;

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};

/*
 * log-gamma function to support poisson distribution sampling. The
 * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their
 * book "Computation of Special Functions", 1996, John Wiley & Sons, Inc.
 */
jStat.loggam = function loggam(x) {
  var x0, x2, xp, gl, gl0;
  var k, n;

  var a = [8.333333333333333e-02, -2.777777777777778e-03,
          7.936507936507937e-04, -5.952380952380952e-04,
          8.417508417508418e-04, -1.917526917526918e-03,
          6.410256410256410e-03, -2.955065359477124e-02,
          1.796443723688307e-01, -1.39243221690590e+00];
  x0 = x;
  n = 0;
  if ((x == 1.0) || (x == 2.0)) {
      return 0.0;
  }
  if (x <= 7.0) {
      n = Math.floor(7 - x);
      x0 = x + n;
  }
  x2 = 1.0 / (x0 * x0);
  xp = 2 * Math.PI;
  gl0 = a[9];
  for (k = 8; k >= 0; k--) {
      gl0 *= x2;
      gl0 += a[k];
  }
  gl = gl0 / x0 + 0.5 * Math.log(xp) + (x0 - 0.5) * Math.log(x0) - x0;
  if (x <= 7.0) {
      for (k = 1; k <= n; k++) {
          gl -= Math.log(x0 - 1.0);
          x0 -= 1.0;
      }
  }
  return gl;
}

// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res;
  if (x > 171.6243769536076) {
    return Infinity;
  }
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function, which is usually typeset with a
// lower-case greek gamma as the function symbol
jStat.gammap = function gammap(a, x) {
  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);
};


// The lower regularized incomplete gamma function, usually written P(a,x)
jStat.lowRegGamma = function lowRegGamma(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
};

// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse of the lower regularized inomplete gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.lowRegGamma(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = jStat._random_fn();
    v = 1.7156 * (jStat._random_fn() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = jStat._random_fn();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = jStat._random_fn();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function f(a, b, c) {
      if (!(this instanceof f))
        return new f(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +
  'binomial negbin hypgeom poisson triangular tukey arcsine'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 && beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    return jStat.ibetainv(0.5, alpha, beta);
  },

  mode: function mode(alpha, beta) {
    return (alpha - 1 ) / ( alpha + beta - 2);
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  // This implementation of the pdf function avoids float overflow
  // See the way that R calculates this value:
  // https://svn.r-project.org/R/trunk/src/nmath/df.c
  pdf: function pdf(x, df1, df2) {
    var p, q, f;

    if (x < 0)
      return 0;

    if (df1 <= 2) {
      if (x === 0 && df1 < 2) {
        return Infinity;
      }
      if (x === 0 && df1 === 2) {
        return 1;
      }
      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *
              Math.pow(df1 / df2, df1 / 2) *
              Math.pow(x, (df1/2) - 1) *
              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);
    }

    p = (df1 * x) / (df2 + x * df1);
    q = df2 / (df2 + x * df1);
    f = df1 * q / 2.0;
    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
  },

  cdf: function cdf(x, df1, df2) {
    if (x < 0)
      return 0;
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    if (scale < 0) { return 0; }

    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local/*, scale*/) {
    return local;
  },

  mode: function mode(local/*, scale*/) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    if (x < 0)
      return 0;
    return (x === 0 && dof === 2) ? 0.5 :
        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                 Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(/*rate*/) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(jStat._random_fn());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return (x === 0 && shape === 1) ? 1 / scale :
            Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return 1 - jStat.lowRegGamma(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    if (x === 0 && alpha === 1)
      return beta;
    else if (x === 1 && beta === 1)
      return alpha;
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    if (x < 0)
      return 0;
    else if (x > 1)
      return 1;
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  inv: function inv(p, alpha, beta) {
    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(/*alpha, beta*/) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    if (x <= 0)
      return 0;
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    if (x < 0)
      return 0;
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu/*, sigma*/) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend noncentralt function with static methods
jStat.extend(jStat.noncentralt, {
  pdf: function pdf(x, dof, ncp) {
    var tol = 1e-14;
    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.pdf(x, dof)

    if (Math.abs(x) < tol) {  // different formula for x == 0
      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -
                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));
    }

    // formula for x != 0
    return dof / x *
        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -
         jStat.noncentralt.cdf(x, dof, ncp));
  },

  cdf: function cdf(x, dof, ncp) {
    var tol = 1e-14;
    var min_iterations = 200;

    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.cdf(x, dof);

    // turn negative x into positive and flip result afterwards
    var flip = false;
    if (x < 0) {
      flip = true;
      ncp = -ncp;
    }

    var prob = jStat.normal.cdf(-ncp, 0, 1);
    var value = tol + 1;
    // use value at last two steps to determine convergence
    var lastvalue = value;
    var y = x * x / (x * x + dof);
    var j = 0;
    var p = Math.exp(-ncp * ncp / 2);
    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -
                     jStat.gammaln(3 / 2)) * ncp;
    while (j < min_iterations || lastvalue > tol || value > tol) {
      lastvalue = value;
      if (j > 0) {
        p *= (ncp * ncp) / (2 * j);
        q *= (ncp * ncp) / (2 * (j + 1 / 2));
      }
      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +
          q * jStat.beta.cdf(y, j+1, dof/2);
      prob += 0.5 * value;
      j++;
    }

    return flip ? (1 - prob) : prob;
  }
});


// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean/*, std*/) {
    return mean;
  },

  median: function median(mean/*, std*/) {
    return mean;
  },

  mode: function (mean/*, std*/) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return 1 - Math.pow(scale / x, shape);
  },

  inv: function inv(p, scale, shape) {
    return scale / Math.pow(1 - p, 1 / shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale/*, shape*/) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    dof = dof > 1e100 ? 1e100 : dof;
    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(/*dof*/) {
    return 0;
  },

  mode: function mode(/*dof*/) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0 || scale < 0 || shape < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return 0;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(jStat._random_fn()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(jStat.weibull.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  inv: function(p, a, b) {
    return a + (p * (b - a));
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(/*a, b*/) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});


// Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html
function betinc(x, a, b, eps) {
  var a0 = 0;
  var b0 = 1;
  var a1 = 1;
  var b1 = 1;
  var m9 = 0;
  var a2 = 0;
  var c9;

  while (Math.abs((a1 - a2) / a1) > eps) {
    a2 = a1;
    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
    a0 = a1 + c9 * a0;
    b0 = b1 + c9 * b0;
    m9 = m9 + 1;
    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
    a1 = a0 + c9 * a1;
    b1 = b0 + c9 * b1;
    a0 = a0 / b1;
    b0 = b0 / b1;
    a1 = a1 / b1;
    b1 = 1;
  }

  return a1 / a;
}


// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var betacdf;
    var eps = 1e-10;

    if (x < 0)
      return 0;
    if (x >= n)
      return 1;
    if (p < 0 || p > 1 || n <= 0)
      return NaN;

    x = Math.floor(x);
    var z = p;
    var a = x + 1;
    var b = n - x;
    var s = a + b;
    var bt = Math.exp(jStat.gammaln(s) - jStat.gammaln(b) -
                      jStat.gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));

    if (z < (a + 1) / (s + 2))
      betacdf = bt * betinc(z, a, b, eps);
    else
      betacdf = 1 - bt * betinc(1 - z, b, a, eps);

    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    if (k !== k >>> 0)
      return false;
    if (k < 0)
      return 0;
    return jStat.combination(k + r - 1, r - 1) *
        Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    if (l < 0 || (k % 1) !== 0 || k < 0) {
      return 0;
    }

    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sampleSmall: function sampleSmall(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= jStat._random_fn();
    } while (p > L);
    return k - 1;
  },

  sampleLarge: function sampleLarge(l) {
    var lam = l;
    var k;
    var U, V, slam, loglam, a, b, invalpha, vr, us;

    slam = Math.sqrt(lam);
    loglam = Math.log(lam);
    b = 0.931 + 2.53 * slam;
    a = -0.059 + 0.02483 * b;
    invalpha = 1.1239 + 1.1328 / (b - 3.4);
    vr = 0.9277 - 3.6224 / (b - 2);

    while (1) {
      U = Math.random() - 0.5;
      V = Math.random();
      us = 0.5 - Math.abs(U);
      k = Math.floor((2 * a / us + b) * U + lam + 0.43);
      if ((us >= 0.07) && (V <= vr)) {
          return k;
      }
      if ((k < 0) || ((us < 0.013) && (V > us))) {
          continue;
      }
      /* log(V) == log(0.0) ok here */
      /* if U==0.0 so that us==0.0, log is ok since always returns */
      if ((Math.log(V) + Math.log(invalpha) - Math.log(a / (us * us) + b)) <= (-lam + k * loglam - jStat.loggam(k + 1))) {
          return k;
      }
    }
  },

  sample: function sample(l) {
    if (l < 10)
      return this.sampleSmall(l);
    else
      return this.sampleLarge(l);
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (x < a || x > b) {
        return 0;
      } else if (x < c) {
          return (2 * (x - a)) / ((b - a) * (c - a));
      } else if (x === c) {
          return (2 / (b - a));
      } else { // x > c
          return (2 * (b - x)) / ((b - a) * (b - c));
      }
    }
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return NaN;
    if (x <= a)
      return 0;
    else if (x >= b)
      return 1;
    if (x <= c)
      return Math.pow(x - a, 2) / ((b - a) * (c - a));
    else // x > c
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
  },

  inv: function inv(p, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (p <= ((c - a) / (b - a))) {
        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));
      } else { // p > ((c - a) / (b - a))
        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));
      }
    }
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = jStat._random_fn();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});


// extend arcsine function with static methods
jStat.extend(jStat.arcsine, {
  pdf: function pdf(x, a, b) {
    if (b <= a) return NaN;

    return (x <= a || x >= b) ? 0 :
      (2 / Math.PI) *
        Math.pow(Math.pow(b - a, 2) -
                  Math.pow(2 * x - a - b, 2), -0.5);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));
    return 1;
  },

  inv: function(p, a, b) {
    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);
  },

  mean: function mean(a, b) {
    if (b <= a) return NaN;
    return (a + b) / 2;
  },

  median: function median(a, b) {
    if (b <= a) return NaN;
    return (a + b) / 2;
  },

  mode: function mode(/*a, b*/) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return ((a + b) / 2) + ((b - a) / 2) *
      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));
  },

  variance: function variance(a, b) {
    if (b <= a) return NaN;
    return Math.pow(b - a, 2) / 8;
  }
});


function laplaceSign(x) { return x / Math.abs(x); }

jStat.extend(jStat.laplace, {
  pdf: function pdf(x, mu, b) {
    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);
  },

  cdf: function cdf(x, mu, b) {
    if (b <= 0) { return 0; }

    if(x < mu) {
      return 0.5 * Math.exp((x - mu) / b);
    } else {
      return 1 - 0.5 * Math.exp(- (x - mu) / b);
    }
  },

  mean: function(mu/*, b*/) {
    return mu;
  },

  median: function(mu/*, b*/) {
    return mu;
  },

  mode: function(mu/*, b*/) {
    return mu;
  },

  variance: function(mu, b) {
    return 2 * b * b;
  },

  sample: function sample(mu, b) {
    var u = jStat._random_fn() - 0.5;

    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));
  }
});

function tukeyWprob(w, rr, cc) {
  var nleg = 12;
  var ihalf = 6;

  var C1 = -30;
  var C2 = -50;
  var C3 = 60;
  var bb   = 8;
  var wlar = 3;
  var wincr1 = 2;
  var wincr2 = 3;
  var xleg = [
    0.981560634246719250690549090149,
    0.904117256370474856678465866119,
    0.769902674194304687036893833213,
    0.587317954286617447296702418941,
    0.367831498998180193752691536644,
    0.125233408511468915472441369464
  ];
  var aleg = [
    0.047175336386511827194615961485,
    0.106939325995318430960254718194,
    0.160078328543346226334652529543,
    0.203167426723065921749064455810,
    0.233492536538354808760849898925,
    0.249147045813402785000562436043
  ];

  var qsqz = w * 0.5;

  // if w >= 16 then the integral lower bound (occurs for c=20)
  // is 0.99999999999995 so return a value of 1.

  if (qsqz >= bb)
    return 1.0;

  // find (f(w/2) - 1) ^ cc
  // (first term in integral of hartley's form).

  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)
  // if pr_w ^ cc < 2e-22 then set pr_w = 0
  if (pr_w >= Math.exp(C2 / cc))
    pr_w = Math.pow(pr_w, cc);
  else
    pr_w = 0.0;

  // if w is large then the second component of the
  // integral is small, so fewer intervals are needed.

  var wincr;
  if (w > wlar)
    wincr = wincr1;
  else
    wincr = wincr2;

  // find the integral of second term of hartley's form
  // for the integral of the range for equal-length
  // intervals using legendre quadrature.  limits of
  // integration are from (w/2, 8).  two or three
  // equal-length intervals are used.

  // blb and bub are lower and upper limits of integration.

  var blb = qsqz;
  var binc = (bb - qsqz) / wincr;
  var bub = blb + binc;
  var einsum = 0.0;

  // integrate over each interval

  var cc1 = cc - 1.0;
  for (var wi = 1; wi <= wincr; wi++) {
    var elsum = 0.0;
    var a = 0.5 * (bub + blb);

    // legendre quadrature with order = nleg

    var b = 0.5 * (bub - blb);

    for (var jj = 1; jj <= nleg; jj++) {
      var j, xx;
      if (ihalf < jj) {
        j = (nleg - jj) + 1;
        xx = xleg[j-1];
      } else {
        j = jj;
        xx = -xleg[j-1];
      }
      var c = b * xx;
      var ac = a + c;

      // if exp(-qexpo/2) < 9e-14,
      // then doesn't contribute to integral

      var qexpo = ac * ac;
      if (qexpo > C3)
        break;

      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);
      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);

      // if rinsum ^ (cc-1) < 9e-14,
      // then doesn't contribute to integral

      var rinsum = (pplus * 0.5) - (pminus * 0.5);
      if (rinsum >= Math.exp(C1 / cc1)) {
        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);
        elsum += rinsum;
      }
    }
    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));
    einsum += elsum;
    blb = bub;
    bub += binc;
  }

  // if pr_w ^ rr < 9e-14, then return 0
  pr_w += einsum;
  if (pr_w <= Math.exp(C1 / rr))
    return 0;

  pr_w = Math.pow(pr_w, rr);
  if (pr_w >= 1) // 1 was iMax was eps
    return 1;
  return pr_w;
}

function tukeyQinv(p, c, v) {
  var p0 = 0.322232421088;
  var q0 = 0.993484626060e-01;
  var p1 = -1.0;
  var q1 = 0.588581570495;
  var p2 = -0.342242088547;
  var q2 = 0.531103462366;
  var p3 = -0.204231210125;
  var q3 = 0.103537752850;
  var p4 = -0.453642210148e-04;
  var q4 = 0.38560700634e-02;
  var c1 = 0.8832;
  var c2 = 0.2368;
  var c3 = 1.214;
  var c4 = 1.208;
  var c5 = 1.4142;
  var vmax = 120.0;

  var ps = 0.5 - 0.5 * p;
  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));
  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)
     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
  if (v < vmax) t += (t * t * t + t) / v / 4.0;
  var q = c1 - c2 * t;
  if (v < vmax) q += -c3 / v + c4 * t / v;
  return t * (q * Math.log(c - 1.0) + c5);
}

jStat.extend(jStat.tukey, {
  cdf: function cdf(q, nmeans, df) {
    // Identical implementation as the R ptukey() function as of commit 68947
    var rr = 1;
    var cc = nmeans;

    var nlegq = 16;
    var ihalfq = 8;

    var eps1 = -30.0;
    var eps2 = 1.0e-14;
    var dhaf  = 100.0;
    var dquar = 800.0;
    var deigh = 5000.0;
    var dlarg = 25000.0;
    var ulen1 = 1.0;
    var ulen2 = 0.5;
    var ulen3 = 0.25;
    var ulen4 = 0.125;
    var xlegq = [
      0.989400934991649932596154173450,
      0.944575023073232576077988415535,
      0.865631202387831743880467897712,
      0.755404408355003033895101194847,
      0.617876244402643748446671764049,
      0.458016777657227386342419442984,
      0.281603550779258913230460501460,
      0.950125098376374401853193354250e-1
    ];
    var alegq = [
      0.271524594117540948517805724560e-1,
      0.622535239386478928628438369944e-1,
      0.951585116824927848099251076022e-1,
      0.124628971255533872052476282192,
      0.149595988816576732081501730547,
      0.169156519395002538189312079030,
      0.182603415044923588866763667969,
      0.189450610455068496285396723208
    ];

    if (q <= 0)
      return 0;

    // df must be > 1
    // there must be at least two values

    if (df < 2 || rr < 1 || cc < 2) return NaN;

    if (!Number.isFinite(q))
      return 1;

    if (df > dlarg)
      return tukeyWprob(q, rr, cc);

    // calculate leading constant

    var f2 = df * 0.5;
    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);
    var f21 = f2 - 1.0;

    // integral is divided into unit, half-unit, quarter-unit, or
    // eighth-unit length intervals depending on the value of the
    // degrees of freedom.

    var ff4 = df * 0.25;
    var ulen;
    if      (df <= dhaf)  ulen = ulen1;
    else if (df <= dquar) ulen = ulen2;
    else if (df <= deigh) ulen = ulen3;
    else                  ulen = ulen4;

    f2lf += Math.log(ulen);

    // integrate over each subinterval

    var ans = 0.0;

    for (var i = 1; i <= 50; i++) {
      var otsum = 0.0;

      // legendre quadrature with order = nlegq
      // nodes (stored in xlegq) are symmetric around zero.

      var twa1 = (2 * i - 1) * ulen;

      for (var jj = 1; jj <= nlegq; jj++) {
        var j, t1;
        if (ihalfq < jj) {
          j = jj - ihalfq - 1;
          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))
              - (((xlegq[j] * ulen) + twa1) * ff4);
        } else {
          j = jj - 1;
          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))
              + (((xlegq[j] * ulen) - twa1) * ff4);
        }

        // if exp(t1) < 9e-14, then doesn't contribute to integral
        var qsqz;
        if (t1 >= eps1) {
          if (ihalfq < jj) {
            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);
          } else {
            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);
          }

          // call wprob to find integral of range portion

          var wprb = tukeyWprob(qsqz, rr, cc);
          var rotsum = (wprb * alegq[j]) * Math.exp(t1);
          otsum += rotsum;
        }
        // end legendre integral for interval i
        // L200:
      }

      // if integral for interval i < 1e-14, then stop.
      // However, in order to avoid small area under left tail,
      // at least  1 / ulen  intervals are calculated.
      if (i * ulen >= 1.0 && otsum <= eps2)
        break;

      // end of interval i
      // L330:

      ans += otsum;
    }

    if (otsum > eps2) { // not converged
      throw new Error('tukey.cdf failed to converge');
    }
    if (ans > 1)
      ans = 1;
    return ans;
  },

  inv: function(p, nmeans, df) {
    // Identical implementation as the R qtukey() function as of commit 68947
    var rr = 1;
    var cc = nmeans;

    var eps = 0.0001;
    var maxiter = 50;

    // df must be > 1 ; there must be at least two values
    if (df < 2 || rr < 1 || cc < 2) return NaN;

    if (p < 0 || p > 1) return NaN;
    if (p === 0) return 0;
    if (p === 1) return Infinity;

    // Initial value

    var x0 = tukeyQinv(p, cc, df);

    // Find prob(value < x0)

    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;

    // Find the second iterate and prob(value < x1).
    // If the first iterate has probability value
    // exceeding p then second iterate is 1 less than
    // first iterate; otherwise it is 1 greater.

    var x1;
    if (valx0 > 0.0)
      x1 = Math.max(0.0, x0 - 1.0);
    else
      x1 = x0 + 1.0;
    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;

    // Find new iterate

    var ans;
    for(var iter = 1; iter < maxiter; iter++) {
      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));
      valx0 = valx1;

      // New iterate must be >= 0

      x0 = x1;
      if (ans < 0.0) {
        ans = 0.0;
        valx1 = -p;
      }
      // Find prob(value < new iterate)

      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;
      x1 = ans;

      // If the difference between two successive
      // iterates is less than eps, stop

      var xabs = Math.abs(x1 - x0);
      if (xabs < eps)
        return ans;
    }

    throw new Error('tukey.inv failed to converge');
  }
});

}(jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

function isUsable(arg) {
  return isArray(arg) || arg instanceof jStat;
}

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isUsable(arg)) {
      if (!isUsable(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isUsable(arg)) {
      if (!isUsable(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isUsable(arg)) {
      if (!isUsable(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum, nrow, ncol, res, rescols;
    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure
    if (arr.length === undefined && arg.length === undefined) {
      return arr * arg;
    }
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isUsable(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // outer([1,2,3],[4,5,6])
  // ===
  // [[1],[2],[3]] times [[4,5,6]]
  // ->
  // [[4,5,6],[8,10,12],[12,15,18]]
  outer:function outer(A, B) {
    return jStat.multiply(A.map(function(t){ return [t] }), [B]);
  },


  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isUsable(arr[0])) arr = [ arr ];
    if (!isUsable(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // exponentiate every element
  exp: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.exp(value); });
  },

  // generate the natural log of every element
  log: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.log(value); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isUsable(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // computes the angle between two vectors in rads
  // In case a matrix is passed, this uses the first row as the vector
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  // Note: this function returns a matrix, not a jStat object
  aug: function aug(a, b) {
    var newarr = [];
    var i;
    for (i = 0; i < a.length; i++) {
      newarr.push(a[i].slice());
    }
    for (i = 0; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  // The inv() function calculates the inverse of a matrix
  // Create the inverse by augmenting the matrix by the identity matrix of the
  // appropriate size, and then use G-J elimination on the augmented matrix.
  inv: function inv(a) {
    var rows = a.length;
    var cols = a[0].length;
    var b = jStat.identity(rows, cols);
    var c = jStat.gauss_jordan(a, b);
    var result = [];
    var i = 0;
    var j;

    //We need to copy the inverse portion to a new matrix to rid G-J artifacts
    for (; i < rows; i++) {
      result[i] = [];
      for (j = cols; j < c[0].length; j++)
        result[i][j - cols] = c[i][j];
    }
    return result;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    if (a.length === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }

    var determinant = 0;
    for (var i = 0; i < a.length; i++) {
      // build a sub matrix without column `i`
      var submatrix = [];
      for (var row = 1; row < a.length; row++) {
        submatrix[row - 1] = [];
        for (var col = 0; col < a.length; col++) {
          if (col < i) {
            submatrix[row - 1][col] = a[row][col];
          } else if (col > i) {
            submatrix[row - 1][col - 1] = a[row][col];
          }
        }
      }

      // alternate between + and - between determinants
      var sign = i % 2 ? -1 : 1;
      determinant += det(submatrix) * a[0][i] * sign;
    }

    return determinant
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(i = 0; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = sum + x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b);
    var h = m.length;
    var w = m[0].length;
    var c = 0;
    var x, y, y2;
    // find max pivot
    for (y = 0; y < h; y++) {
      var maxrow = y;
      for (y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (y2 = 0; y2 < y; y2++) {
        for (x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  // solve equation
  // Ax=b
  // A is upper triangular matrix
  // A=[[1,2,3],[0,4,5],[0,6,7]]
  // b=[1,2,3]
  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
  // if you use matrix style
  // A=[[1,2,3],[0,4,5],[0,6,7]]
  // b=[[1],[2],[3]]
  // will return [[2.666],[0.1666],[1.666]]
  triaUpSolve: function triaUpSolve(A, b) {
    var size = A[0].length;
    var x = jStat.zeros(1, size)[0];
    var parts;
    var matrix_mode = false;

    if (b[0].length != undefined) {
      b = b.map(function(i){ return i[0] });
      matrix_mode = true;
    }

    jStat.arange(size - 1, -1, -1).forEach(function(i) {
      parts = jStat.arange(i + 1, size).map(function(j) {
        return x[j] * A[i][j];
      });
      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
    });

    if (matrix_mode)
      return x.map(function(i){ return [i] });
    return x;
  },

  triaLowSolve: function triaLowSolve(A, b) {
    // like to triaUpSolve but A is lower triangular matrix
    var size = A[0].length;
    var x = jStat.zeros(1, size)[0];
    var parts;

    var matrix_mode=false;
    if (b[0].length != undefined) {
      b = b.map(function(i){ return i[0] });
      matrix_mode = true;
    }

    jStat.arange(size).forEach(function(i) {
      parts = jStat.arange(i).map(function(j) {
        return A[i][j] * x[j];
      });
      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
    })

    if (matrix_mode)
      return x.map(function(i){ return [i] });
    return x;
  },


  // A -> [L,U]
  // A=LU
  // L is lower triangular matrix
  // U is upper triangular matrix
  lu: function lu(A) {
    var size = A.length;
    //var L=jStat.diagonal(jStat.ones(1,size)[0]);
    var L = jStat.identity(size);
    var R = jStat.zeros(A.length, A[0].length);
    var parts;
    jStat.arange(size).forEach(function(t) {
      R[0][t] = A[0][t];
    });
    jStat.arange(1, size).forEach(function(l) {
      jStat.arange(l).forEach(function(i) {
        parts = jStat.arange(i).map(function(jj) {
          return L[l][jj] * R[jj][i];
        });
        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];
      });
      jStat.arange(l, size).forEach(function(j) {
        parts = jStat.arange(l).map(function(jj) {
          return L[l][jj] * R[jj][j];
        });
        R[l][j] = A[parts.length][j] - jStat.sum(parts);
      });
    });
    return [L, R];
  },

  // A -> T
  // A=TT'
  // T is lower triangular matrix
  cholesky: function cholesky(A) {
    var size = A.length;
    var T = jStat.zeros(A.length, A[0].length);
    var parts;
    jStat.arange(size).forEach(function(i) {
      parts = jStat.arange(i).map(function(t) {
        return Math.pow(T[i][t],2);
      });
      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));
      jStat.arange(i + 1, size).forEach(function(j) {
        parts = jStat.arange(i).map(function(t) {
          return T[i][t] * T[j][t];
        });
        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];
      });
    });
    return T;
  },


  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // A -> [Q,R]
  // Q is orthogonal matrix
  // R is upper triangular
  QR: (function() {
    // x -> Q
    // find a orthogonal matrix Q st.
    // Qx=y
    // y is [||x||,0,0,...]

    // quick ref
    var sum   = jStat.sum;
    var range = jStat.arange;

    function qr2(x) {
      // quick impletation
      // https://www.stat.wisc.edu/~larget/math496/qr.html

      var n = x.length;
      var p = x[0].length;

      var r = jStat.zeros(p, p);
      x = jStat.copy(x);

      var i,j,k;
      for(j = 0; j < p; j++){
        r[j][j] = Math.sqrt(sum(range(n).map(function(i){
          return x[i][j] * x[i][j];
        })));
        for(i = 0; i < n; i++){
          x[i][j] = x[i][j] / r[j][j];
        }
        for(k = j+1; k < p; k++){
          r[j][k] = sum(range(n).map(function(i){
            return x[i][j] * x[i][k];
          }));
          for(i = 0; i < n; i++){
            x[i][k] = x[i][k] - x[i][j]*r[j][k];
          }
        }
      }
      return [x, r];
    }

    return qr2;
  }()),

  lstsq: (function() {
    // solve least squard problem for Ax=b as QR decomposition way if b is
    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution
    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution
    function R_I(A) {
      A = jStat.copy(A);
      var size = A.length;
      var I = jStat.identity(size);
      jStat.arange(size - 1, -1, -1).forEach(function(i) {
        jStat.sliceAssign(
            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));
        jStat.sliceAssign(
            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));
        jStat.arange(i).forEach(function(j) {
          var c = jStat.multiply(A[j][i], -1);
          var Aj = jStat.slice(A, { row: j });
          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);
          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));
          var Ij = jStat.slice(I, { row: j });
          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);
          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));
        })
      });
      return I;
    }

    function qr_solve(A, b){
      var array_mode = false;
      if (b[0].length === undefined) {
        // [c1,c2,c3] mode
        b = b.map(function(x){ return [x] });
        array_mode = true;
      }
      var QR = jStat.QR(A);
      var Q = QR[0];
      var R = QR[1];
      var attrs = A[0].length;
      var Q1 = jStat.slice(Q,{col:{end:attrs}});
      var R1 = jStat.slice(R,{row:{end:attrs}});
      var RI = R_I(R1);
      var Q2 = jStat.transpose(Q1);

      if(Q2[0].length === undefined){
        Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.
      }

      var x = jStat.multiply(jStat.multiply(RI, Q2), b);

      if(x.length === undefined){
        x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.
      }


      if (array_mode)
        return x.map(function(i){ return i[0] });
      return x;
    }

    return qr_solve;
  }()),

  jacobi: function jacobi(a) {
    var condition = 1;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var h_min = Math.abs(x - X[pos(X, x) + 1]);
    var i = 0;
    var g = [];
    var h1 = [];
    var y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
        h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));

}(jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;
var isArray = jStat.utils.isArray;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    var z;
    if (isArray(args[1])) {
      // (value, array, sides, flag)
      z = jStat.zscore(args[0],args[1],args[3]);
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
    } else {
      if (args.length > 2) {
        // (value, mean, sd, sides)
        z = jStat.zscore(args[0],args[1],args[2]);
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      } else {
        // (zscore, sides)
        z = args[0];
        return (args[1] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)*2);
      }
    }
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    var anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Tukey's range test
jStat.extend({
  // 2 parameter lists
  // (mean1, mean2, n1, n2, sd)
  // (array1, array2, sd)
  qscore: function qscore() {
    var args = slice.call(arguments);
    var mean1, mean2, n1, n2, sd;
    if (isNumber(args[0])) {
        mean1 = args[0];
        mean2 = args[1];
        n1 = args[2];
        n2 = args[3];
        sd = args[4];
    } else {
        mean1 = jStat.mean(args[0]);
        mean2 = jStat.mean(args[1]);
        n1 = args[0].length;
        n2 = args[1].length;
        sd = args[2];
    }
    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));
  },

  // 3 different parameter lists:
  // (qscore, n, k)
  // (mean1, mean2, n1, n2, sd, n, k)
  // (array1, array2, sd, n, k)
  qtest: function qtest() {
    var args = slice.call(arguments);

    var qscore;
    if (args.length === 3) {
      qscore = args[0];
      args = args.slice(1);
    } else if (args.length === 7) {
      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);
      args = args.slice(5);
    } else {
      qscore = jStat.qscore(args[0], args[1], args[2]);
      args = args.slice(3);
    }

    var n = args[0];
    var k = args[1];

    return 1 - jStat.tukey.cdf(qscore, k, n - k);
  },

  tukeyhsd: function tukeyhsd(arrays) {
    var sd = jStat.pooledstdev(arrays);
    var means = arrays.map(function (arr) {return jStat.mean(arr);});
    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);

    var results = [];
    for (var i = 0; i < arrays.length; ++i) {
        for (var j = i + 1; j < arrays.length; ++j) {
            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);
            results.push([[i, j], p]);
        }
    }

    return results;
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

// internal method for calculating the z-score for a difference of proportions test
function differenceOfProportions(p1, n1, p2, n2) {
  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
    throw new Error("Proportions should be greater than 0 and less than 1")
  }
  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));
  return (p1 - p2) / se;
}

// Difference of Proportions
jStat.extend(jStat.fn, {
  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 1);
  },

  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 2);
  }
});

}(jStat, Math));
jStat.models = (function(){
  function sub_regress(exog) {
    var var_count = exog[0].length;
    var modelList = jStat.arange(var_count).map(function(endog_index) {
      var exog_index =
          jStat.arange(var_count).filter(function(i){return i!==endog_index});
      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),
                 jStat.col(exog, exog_index))
    });
    return modelList;
  }

  // do OLS model regress
  // exog have include const columns ,it will not generate it .In fact, exog is
  // "design matrix" look at
  //https://en.wikipedia.org/wiki/Design_matrix
  function ols(endog, exog) {
    var nobs = endog.length;
    var df_model = exog[0].length - 1;
    var df_resid = nobs-df_model - 1;
    var coef = jStat.lstsq(exog, endog);
    var predict =
        jStat.multiply(exog, coef.map(function(x) { return [x] }))
            .map(function(p) { return p[0] });
    var resid = jStat.subtract(endog, predict);
    var ybar = jStat.mean(endog);
    // constant cause problem
    // var SST = jStat.sum(endog.map(function(y) {
    //   return Math.pow(y-ybar,2);
    // }));
    var SSE = jStat.sum(predict.map(function(f) {
      return Math.pow(f - ybar, 2);
    }));
    var SSR = jStat.sum(endog.map(function(y, i) {
      return Math.pow(y - predict[i], 2);
    }));
    var SST = SSE + SSR;
    var R2 = (SSE / SST);
    return {
        exog:exog,
        endog:endog,
        nobs:nobs,
        df_model:df_model,
        df_resid:df_resid,
        coef:coef,
        predict:predict,
        resid:resid,
        ybar:ybar,
        SST:SST,
        SSE:SSE,
        SSR:SSR,
        R2:R2
    };
  }

  // H0: b_I=0
  // H1: b_I!=0
  function t_test(model) {
    var subModelList = sub_regress(model.exog);
    //var sigmaHat=jStat.stdev(model.resid);
    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));
    var seBetaHat = subModelList.map(function(mod) {
      var SST = mod.SST;
      var R2 = mod.R2;
      return sigmaHat / Math.sqrt(SST * (1 - R2));
    });
    var tStatistic = model.coef.map(function(coef, i) {
      return (coef - 0) / seBetaHat[i];
    });
    var pValue = tStatistic.map(function(t) {
      var leftppf = jStat.studentt.cdf(t, model.df_resid);
      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
    });
    var c = jStat.studentt.inv(0.975, model.df_resid);
    var interval95 = model.coef.map(function(coef, i) {
      var d = c * seBetaHat[i];
      return [coef - d, coef + d];
    })
    return {
        se: seBetaHat,
        t: tStatistic,
        p: pValue,
        sigmaHat: sigmaHat,
        interval95: interval95
    };
  }

  function F_test(model) {
    var F_statistic =
        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);
    var fcdf = function(x, n1, n2) {
      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)
    }
    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
    return { F_statistic: F_statistic, pvalue: pvalue };
  }

  function ols_wrap(endog, exog) {
    var model = ols(endog,exog);
    var ttest = t_test(model);
    var ftest = F_test(model);
    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2
    // Which matches the 'adjusted R^2' provided by R's lm package
    var adjust_R2 =
        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));
    model.t = ttest;
    model.f = ftest;
    model.adjust_R2 = adjust_R2;
    return model;
  }

  return { ols: ols_wrap };
})();
//To regress, simply build X matrix
//(append column of 1's) using
//buildxmatrix and build the Y
//matrix using buildymatrix
//(simply the transpose)
//and run regress.



//Regressions

jStat.extend({
  buildxmatrix: function buildxmatrix(){
    //Parameters will be passed in as such
    //(array1,array2,array3,...)
    //as (x1,x2,x3,...)
    //needs to be (1,x1,x2,x3,...)
    var matrixRows = new Array(arguments.length);
    for(var i=0;i<arguments.length;i++){
      var array = [1];
      matrixRows[i]= array.concat(arguments[i]);
    }
    return jStat(matrixRows);

  },

  builddxmatrix: function builddxmatrix() {
    //Paramters will be passed in as such
    //([array1,array2,...]
    var matrixRows = new Array(arguments[0].length);
    for(var i=0;i<arguments[0].length;i++){
      var array = [1]
      matrixRows[i]= array.concat(arguments[0][i]);
    }
    return jStat(matrixRows);

  },

  buildjxmatrix: function buildjxmatrix(jMat) {
    //Builds from jStat Matrix
    var pass = new Array(jMat.length)
    for(var i=0;i<jMat.length;i++){
      pass[i] = jMat[i];
    }
    return jStat.builddxmatrix(pass);

  },

  buildymatrix: function buildymatrix(array){
    return jStat(array).transpose();
  },

  buildjymatrix: function buildjymatrix(jMat){
    return jMat.transpose();
  },

  matrixmult: function matrixmult(A,B){
    var i, j, k, result, sum;
    if (A.cols() == B.rows()) {
      if(B.rows()>1){
        result = [];
        for (i = 0; i < A.rows(); i++) {
          result[i] = [];
          for (j = 0; j < B.cols(); j++) {
            sum = 0;
            for (k = 0; k < A.cols(); k++) {
              sum += A.toArray()[i][k] * B.toArray()[k][j];
            }
            result[i][j] = sum;
          }
        }
        return jStat(result);
      }
      result = [];
      for (i = 0; i < A.rows(); i++) {
        result[i] = [];
        for (j = 0; j < B.cols(); j++) {
          sum = 0;
          for (k = 0; k < A.cols(); k++) {
            sum += A.toArray()[i][k] * B.toArray()[j];
          }
          result[i][j] = sum;
        }
      }
      return jStat(result);
    }
  },

  //regress and regresst to be fixed

  regress: function regress(jMatX,jMatY){
    //print("regressin!");
    //print(jMatX.toArray());
    var innerinv = jStat.xtranspxinv(jMatX);
    //print(innerinv);
    var xtransp = jMatX.transpose();
    var next = jStat.matrixmult(jStat(innerinv),xtransp);
    return jStat.matrixmult(next,jMatY);

  },

  regresst: function regresst(jMatX,jMatY,sides){
    var beta = jStat.regress(jMatX,jMatY);

    var compile = {};
    compile.anova = {};
    var jMatYBar = jStat.jMatYBar(jMatX, beta);
    compile.yBar = jMatYBar;
    var yAverage = jMatY.mean();
    compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);

    compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
    compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);

    compile.anova.sse = jStat.sse(jMatY, jMatYBar);
    compile.anova.mse =
        compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);

    compile.anova.sst = jStat.sst(jMatY, yAverage);
    compile.anova.mst = compile.anova.sst / (jMatY.length - 1);

    compile.anova.r2 = 1 - (compile.anova.sse / compile.anova.sst);
    if (compile.anova.r2 < 0) compile.anova.r2 = 0;

    compile.anova.fratio = compile.anova.msr / compile.anova.mse;
    compile.anova.pvalue =
        jStat.anovaftest(compile.anova.fratio,
                         jMatX[0].length - 1,
                         jMatY.length - (jMatX[0].length - 1) - 1);

    compile.anova.rmse = Math.sqrt(compile.anova.mse);

    compile.anova.r2adj = 1 - (compile.anova.mse / compile.anova.mst);
    if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;

    compile.stats = new Array(jMatX[0].length);
    var covar = jStat.xtranspxinv(jMatX);
    var sds, ts, ps;

    for(var i=0; i<beta.length;i++){
      sds=Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));
      ts= Math.abs(beta[i] / sds);
      ps= jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);

      compile.stats[i]=[beta[i], sds, ts, ps];
    }

    compile.regress = beta;
    return compile;
  },

  xtranspx: function xtranspx(jMatX){
    return jStat.matrixmult(jMatX.transpose(),jMatX);
  },


  xtranspxinv: function xtranspxinv(jMatX){
    var inner = jStat.matrixmult(jMatX.transpose(),jMatX);
    var innerinv = jStat.inv(inner);
    return innerinv;
  },

  jMatYBar: function jMatYBar(jMatX, beta) {
    var yBar = jStat.matrixmult(jMatX, beta);
    return new jStat(yBar);
  },

  residuals: function residuals(jMatY, jMatYBar) {
    return jStat.matrixsubtract(jMatY, jMatYBar);
  },

  ssr: function ssr(jMatYBar, yAverage) {
    var ssr = 0;
    for(var i = 0; i < jMatYBar.length; i++) {
      ssr += Math.pow(jMatYBar[i] - yAverage, 2);
    }
    return ssr;
  },

  sse: function sse(jMatY, jMatYBar) {
    var sse = 0;
    for(var i = 0; i < jMatY.length; i++) {
      sse += Math.pow(jMatY[i] - jMatYBar[i], 2);
    }
    return sse;
  },

  sst: function sst(jMatY, yAverage) {
    var sst = 0;
    for(var i = 0; i < jMatY.length; i++) {
      sst += Math.pow(jMatY[i] - yAverage, 2);
    }
    return sst;
  },

  matrixsubtract: function matrixsubtract(A,B){
    var ans = new Array(A.length);
    for(var i=0;i<A.length;i++){
      ans[i] = new Array(A[i].length);
      for(var j=0;j<A[i].length;j++){
        ans[i][j]=A[i][j]-B[i][j];
      }
    }
    return jStat(ans);
  }
});
  // Make it compatible with previous version.
  jStat.jStat = jStat;

  return jStat;
});


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jstat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(789);
/* harmony import */ var jstat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jstat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in jstat__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => jstat__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
// @ts-ignore


})();

jStat = __webpack_exports__;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRDtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsNENBQTRDLGdDQUFnQztBQUM1RTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QTtTQUNBOzs7OztVQ3RCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsaUNBQWlDLFdBQVc7VUFDNUM7VUFDQTs7Ozs7VUNQQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLHlDQUF5Qyx3Q0FBd0M7VUFDakY7VUFDQTtVQUNBOzs7OztVQ1BBOzs7OztVQ0FBO1VBQ0E7VUFDQTtVQUNBLHVEQUF1RCxpQkFBaUI7VUFDeEU7VUFDQSxnREFBZ0QsYUFBYTtVQUM3RDs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ3NCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qc3RhdC9kaXN0L2pzdGF0LmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHdpbmRvdywgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5qU3RhdCA9IGZhY3RvcnkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG52YXIgalN0YXQgPSAoZnVuY3Rpb24oTWF0aCwgdW5kZWZpbmVkKSB7XG5cbi8vIEZvciBxdWljayByZWZlcmVuY2UuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIENhbGN1bGF0ZSBjb3JyZWN0aW9uIGZvciBJRUVFIGVycm9yXG4vLyBUT0RPOiBUaGlzIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXByb3ZlZC5cbmZ1bmN0aW9uIGNhbGNSZHgobiwgbSkge1xuICB2YXIgdmFsID0gbiA+IG0gPyBuIDogbTtcbiAgcmV0dXJuIE1hdGgucG93KDEwLFxuICAgICAgICAgICAgICAgICAgMTcgLSB+fihNYXRoLmxvZygoKHZhbCA+IDApID8gdmFsIDogLXZhbCkpICogTWF0aC5MT0cxMEUpKTtcbn1cblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuXG5mdW5jdGlvbiBpc051bWJlcihudW0pIHtcbiAgcmV0dXJuICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykgPyBudW0gLSBudW0gPT09IDAgOiBmYWxzZTtcbn1cblxuXG4vLyBDb252ZXJ0cyB0aGUgalN0YXQgbWF0cml4IHRvIHZlY3Rvci5cbmZ1bmN0aW9uIHRvVmVjdG9yKGFycikge1xuICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG5cbi8vIFRoZSBvbmUgYW5kIG9ubHkgalN0YXQgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBqU3RhdCgpIHtcbiAgcmV0dXJuIG5ldyBqU3RhdC5faW5pdChhcmd1bWVudHMpO1xufVxuXG5cbi8vIFRPRE86IFJlbW92ZSBhZnRlciBhbGwgcmVmZXJlbmNlcyBpbiBzcmMgZmlsZXMgaGF2ZSBiZWVuIHJlbW92ZWQuXG5qU3RhdC5mbiA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpbml0aWFsaXplciBmcm9tIHRoZSBjb25zdHJ1Y3RvciBpdCdzIGVhc2llciB0byBoYW5kbGVcbi8vIGFsd2F5cyByZXR1cm5pbmcgYSBuZXcgaW5zdGFuY2Ugd2hldGhlciBcIm5ld1wiIHdhcyB1c2VkIG9yIG5vdC5cbmpTdGF0Ll9pbml0ID0gZnVuY3Rpb24gX2luaXQoYXJncykge1xuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgbXVzdCBiZSB2ZWN0b3Igb3IgbWF0cml4LlxuICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgIC8vIENoZWNrIGlmIG1hdHJpeC5cbiAgICBpZiAoaXNBcnJheShhcmdzWzBdWzBdKSkge1xuICAgICAgLy8gU2VlIGlmIGEgbWFwcGluZyBmdW5jdGlvbiB3YXMgYWxzbyBwYXNzZWQuXG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzWzFdKSlcbiAgICAgICAgYXJnc1swXSA9IGpTdGF0Lm1hcChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGlzIGZhc3RlciB0aGFuIHRoaXMucHVzaC5hcHBseSh0aGlzLCBhcmdzWzBdLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzWzBdLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzW2ldID0gYXJnc1swXVtpXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gYXJnc1swXS5sZW5ndGg7XG5cbiAgICAvLyBPdGhlcndpc2UgbXVzdCBiZSBhIHZlY3Rvci5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1swXSA9IGlzRnVuY3Rpb24oYXJnc1sxXSkgPyBqU3RhdC5tYXAoYXJnc1swXSwgYXJnc1sxXSkgOiBhcmdzWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBudW1iZXIsIGFzc3VtZSBjcmVhdGlvbiBvZiBzZXF1ZW5jZS5cbiAgfSBlbHNlIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgIHRoaXNbMF0gPSBqU3RhdC5zZXEuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZW4galN0YXQgb2JqZWN0IGlzIHBhc3NlZCB0byBqU3RhdC5cbiAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgalN0YXQpIHtcbiAgICAvLyBEdXBsaWNhdGUgdGhlIG9iamVjdCBhbmQgcGFzcyBpdCBiYWNrLlxuICAgIHJldHVybiBqU3RhdChhcmdzWzBdLnRvQXJyYXkoKSk7XG5cbiAgLy8gVW5leHBlY3RlZCBhcmd1bWVudCB2YWx1ZSwgcmV0dXJuIGVtcHR5IGpTdGF0IG9iamVjdC5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdHJhbmdlIGJlaGF2aW9yLiBTaG91bGRuJ3QgdGhpcyB0aHJvdyBvciBzb21lIHN1Y2ggdG8gbGV0XG4gIC8vIHRoZSB1c2VyIGtub3cgdGhleSBoYWQgYmFkIGFyZ3VtZW50cz9cbiAgfSBlbHNlIHtcbiAgICB0aGlzWzBdID0gW107XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xualN0YXQuX2luaXQucHJvdG90eXBlID0galN0YXQucHJvdG90eXBlO1xualN0YXQuX2luaXQuY29uc3RydWN0b3IgPSBqU3RhdDtcblxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucy5cbi8vIFRPRE86IGZvciBpbnRlcm5hbCB1c2Ugb25seT9cbmpTdGF0LnV0aWxzID0ge1xuICBjYWxjUmR4OiBjYWxjUmR4LFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIHRvVmVjdG9yOiB0b1ZlY3RvclxufTtcblxuXG5qU3RhdC5fcmFuZG9tX2ZuID0gTWF0aC5yYW5kb207XG5qU3RhdC5zZXRSYW5kb20gPSBmdW5jdGlvbiBzZXRSYW5kb20oZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmbiBpcyBub3QgYSBmdW5jdGlvbicpO1xuICBqU3RhdC5fcmFuZG9tX2ZuID0gZm47XG59O1xuXG5cbi8vIEVhc2lseSBleHRlbmQgdGhlIGpTdGF0IG9iamVjdC5cbi8vIFRPRE86IGlzIHRoaXMgc2VyaW91c2x5IG5lY2Vzc2FyeT9cbmpTdGF0LmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmb3IgKGogaW4gb2JqKVxuICAgICAgalN0YXRbal0gPSBvYmpbal07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChqIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgIG9ialtqXSA9IGFyZ3VtZW50c1tpXVtqXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXguXG5qU3RhdC5yb3dzID0gZnVuY3Rpb24gcm93cyhhcnIpIHtcbiAgcmV0dXJuIGFyci5sZW5ndGggfHwgMTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeC5cbmpTdGF0LmNvbHMgPSBmdW5jdGlvbiBjb2xzKGFycikge1xuICByZXR1cm4gYXJyWzBdLmxlbmd0aCB8fCAxO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgeyByb3dzOiBpLCBjb2xzOiBqIH1cbmpTdGF0LmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKGFycikge1xuICByZXR1cm4ge1xuICAgIHJvd3M6IGpTdGF0LnJvd3MoYXJyKSxcbiAgICBjb2xzOiBqU3RhdC5jb2xzKGFycilcbiAgfTtcbn07XG5cblxuLy8gUmV0dXJucyBhIHNwZWNpZmllZCByb3cgYXMgYSB2ZWN0b3Igb3IgcmV0dXJuIGEgc3ViIG1hdHJpeCBieSBwaWNrIHNvbWUgcm93c1xualN0YXQucm93ID0gZnVuY3Rpb24gcm93KGFyciwgaW5kZXgpIHtcbiAgaWYgKGlzQXJyYXkoaW5kZXgpKSB7XG4gICAgcmV0dXJuIGluZGV4Lm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4galN0YXQucm93KGFyciwgaSk7XG4gICAgfSlcbiAgfVxuICByZXR1cm4gYXJyW2luZGV4XTtcbn07XG5cblxuLy8gcmV0dXJuIHJvdyBhcyBhcnJheVxuLy8gcm93YShbWzEsMl0sWzMsNF1dLDApIC0+IFsxLDJdXG5qU3RhdC5yb3dhID0gZnVuY3Rpb24gcm93YShhcnIsIGkpIHtcbiAgcmV0dXJuIGpTdGF0LnJvdyhhcnIsIGkpO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgY29sdW1uIGFzIGEgdmVjdG9yIG9yIHJldHVybiBhIHN1YiBtYXRyaXggYnkgcGljayBzb21lXG4vLyBjb2x1bW5zXG5qU3RhdC5jb2wgPSBmdW5jdGlvbiBjb2woYXJyLCBpbmRleCkge1xuICBpZiAoaXNBcnJheShpbmRleCkpIHtcbiAgICB2YXIgc3VibWF0ID0galN0YXQuYXJhbmdlKGFyci5sZW5ndGgpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkoaW5kZXgubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBpbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGluZCwgaSl7XG4gICAgICBqU3RhdC5hcmFuZ2UoYXJyLmxlbmd0aCkuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgIHN1Ym1hdFtqXVtpXSA9IGFycltqXVtpbmRdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Ym1hdDtcbiAgfVxuICB2YXIgY29sdW1uID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2x1bW5baV0gPSBbYXJyW2ldW2luZGV4XV07XG4gIHJldHVybiBjb2x1bW47XG59O1xuXG5cbi8vIHJldHVybiBjb2x1bW4gYXMgYXJyYXlcbi8vIGNvbGEoW1sxLDJdLFszLDRdXSwwKSAtPiBbMSwzXVxualN0YXQuY29sYSA9IGZ1bmN0aW9uIGNvbGEoYXJyLCBpKSB7XG4gIHJldHVybiBqU3RhdC5jb2woYXJyLCBpKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBhWzBdIH0pO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaWFnb25hbCBvZiB0aGUgbWF0cml4XG5qU3RhdC5kaWFnID0gZnVuY3Rpb24gZGlhZyhhcnIpIHtcbiAgdmFyIG5yb3cgPSBqU3RhdC5yb3dzKGFycik7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobnJvdyk7XG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKVxuICAgIHJlc1tyb3ddID0gW2Fycltyb3ddW3Jvd11dO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBhbnRpLWRpYWdvbmFsIG9mIHRoZSBtYXRyaXhcbmpTdGF0LmFudGlkaWFnID0gZnVuY3Rpb24gYW50aWRpYWcoYXJyKSB7XG4gIHZhciBucm93ID0galN0YXQucm93cyhhcnIpIC0gMTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShucm93KTtcbiAgZm9yICh2YXIgaSA9IDA7IG5yb3cgPj0gMDsgbnJvdy0tLCBpKyspXG4gICAgcmVzW2ldID0gW2FycltpXVtucm93XV07XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBUcmFuc3Bvc2UgYSBtYXRyaXggb3IgYXJyYXkuXG5qU3RhdC50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoYXJyKSB7XG4gIHZhciBvYmogPSBbXTtcbiAgdmFyIG9iakFyciwgcm93cywgY29scywgaiwgaTtcblxuICAvLyBNYWtlIHN1cmUgYXJyIGlzIGluIG1hdHJpeCBmb3JtYXQuXG4gIGlmICghaXNBcnJheShhcnJbMF0pKVxuICAgIGFyciA9IFthcnJdO1xuXG4gIHJvd3MgPSBhcnIubGVuZ3RoO1xuICBjb2xzID0gYXJyWzBdLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgb2JqQXJyID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAoaiA9IDA7IGogPCByb3dzOyBqKyspXG4gICAgICBvYmpBcnJbal0gPSBhcnJbal1baV07XG4gICAgb2JqLnB1c2gob2JqQXJyKTtcbiAgfVxuXG4gIC8vIElmIG9iaiBpcyB2ZWN0b3IsIHJldHVybiBvbmx5IHNpbmdsZSBhcnJheS5cbiAgcmV0dXJuIG9iai5sZW5ndGggPT09IDEgPyBvYmpbMF0gOiBvYmo7XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGFuIGFycmF5IG9yIGFycmF5IG9mIGFycmF5cy5cbi8vIFwidG9BbHRlclwiIGlzIGFuIGludGVybmFsIHZhcmlhYmxlLlxualN0YXQubWFwID0gZnVuY3Rpb24gbWFwKGFyciwgZnVuYywgdG9BbHRlcikge1xuICB2YXIgcm93LCBucm93LCBuY29sLCByZXMsIGNvbDtcblxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICBucm93ID0gYXJyLmxlbmd0aDtcbiAgbmNvbCA9IGFyclswXS5sZW5ndGg7XG4gIHJlcyA9IHRvQWx0ZXIgPyBhcnIgOiBuZXcgQXJyYXkobnJvdyk7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgIC8vIGlmIHRoZSByb3cgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFyZXNbcm93XSlcbiAgICAgIHJlc1tyb3ddID0gbmV3IEFycmF5KG5jb2wpO1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICByZXNbcm93XVtjb2xdID0gZnVuYyhhcnJbcm93XVtjb2xdLCByb3csIGNvbCk7XG4gIH1cblxuICByZXR1cm4gcmVzLmxlbmd0aCA9PT0gMSA/IHJlc1swXSA6IHJlcztcbn07XG5cblxuLy8gQ3VtdWxhdGl2ZWx5IGNvbWJpbmUgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG9yIGFycmF5IG9mIGFycmF5cyB1c2luZyBhIGZ1bmN0aW9uLlxualN0YXQuY3VtcmVkdWNlID0gZnVuY3Rpb24gY3VtcmVkdWNlKGFyciwgZnVuYywgdG9BbHRlcikge1xuICB2YXIgcm93LCBucm93LCBuY29sLCByZXMsIGNvbDtcblxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICBucm93ID0gYXJyLmxlbmd0aDtcbiAgbmNvbCA9IGFyclswXS5sZW5ndGg7XG4gIHJlcyA9IHRvQWx0ZXIgPyBhcnIgOiBuZXcgQXJyYXkobnJvdyk7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgIC8vIGlmIHRoZSByb3cgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFyZXNbcm93XSlcbiAgICAgIHJlc1tyb3ddID0gbmV3IEFycmF5KG5jb2wpO1xuICAgIGlmIChuY29sID4gMClcbiAgICAgIHJlc1tyb3ddWzBdID0gYXJyW3Jvd11bMF07XG4gICAgZm9yIChjb2wgPSAxOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHJlc1tyb3ddW2NvbF0gPSBmdW5jKHJlc1tyb3ddW2NvbC0xXSwgYXJyW3Jvd11bY29sXSk7XG4gIH1cbiAgcmV0dXJuIHJlcy5sZW5ndGggPT09IDEgPyByZXNbMF0gOiByZXM7XG59O1xuXG5cbi8vIERlc3RydWN0aXZlbHkgYWx0ZXIgYW4gYXJyYXkuXG5qU3RhdC5hbHRlciA9IGZ1bmN0aW9uIGFsdGVyKGFyciwgZnVuYykge1xuICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuYywgdHJ1ZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uXG5qU3RhdC5jcmVhdGUgPSBmdW5jdGlvbiAgY3JlYXRlKHJvd3MsIGNvbHMsIGZ1bmMpIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShyb3dzKTtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29scykpIHtcbiAgICBmdW5jID0gY29scztcbiAgICBjb2xzID0gcm93cztcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICByZXNbaV0gPSBuZXcgQXJyYXkoY29scyk7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHM7IGorKylcbiAgICAgIHJlc1tpXVtqXSA9IGZ1bmMoaSwgaik7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG5mdW5jdGlvbiByZXRaZXJvKCkgeyByZXR1cm4gMDsgfVxuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHplcm9zLlxualN0YXQuemVyb3MgPSBmdW5jdGlvbiB6ZXJvcyhyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0WmVybyk7XG59O1xuXG5cbmZ1bmN0aW9uIHJldE9uZSgpIHsgcmV0dXJuIDE7IH1cblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiBvbmVzLlxualN0YXQub25lcyA9IGZ1bmN0aW9uIG9uZXMocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldE9uZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHVuaWZvcm1seSByYW5kb20gbnVtYmVycy5cbmpTdGF0LnJhbmQgPSBmdW5jdGlvbiByYW5kKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCBqU3RhdC5fcmFuZG9tX2ZuKTtcbn07XG5cblxuZnVuY3Rpb24gcmV0SWRlbnQoaSwgaikgeyByZXR1cm4gaSA9PT0gaiA/IDEgOiAwOyB9XG5cblxuLy8gR2VuZXJhdGUgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgcm93IHggY29scy5cbmpTdGF0LmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldElkZW50KTtcbn07XG5cblxuLy8gVGVzdHMgd2hldGhlciBhIG1hdHJpeCBpcyBzeW1tZXRyaWNcbmpTdGF0LnN5bW1ldHJpYyA9IGZ1bmN0aW9uIHN5bW1ldHJpYyhhcnIpIHtcbiAgdmFyIHNpemUgPSBhcnIubGVuZ3RoO1xuICB2YXIgcm93LCBjb2w7XG5cbiAgaWYgKGFyci5sZW5ndGggIT09IGFyclswXS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAocm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKVxuICAgICAgaWYgKGFycltjb2xdW3Jvd10gIT09IGFycltyb3ddW2NvbF0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBTZXQgYWxsIHZhbHVlcyB0byB6ZXJvLlxualN0YXQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgcmV0WmVybyk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHNlcXVlbmNlLlxualN0YXQuc2VxID0gZnVuY3Rpb24gc2VxKG1pbiwgbWF4LCBsZW5ndGgsIGZ1bmMpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKVxuICAgIGZ1bmMgPSBmYWxzZTtcblxuICB2YXIgYXJyID0gW107XG4gIHZhciBoaXZhbCA9IGNhbGNSZHgobWluLCBtYXgpO1xuICB2YXIgc3RlcCA9IChtYXggKiBoaXZhbCAtIG1pbiAqIGhpdmFsKSAvICgobGVuZ3RoIC0gMSkgKiBoaXZhbCk7XG4gIHZhciBjdXJyZW50ID0gbWluO1xuICB2YXIgY250O1xuXG4gIC8vIEN1cnJlbnQgaXMgYXNzaWduZWQgdXNpbmcgYSB0ZWNobmlxdWUgdG8gY29tcGVuc2F0ZSBmb3IgSUVFRSBlcnJvci5cbiAgLy8gVE9ETzogTmVlZHMgYmV0dGVyIGltcGxlbWVudGF0aW9uLlxuICBmb3IgKGNudCA9IDA7XG4gICAgICAgY3VycmVudCA8PSBtYXggJiYgY250IDwgbGVuZ3RoO1xuICAgICAgIGNudCsrLCBjdXJyZW50ID0gKG1pbiAqIGhpdmFsICsgc3RlcCAqIGhpdmFsICogY250KSAvIGhpdmFsKSB7XG4gICAgYXJyLnB1c2goKGZ1bmMgPyBmdW5jKGN1cnJlbnQsIGNudCkgOiBjdXJyZW50KSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuXG4vLyBhcmFuZ2UoNSkgLT4gWzAsMSwyLDMsNF1cbi8vIGFyYW5nZSgxLDUpIC0+IFsxLDIsMyw0XVxuLy8gYXJhbmdlKDUsMSwtMSkgLT4gWzUsNCwzLDJdXG5qU3RhdC5hcmFuZ2UgPSBmdW5jdGlvbiBhcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICB2YXIgcmwgPSBbXTtcbiAgdmFyIGk7XG4gIHN0ZXAgPSBzdGVwIHx8IDE7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoc3RhcnQgPT09IGVuZCB8fCBzdGVwID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChzdGFydCA8IGVuZCAmJiBzdGVwIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQgJiYgc3RlcCA+IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gc3RlcCkge1xuICAgICAgcmwucHVzaChpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPiBlbmQ7IGkgKz0gc3RlcCkge1xuICAgICAgcmwucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJsO1xufTtcblxuXG4vLyBBPVtbMSwyLDNdLFs0LDUsNl0sWzcsOCw5XV1cbi8vIHNsaWNlKEEse3Jvdzp7ZW5kOjJ9LGNvbDp7c3RhcnQ6MX19KSAtPiBbWzIsM10sWzUsNl1dXG4vLyBzbGljZShBLDEse3N0YXJ0OjF9KSAtPiBbNSw2XVxuLy8gYXMgbnVtcHkgY29kZSBBWzoyLDE6XVxualN0YXQuc2xpY2UgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gX3NsaWNlKGxpc3QsIHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAvLyBub3RlIGl0J3Mgbm90IGVxdWFsIHRvIHJhbmdlLm1hcCBtb2RlIGl0J3MgYSBidWdcbiAgICB2YXIgaTtcbiAgICB2YXIgcmwgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQgJiYgc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4galN0YXQuY29weShsaXN0KTtcbiAgICB9XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgZW5kID0gZW5kIHx8IGxpc3QubGVuZ3RoO1xuICAgIHN0YXJ0ID0gc3RhcnQgPj0gMCA/IHN0YXJ0IDogbGVuZ3RoICsgc3RhcnQ7XG4gICAgZW5kID0gZW5kID49IDAgPyBlbmQgOiBsZW5ndGggKyBlbmQ7XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCBzdGVwID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGVuZCAmJiBzdGVwIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPiBlbmQgJiYgc3RlcCA+IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBzdGVwKSB7XG4gICAgICAgIHJsLnB1c2gobGlzdFtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHN0YXJ0OyBpID4gZW5kO2kgKz0gc3RlcCkge1xuICAgICAgICBybC5wdXNoKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmw7XG4gIH1cblxuICBmdW5jdGlvbiBzbGljZShsaXN0LCByY1NsaWNlKSB7XG4gICAgdmFyIGNvbFNsaWNlLCByb3dTbGljZTtcbiAgICByY1NsaWNlID0gcmNTbGljZSB8fCB7fTtcbiAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5yb3cpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5jb2wpKVxuICAgICAgICByZXR1cm4gbGlzdFtyY1NsaWNlLnJvd11bcmNTbGljZS5jb2xdO1xuICAgICAgdmFyIHJvdyA9IGpTdGF0LnJvd2EobGlzdCwgcmNTbGljZS5yb3cpO1xuICAgICAgY29sU2xpY2UgPSByY1NsaWNlLmNvbCB8fCB7fTtcbiAgICAgIHJldHVybiBfc2xpY2Uocm93LCBjb2xTbGljZS5zdGFydCwgY29sU2xpY2UuZW5kLCBjb2xTbGljZS5zdGVwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5jb2wpKSB7XG4gICAgICB2YXIgY29sID0galN0YXQuY29sYShsaXN0LCByY1NsaWNlLmNvbCk7XG4gICAgICByb3dTbGljZSA9IHJjU2xpY2Uucm93IHx8IHt9O1xuICAgICAgcmV0dXJuIF9zbGljZShjb2wsIHJvd1NsaWNlLnN0YXJ0LCByb3dTbGljZS5lbmQsIHJvd1NsaWNlLnN0ZXApO1xuICAgIH1cblxuICAgIHJvd1NsaWNlID0gcmNTbGljZS5yb3cgfHwge307XG4gICAgY29sU2xpY2UgPSByY1NsaWNlLmNvbCB8fCB7fTtcbiAgICB2YXIgcm93cyA9IF9zbGljZShsaXN0LCByb3dTbGljZS5zdGFydCwgcm93U2xpY2UuZW5kLCByb3dTbGljZS5zdGVwKTtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gX3NsaWNlKHJvdywgY29sU2xpY2Uuc3RhcnQsIGNvbFNsaWNlLmVuZCwgY29sU2xpY2Uuc3RlcCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2xpY2U7XG59KCkpO1xuXG5cbi8vIEE9W1sxLDIsM10sWzQsNSw2XSxbNyw4LDldXVxuLy8gc2xpY2VBc3NpZ24oQSx7cm93OntzdGFydDoxfSxjb2w6e3N0YXJ0OjF9fSxbWzAsMF0sWzAsMF1dKVxuLy8gQT1bWzEsMiwzXSxbNCwwLDBdLFs3LDAsMF1dXG5qU3RhdC5zbGljZUFzc2lnbiA9IGZ1bmN0aW9uIHNsaWNlQXNzaWduKEEsIHJjU2xpY2UsIEIpIHtcbiAgdmFyIG5sLCBtbDtcbiAgaWYgKGlzTnVtYmVyKHJjU2xpY2Uucm93KSkge1xuICAgIGlmIChpc051bWJlcihyY1NsaWNlLmNvbCkpXG4gICAgICByZXR1cm4gQVtyY1NsaWNlLnJvd11bcmNTbGljZS5jb2xdID0gQjtcbiAgICByY1NsaWNlLmNvbCA9IHJjU2xpY2UuY29sIHx8IHt9O1xuICAgIHJjU2xpY2UuY29sLnN0YXJ0ID0gcmNTbGljZS5jb2wuc3RhcnQgfHwgMDtcbiAgICByY1NsaWNlLmNvbC5lbmQgPSByY1NsaWNlLmNvbC5lbmQgfHwgQVswXS5sZW5ndGg7XG4gICAgcmNTbGljZS5jb2wuc3RlcCA9IHJjU2xpY2UuY29sLnN0ZXAgfHwgMTtcbiAgICBubCA9IGpTdGF0LmFyYW5nZShyY1NsaWNlLmNvbC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQS5sZW5ndGgsIHJjU2xpY2UuY29sLmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2UuY29sLnN0ZXApO1xuICAgIHZhciBtID0gcmNTbGljZS5yb3c7XG4gICAgbmwuZm9yRWFjaChmdW5jdGlvbihuLCBpKSB7XG4gICAgICBBW21dW25dID0gQltpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gQTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihyY1NsaWNlLmNvbCkpIHtcbiAgICByY1NsaWNlLnJvdyA9IHJjU2xpY2Uucm93IHx8IHt9O1xuICAgIHJjU2xpY2Uucm93LnN0YXJ0ID0gcmNTbGljZS5yb3cuc3RhcnQgfHwgMDtcbiAgICByY1NsaWNlLnJvdy5lbmQgPSByY1NsaWNlLnJvdy5lbmQgfHwgQS5sZW5ndGg7XG4gICAgcmNTbGljZS5yb3cuc3RlcCA9IHJjU2xpY2Uucm93LnN0ZXAgfHwgMTtcbiAgICBtbCA9IGpTdGF0LmFyYW5nZShyY1NsaWNlLnJvdy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQVswXS5sZW5ndGgsIHJjU2xpY2Uucm93LmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2Uucm93LnN0ZXApO1xuICAgIHZhciBuID0gcmNTbGljZS5jb2w7XG4gICAgbWwuZm9yRWFjaChmdW5jdGlvbihtLCBqKSB7XG4gICAgICBBW21dW25dID0gQltqXTtcbiAgICB9KTtcbiAgICByZXR1cm4gQTtcbiAgfVxuXG4gIGlmIChCWzBdLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgQiA9IFtCXTtcbiAgfVxuICByY1NsaWNlLnJvdy5zdGFydCA9IHJjU2xpY2Uucm93LnN0YXJ0IHx8IDA7XG4gIHJjU2xpY2Uucm93LmVuZCA9IHJjU2xpY2Uucm93LmVuZCB8fCBBLmxlbmd0aDtcbiAgcmNTbGljZS5yb3cuc3RlcCA9IHJjU2xpY2Uucm93LnN0ZXAgfHwgMTtcbiAgcmNTbGljZS5jb2wuc3RhcnQgPSByY1NsaWNlLmNvbC5zdGFydCB8fCAwO1xuICByY1NsaWNlLmNvbC5lbmQgPSByY1NsaWNlLmNvbC5lbmQgfHwgQVswXS5sZW5ndGg7XG4gIHJjU2xpY2UuY29sLnN0ZXAgPSByY1NsaWNlLmNvbC5zdGVwIHx8IDE7XG4gIG1sID0galN0YXQuYXJhbmdlKHJjU2xpY2Uucm93LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQS5sZW5ndGgsIHJjU2xpY2Uucm93LmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICByY1NsaWNlLnJvdy5zdGVwKTtcbiAgbmwgPSBqU3RhdC5hcmFuZ2UocmNTbGljZS5jb2wuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihBWzBdLmxlbmd0aCwgcmNTbGljZS5jb2wuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2UuY29sLnN0ZXApO1xuICBtbC5mb3JFYWNoKGZ1bmN0aW9uKG0sIGkpIHtcbiAgICBubC5mb3JFYWNoKGZ1bmN0aW9uKG4sIGopIHtcbiAgICAgIEFbbV1bbl0gPSBCW2ldW2pdO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIEE7XG59O1xuXG5cbi8vIFsxLDIsM10gLT5cbi8vIFtbMSwwLDBdLFswLDIsMF0sWzAsMCwzXV1cbmpTdGF0LmRpYWdvbmFsID0gZnVuY3Rpb24gZGlhZ29uYWwoZGlhZ0FycmF5KSB7XG4gIHZhciBtYXQgPSBqU3RhdC56ZXJvcyhkaWFnQXJyYXkubGVuZ3RoLCBkaWFnQXJyYXkubGVuZ3RoKTtcbiAgZGlhZ0FycmF5LmZvckVhY2goZnVuY3Rpb24odCwgaSkge1xuICAgIG1hdFtpXVtpXSA9IHQ7XG4gIH0pO1xuICByZXR1cm4gbWF0O1xufTtcblxuXG4vLyByZXR1cm4gY29weSBvZiBBXG5qU3RhdC5jb3B5ID0gZnVuY3Rpb24gY29weShBKSB7XG4gIHJldHVybiBBLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICBpZiAoaXNOdW1iZXIocm93KSlcbiAgICAgIHJldHVybiByb3c7XG4gICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuXG4vLyBUT0RPOiBHbyBvdmVyIHRoaXMgZW50aXJlIGltcGxlbWVudGF0aW9uLiBTZWVtcyBhIHRyYWdpYyB3YXN0ZSBvZiByZXNvdXJjZXNcbi8vIGRvaW5nIGFsbCB0aGlzIHdvcmsuIEluc3RlYWQsIGFuZCB3aGlsZSB1Z2x5LCB1c2UgbmV3IEZ1bmN0aW9uKCkgdG8gZ2VuZXJhdGVcbi8vIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciBlYWNoIHN0YXRpYyBtZXRob2QuXG5cbi8vIFF1aWNrIHJlZmVyZW5jZS5cbnZhciBqUHJvdG8gPSBqU3RhdC5wcm90b3R5cGU7XG5cbi8vIERlZmF1bHQgbGVuZ3RoLlxualByb3RvLmxlbmd0aCA9IDA7XG5cbi8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbi8vIFRPRE86IENoZWNrIGlmIHRoZXkncmUgYWN0dWFsbHkgdXNlZCwgYW5kIGlmIHRoZXkgYXJlIHRoZW4gcmVuYW1lIHRoZW1cbi8vIHRvIF8qXG5qUHJvdG8ucHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xualByb3RvLnNvcnQgPSBBcnJheS5wcm90b3R5cGUuc29ydDtcbmpQcm90by5zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xualByb3RvLnNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cbi8vIFJldHVybiBhIGNsZWFuIGFycmF5LlxualByb3RvLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCh0aGlzKSA6IHNsaWNlLmNhbGwodGhpcylbMF07XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGEgbWF0cml4IG9yIHZlY3Rvci5cbmpQcm90by5tYXAgPSBmdW5jdGlvbiBtYXAoZnVuYywgdG9BbHRlcikge1xuICByZXR1cm4galN0YXQoalN0YXQubWFwKHRoaXMsIGZ1bmMsIHRvQWx0ZXIpKTtcbn07XG5cblxuLy8gQ3VtdWxhdGl2ZWx5IGNvbWJpbmUgdGhlIGVsZW1lbnRzIG9mIGEgbWF0cml4IG9yIHZlY3RvciB1c2luZyBhIGZ1bmN0aW9uLlxualByb3RvLmN1bXJlZHVjZSA9IGZ1bmN0aW9uIGN1bXJlZHVjZShmdW5jLCB0b0FsdGVyKSB7XG4gIHJldHVybiBqU3RhdChqU3RhdC5jdW1yZWR1Y2UodGhpcywgZnVuYywgdG9BbHRlcikpO1xufTtcblxuXG4vLyBEZXN0cnVjdGl2ZWx5IGFsdGVyIGFuIGFycmF5LlxualByb3RvLmFsdGVyID0gZnVuY3Rpb24gYWx0ZXIoZnVuYykge1xuICBqU3RhdC5hbHRlcih0aGlzLCBmdW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBtZXRob2RzIHRoYXQgaGF2ZSBubyBhcmd1bWVudC5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVzdWx0cztcbiAgICAgIC8vIENoZWNrIGZvciBjYWxsYmFjay5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHNlbGYsIGpQcm90b1twYXNzZnVuY10uY2FsbChzZWxmKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBqU3RhdFtwYXNzZnVuY10odGhpcyk7XG4gICAgICByZXR1cm4gaXNBcnJheShyZXN1bHRzKSA/IGpTdGF0KHJlc3VsdHMpIDogcmVzdWx0cztcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgndHJhbnNwb3NlIGNsZWFyIHN5bW1ldHJpYyByb3dzIGNvbHMgZGltZW5zaW9ucyBkaWFnIGFudGlkaWFnJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggbWV0aG9kcyB0aGF0IGhhdmUgb25lIGFyZ3VtZW50LlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihpbmRleCwgZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gY2hlY2sgZm9yIGNhbGxiYWNrXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbChzZWxmLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwoc2VsZiwgaW5kZXgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBpbmRleCkpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdyb3cgY29sJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggc2ltcGxlIHNob3J0Y3V0IG1ldGhvZHMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgnY3JlYXRlIHplcm9zIG9uZXMgcmFuZCBpZGVudGl0eScuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXhwb3NpbmcgalN0YXQuXG5yZXR1cm4galN0YXQ7XG5cbn0oTWF0aCkpO1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0galN0YXQudXRpbHMuaXNGdW5jdGlvbjtcblxuLy8gQXNjZW5kaW5nIGZ1bmN0aW9ucyBmb3Igc29ydFxuZnVuY3Rpb24gYXNjTnVtKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9XG5cbmZ1bmN0aW9uIGNsaXAoYXJnLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihhcmcsIG1heCkpO1xufVxuXG5cbi8vIHN1bSBvZiBhbiBhcnJheVxualN0YXQuc3VtID0gZnVuY3Rpb24gc3VtKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIHNxdWFyZWRcbmpTdGF0LnN1bXNxcmQgPSBmdW5jdGlvbiBzdW1zcXJkKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXSAqIGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIG9mIHNxdWFyZWQgZXJyb3JzIG9mIHByZWRpY3Rpb24gKFNTRSlcbmpTdGF0LnN1bXNxZXJyID0gZnVuY3Rpb24gc3Vtc3FlcnIoYXJyKSB7XG4gIHZhciBtZWFuID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB2YXIgdG1wO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB0bXAgPSBhcnJbaV0gLSBtZWFuO1xuICAgIHN1bSArPSB0bXAgKiB0bXA7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIHN1bSBvZiBhbiBhcnJheSBpbiBlYWNoIHJvd1xualN0YXQuc3Vtcm93ID0gZnVuY3Rpb24gc3Vtcm93KGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIHByb2R1Y3Qgb2YgYW4gYXJyYXlcbmpTdGF0LnByb2R1Y3QgPSBmdW5jdGlvbiBwcm9kdWN0KGFycikge1xuICB2YXIgcHJvZCA9IDE7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIHByb2QgKj0gYXJyW2ldO1xuICByZXR1cm4gcHJvZDtcbn07XG5cblxuLy8gbWluaW11bSB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgbG93ID0gYXJyWzBdO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBhcnIubGVuZ3RoKVxuICAgIGlmIChhcnJbaV0gPCBsb3cpXG4gICAgICBsb3cgPSBhcnJbaV07XG4gIHJldHVybiBsb3c7XG59O1xuXG5cbi8vIG1heGltdW0gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGhpZ2ggPSBhcnJbMF07XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGFyci5sZW5ndGgpXG4gICAgaWYgKGFycltpXSA+IGhpZ2gpXG4gICAgICBoaWdoID0gYXJyW2ldO1xuICByZXR1cm4gaGlnaDtcbn07XG5cblxuLy8gdW5pcXVlIHZhbHVlcyBvZiBhbiBhcnJheVxualN0YXQudW5pcXVlID0gZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICB2YXIgaGFzaCA9IHt9LCBfYXJyID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIF9hcnIucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2Fycjtcbn07XG5cblxuLy8gbWVhbiB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdW0oYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIG1lYW4gc3F1YXJlZCBlcnJvciAoTVNFKVxualN0YXQubWVhbnNxZXJyID0gZnVuY3Rpb24gbWVhbnNxZXJyKGFycikge1xuICByZXR1cm4galN0YXQuc3Vtc3FlcnIoYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIGdlb21ldHJpYyBtZWFuIG9mIGFuIGFycmF5XG5qU3RhdC5nZW9tZWFuID0gZnVuY3Rpb24gZ2VvbWVhbihhcnIpIHtcbiAgdmFyIGxvZ3MgPSBhcnIubWFwKE1hdGgubG9nKVxuICB2YXIgbWVhbk9mTG9ncyA9IGpTdGF0Lm1lYW4obG9ncylcbiAgcmV0dXJuIE1hdGguZXhwKG1lYW5PZkxvZ3MpXG59O1xuXG5cbi8vIG1lZGlhbiBvZiBhbiBhcnJheVxualN0YXQubWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYXJybGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIC8vIGNoZWNrIGlmIGFycmF5IGlzIGV2ZW4gb3Igb2RkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGVcbiAgcmV0dXJuICEoYXJybGVuICYgMSlcbiAgICA/IChfYXJyWyhhcnJsZW4gLyAyKSAtIDEgXSArIF9hcnJbKGFycmxlbiAvIDIpXSkgLyAyXG4gICAgOiBfYXJyWyhhcnJsZW4gLyAyKSB8IDAgXTtcbn07XG5cblxuLy8gY3VtdWxhdGl2ZSBzdW0gb2YgYW4gYXJyYXlcbmpTdGF0LmN1bXN1bSA9IGZ1bmN0aW9uIGN1bXN1bShhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LmN1bXJlZHVjZShhcnIsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG59O1xuXG5cbi8vIGN1bXVsYXRpdmUgcHJvZHVjdCBvZiBhbiBhcnJheVxualN0YXQuY3VtcHJvZCA9IGZ1bmN0aW9uIGN1bXByb2QoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5jdW1yZWR1Y2UoYXJyLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAqIGI7IH0pO1xufTtcblxuXG4vLyBzdWNjZXNzaXZlIGRpZmZlcmVuY2VzIG9mIGEgc2VxdWVuY2VcbmpTdGF0LmRpZmYgPSBmdW5jdGlvbiBkaWZmKGFycikge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJyTGVuOyBpKyspXG4gICAgZGlmZnMucHVzaChhcnJbaV0gLSBhcnJbaSAtIDFdKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vLyByYW5rcyBvZiBhbiBhcnJheVxualN0YXQucmFuayA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGk7XG4gIHZhciBkaXN0aW5jdE51bWJlcnMgPSBbXTtcbiAgdmFyIG51bWJlckNvdW50cyA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG51bWJlciA9IGFycltpXTtcbiAgICBpZiAobnVtYmVyQ291bnRzW251bWJlcl0pIHtcbiAgICAgIG51bWJlckNvdW50c1tudW1iZXJdKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlckNvdW50c1tudW1iZXJdID0gMTtcbiAgICAgIGRpc3RpbmN0TnVtYmVycy5wdXNoKG51bWJlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvcnRlZERpc3RpbmN0TnVtYmVycyA9IGRpc3RpbmN0TnVtYmVycy5zb3J0KGFzY051bSk7XG4gIHZhciBudW1iZXJSYW5rcyA9IHt9O1xuICB2YXIgY3VycmVudFJhbmsgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkRGlzdGluY3ROdW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG51bWJlciA9IHNvcnRlZERpc3RpbmN0TnVtYmVyc1tpXTtcbiAgICB2YXIgY291bnQgPSBudW1iZXJDb3VudHNbbnVtYmVyXTtcbiAgICB2YXIgZmlyc3QgPSBjdXJyZW50UmFuaztcbiAgICB2YXIgbGFzdCA9IGN1cnJlbnRSYW5rICsgY291bnQgLSAxO1xuICAgIHZhciByYW5rID0gKGZpcnN0ICsgbGFzdCkgLyAyO1xuICAgIG51bWJlclJhbmtzW251bWJlcl0gPSByYW5rO1xuICAgIGN1cnJlbnRSYW5rICs9IGNvdW50O1xuICB9XG5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiBudW1iZXJSYW5rc1tudW1iZXJdO1xuICB9KTtcbn07XG5cblxuLy8gbW9kZSBvZiBhbiBhcnJheVxuLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1vZGVzIG9mIGFuIGFycmF5LCByZXR1cm4gYWxsIG9mIHRoZW1cbi8vIGlzIHRoaXMgdGhlIGFwcHJvcHJpYXRlIHdheSBvZiBoYW5kbGluZyBpdD9cbmpTdGF0Lm1vZGUgPSBmdW5jdGlvbiBtb2RlKGFycikge1xuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBjb3VudCA9IDE7XG4gIHZhciBtYXhDb3VudCA9IDA7XG4gIHZhciBudW1NYXhDb3VudCA9IDA7XG4gIHZhciBtb2RlX2FyciA9IFtdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyBpKyspIHtcbiAgICBpZiAoX2FycltpXSA9PT0gX2FycltpICsgMV0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyID0gW19hcnJbaV1dO1xuICAgICAgICBtYXhDb3VudCA9IGNvdW50O1xuICAgICAgICBudW1NYXhDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBhcmUgdGhlcmUgbXVsdGlwbGUgbWF4IGNvdW50c1xuICAgICAgZWxzZSBpZiAoY291bnQgPT09IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyLnB1c2goX2FycltpXSk7XG4gICAgICAgIG51bU1heENvdW50Kys7XG4gICAgICB9XG4gICAgICAvLyByZXNldHRpbmcgY291bnQgZm9yIG5ldyB2YWx1ZSBpbiBhcnJheVxuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1NYXhDb3VudCA9PT0gMCA/IG1vZGVfYXJyWzBdIDogbW9kZV9hcnI7XG59O1xuXG5cbi8vIHJhbmdlIG9mIGFuIGFycmF5XG5qU3RhdC5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGFycikge1xuICByZXR1cm4galN0YXQubWF4KGFycikgLSBqU3RhdC5taW4oYXJyKTtcbn07XG5cbi8vIHZhcmlhbmNlIG9mIGFuIGFycmF5XG4vLyBmbGFnID0gdHJ1ZSBpbmRpY2F0ZXMgc2FtcGxlIGluc3RlYWQgb2YgcG9wdWxhdGlvblxualN0YXQudmFyaWFuY2UgPSBmdW5jdGlvbiB2YXJpYW5jZShhcnIsIGZsYWcpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bXNxZXJyKGFycikgLyAoYXJyLmxlbmd0aCAtIChmbGFnID8gMSA6IDApKTtcbn07XG5cbi8vIHBvb2xlZCB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBhcnJheXNcbmpTdGF0LnBvb2xlZHZhcmlhbmNlID0gZnVuY3Rpb24gcG9vbGVkdmFyaWFuY2UoYXJyKSB7XG4gIHZhciBzdW1zcWVyciA9IGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIHNhbXBsZXMpIHtyZXR1cm4gYSArIGpTdGF0LnN1bXNxZXJyKHNhbXBsZXMpO30sIDApO1xuICB2YXIgY291bnQgPSBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBzYW1wbGVzKSB7cmV0dXJuIGEgKyBzYW1wbGVzLmxlbmd0aDt9LCAwKTtcbiAgcmV0dXJuIHN1bXNxZXJyIC8gKGNvdW50IC0gYXJyLmxlbmd0aCk7XG59O1xuXG4vLyBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbmpTdGF0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgZGV2ID0gbmV3IEFycmF5KGFycmxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJybGVuOyBpKyspIHtcbiAgICBkZXZbaV0gPSBhcnJbaV0gLSBtZWFuO1xuICB9XG4gIHJldHVybiBkZXY7XG59O1xuXG4vLyBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbi8vIGZsYWcgPSB0cnVlIGluZGljYXRlcyBzYW1wbGUgaW5zdGVhZCBvZiBwb3B1bGF0aW9uXG5qU3RhdC5zdGRldiA9IGZ1bmN0aW9uIHN0ZGV2KGFyciwgZmxhZykge1xuICByZXR1cm4gTWF0aC5zcXJ0KGpTdGF0LnZhcmlhbmNlKGFyciwgZmxhZykpO1xufTtcblxuLy8gcG9vbGVkIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBhcnJheXNcbmpTdGF0LnBvb2xlZHN0ZGV2ID0gZnVuY3Rpb24gcG9vbGVkc3RkZXYoYXJyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoalN0YXQucG9vbGVkdmFyaWFuY2UoYXJyKSk7XG59O1xuXG4vLyBtZWFuIGRldmlhdGlvbiAobWVhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWFuZGV2ID0gZnVuY3Rpb24gbWVhbmRldihhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBhID0gW107XG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBhLnB1c2goTWF0aC5hYnMoYXJyW2ldIC0gbWVhbikpO1xuICB9XG4gIHJldHVybiBqU3RhdC5tZWFuKGEpO1xufTtcblxuXG4vLyBtZWRpYW4gZGV2aWF0aW9uIChtZWRpYW4gYWJzb2x1dGUgZGV2aWF0aW9uKSBvZiBhbiBhcnJheVxualN0YXQubWVkZGV2ID0gZnVuY3Rpb24gbWVkZGV2KGFycikge1xuICB2YXIgbWVkaWFuID0galN0YXQubWVkaWFuKGFycik7XG4gIHZhciBhID0gW107XG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBhLnB1c2goTWF0aC5hYnMoYXJyW2ldIC0gbWVkaWFuKSk7XG4gIH1cbiAgcmV0dXJuIGpTdGF0Lm1lZGlhbihhKTtcbn07XG5cblxuLy8gY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG5qU3RhdC5jb2VmZnZhciA9IGZ1bmN0aW9uIGNvZWZmdmFyKGFycikge1xuICByZXR1cm4galN0YXQuc3RkZXYoYXJyKSAvIGpTdGF0Lm1lYW4oYXJyKTtcbn07XG5cblxuLy8gcXVhcnRpbGVzIG9mIGFuIGFycmF5XG5qU3RhdC5xdWFydGlsZXMgPSBmdW5jdGlvbiBxdWFydGlsZXMoYXJyKSB7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgcmV0dXJuIFtcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pIC8gNCkgLSAxIF0sXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAvIDIpIC0gMSBdLFxuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgKiAzIC8gNCkgLSAxIF1cbiAgXTtcbn07XG5cblxuLy8gQXJiaXRhcnkgcXVhbnRpbGVzIG9mIGFuIGFycmF5LiBEaXJlY3QgcG9ydCBvZiB0aGUgc2NpcHkuc3RhdHNcbi8vIGltcGxlbWVudGF0aW9uIGJ5IFBpZXJyZSBHRiBHZXJhcmQtTWFyY2hhbnQuXG5qU3RhdC5xdWFudGlsZXMgPSBmdW5jdGlvbiBxdWFudGlsZXMoYXJyLCBxdWFudGlsZXNBcnJheSwgYWxwaGFwLCBiZXRhcCkge1xuICB2YXIgc29ydGVkQXJyYXkgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBxdWFudGlsZVZhbHMgPSBbcXVhbnRpbGVzQXJyYXkubGVuZ3RoXTtcbiAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSwgcCwgbSwgYWxlcGgsIGssIGdhbW1hO1xuXG4gIGlmICh0eXBlb2YgYWxwaGFwID09PSAndW5kZWZpbmVkJylcbiAgICBhbHBoYXAgPSAzIC8gODtcbiAgaWYgKHR5cGVvZiBiZXRhcCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgYmV0YXAgPSAzIC8gODtcblxuICBmb3IgKGkgPSAwOyBpIDwgcXVhbnRpbGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcXVhbnRpbGVzQXJyYXlbaV07XG4gICAgbSA9IGFscGhhcCArIHAgKiAoMSAtIGFscGhhcCAtIGJldGFwKTtcbiAgICBhbGVwaCA9IG4gKiBwICsgbTtcbiAgICBrID0gTWF0aC5mbG9vcihjbGlwKGFsZXBoLCAxLCBuIC0gMSkpO1xuICAgIGdhbW1hID0gY2xpcChhbGVwaCAtIGssIDAsIDEpO1xuICAgIHF1YW50aWxlVmFsc1tpXSA9ICgxIC0gZ2FtbWEpICogc29ydGVkQXJyYXlbayAtIDFdICsgZ2FtbWEgKiBzb3J0ZWRBcnJheVtrXTtcbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZVZhbHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGstdGggcGVyY2VudGlsZSBvZiB2YWx1ZXMgaW4gYSByYW5nZSwgd2hlcmUgayBpcyBpbiB0aGUgcmFuZ2UgMC4uMSwgaW5jbHVzaXZlLlxuLy8gUGFzc2luZyB0cnVlIGZvciB0aGUgZXhjbHVzaXZlIHBhcmFtZXRlciBleGNsdWRlcyBib3RoIGVuZHBvaW50cyBvZiB0aGUgcmFuZ2UuXG5qU3RhdC5wZXJjZW50aWxlID0gZnVuY3Rpb24gcGVyY2VudGlsZShhcnIsIGssIGV4Y2x1c2l2ZSkge1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIHJlYWxJbmRleCA9IGsgKiAoX2Fyci5sZW5ndGggKyAoZXhjbHVzaXZlID8gMSA6IC0xKSkgKyAoZXhjbHVzaXZlID8gMCA6IDEpO1xuICB2YXIgaW5kZXggPSBwYXJzZUludChyZWFsSW5kZXgpO1xuICB2YXIgZnJhYyA9IHJlYWxJbmRleCAtIGluZGV4O1xuICBpZiAoaW5kZXggKyAxIDwgX2Fyci5sZW5ndGgpIHtcbiAgICByZXR1cm4gX2FycltpbmRleCAtIDFdICsgZnJhYyAqIChfYXJyW2luZGV4XSAtIF9hcnJbaW5kZXggLSAxXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9hcnJbaW5kZXggLSAxXTtcbiAgfVxufVxuXG4vLyBUaGUgcGVyY2VudGlsZSByYW5rIG9mIHNjb3JlIGluIGEgZ2l2ZW4gYXJyYXkuIFJldHVybnMgdGhlIHBlcmNlbnRhZ2Vcbi8vIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIGlucHV0IGFycmF5IHRoYXQgYXJlIGxlc3MgdGhhbiAoa2luZD0nc3RyaWN0Jykgb3Jcbi8vIGxlc3Mgb3IgZXF1YWwgdGhhbiAoa2luZD0nd2VhaycpIHNjb3JlLiBEZWZhdWx0IGlzIHdlYWsuXG5qU3RhdC5wZXJjZW50aWxlT2ZTY29yZSA9IGZ1bmN0aW9uIHBlcmNlbnRpbGVPZlNjb3JlKGFyciwgc2NvcmUsIGtpbmQpIHtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHN0cmljdCA9IGZhbHNlO1xuICB2YXIgdmFsdWUsIGk7XG5cbiAgaWYgKGtpbmQgPT09ICdzdHJpY3QnKVxuICAgIHN0cmljdCA9IHRydWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKChzdHJpY3QgJiYgdmFsdWUgPCBzY29yZSkgfHxcbiAgICAgICAgKCFzdHJpY3QgJiYgdmFsdWUgPD0gc2NvcmUpKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50ZXIgLyBsZW47XG59O1xuXG5cbi8vIEhpc3RvZ3JhbSAoYmluIGNvdW50KSBkYXRhXG5qU3RhdC5oaXN0b2dyYW0gPSBmdW5jdGlvbiBoaXN0b2dyYW0oYXJyLCBiaW5DbnQpIHtcbiAgYmluQ250ID0gYmluQ250IHx8IDQ7XG4gIHZhciBmaXJzdCA9IGpTdGF0Lm1pbihhcnIpO1xuICB2YXIgYmluV2lkdGggPSAoalN0YXQubWF4KGFycikgLSBmaXJzdCkgLyBiaW5DbnQ7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgYmlucyA9IFtdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYmluQ250OyBpKyspXG4gICAgYmluc1tpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICBiaW5zW01hdGgubWluKE1hdGguZmxvb3IoKChhcnJbaV0gLSBmaXJzdCkgLyBiaW5XaWR0aCkpLCBiaW5DbnQgLSAxKV0gKz0gMTtcblxuICByZXR1cm4gYmlucztcbn07XG5cblxuLy8gY292YXJpYW5jZSBvZiB0d28gYXJyYXlzXG5qU3RhdC5jb3ZhcmlhbmNlID0gZnVuY3Rpb24gY292YXJpYW5jZShhcnIxLCBhcnIyKSB7XG4gIHZhciB1ID0galN0YXQubWVhbihhcnIxKTtcbiAgdmFyIHYgPSBqU3RhdC5tZWFuKGFycjIpO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICB2YXIgc3FfZGV2ID0gbmV3IEFycmF5KGFycjFMZW4pO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyMUxlbjsgaSsrKVxuICAgIHNxX2RldltpXSA9IChhcnIxW2ldIC0gdSkgKiAoYXJyMltpXSAtIHYpO1xuXG4gIHJldHVybiBqU3RhdC5zdW0oc3FfZGV2KSAvIChhcnIxTGVuIC0gMSk7XG59O1xuXG5cbi8vIChwZWFyc29uJ3MpIHBvcHVsYXRpb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQsIHJob1xualN0YXQuY29ycmNvZWZmID0gZnVuY3Rpb24gY29ycmNvZWZmKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGpTdGF0LmNvdmFyaWFuY2UoYXJyMSwgYXJyMikgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMSwgMSkgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMiwgMSk7XG59O1xuXG4gIC8vIChzcGVhcm1hbidzKSByYW5rIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50LCBzcFxualN0YXQuc3BlYXJtYW5jb2VmZiA9ICBmdW5jdGlvbiAoYXJyMSwgYXJyMikge1xuICBhcnIxID0galN0YXQucmFuayhhcnIxKTtcbiAgYXJyMiA9IGpTdGF0LnJhbmsoYXJyMik7XG4gIC8vcmV0dXJuIHBlYXJzb24ncyBjb3JyZWxhdGlvbiBvZiB0aGUgcmFua3M6XG4gIHJldHVybiBqU3RhdC5jb3JyY29lZmYoYXJyMSwgYXJyMik7XG59XG5cblxuLy8gc3RhdGlzdGljYWwgc3RhbmRhcmRpemVkIG1vbWVudHMgKGdlbmVyYWwgZm9ybSBvZiBza2V3L2t1cnQpXG5qU3RhdC5zdGFuTW9tZW50ID0gZnVuY3Rpb24gc3Rhbk1vbWVudChhcnIsIG4pIHtcbiAgdmFyIG11ID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgc2lnbWEgPSBqU3RhdC5zdGRldihhcnIpO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHNrZXdTdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgc2tld1N1bSArPSBNYXRoLnBvdygoYXJyW2ldIC0gbXUpIC8gc2lnbWEsIG4pO1xuXG4gIHJldHVybiBza2V3U3VtIC8gYXJyLmxlbmd0aDtcbn07XG5cbi8vIChwZWFyc29uJ3MpIG1vbWVudCBjb2VmZmljaWVudCBvZiBza2V3bmVzc1xualN0YXQuc2tld25lc3MgPSBmdW5jdGlvbiBza2V3bmVzcyhhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN0YW5Nb21lbnQoYXJyLCAzKTtcbn07XG5cbi8vIChwZWFyc29uJ3MpIChleGNlc3MpIGt1cnRvc2lzXG5qU3RhdC5rdXJ0b3NpcyA9IGZ1bmN0aW9uIGt1cnRvc2lzKGFycikge1xuICByZXR1cm4galN0YXQuc3Rhbk1vbWVudChhcnIsIDQpIC0gMztcbn07XG5cblxudmFyIGpQcm90byA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBFeHRlbmQgalByb3RvIHdpdGggbWV0aG9kIGZvciBjYWxjdWxhdGluZyBjdW11bGF0aXZlIHN1bXMgYW5kIHByb2R1Y3RzLlxuLy8gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHNpbWlsYXIgZXh0ZW5zaW9uIGJlbG93IGFzIGN1bXN1bSBhbmQgY3VtcHJvZCBzaG91bGRcbi8vIG5vdCBiZSBydW4gYWdhaW4gaW4gdGhlIGNhc2UgZnVsbGJvb2wgPT09IHRydWUuXG4vLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvbiB0aGVcbi8vIGNvbHVtbnMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgLy8gSWYgYSBtYXRyaXggaXMgcGFzc2VkLCBhdXRvbWF0aWNhbGx5IGFzc3VtZSBvcGVyYXRpb24gc2hvdWxkIGJlIGRvbmUgb25cbiAgICAvLyB0aGUgY29sdW1ucy5cbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVsbGJvb2wsIGZ1bmMpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIEFzc2lnbm1lbnQgcmVhc3NpZ25hdGlvbiBkZXBlbmRpbmcgb24gaG93IHBhcmFtZXRlcnMgd2VyZSBwYXNzZWQgaW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihmdWxsYm9vbCkpIHtcbiAgICAgICAgZnVuYyA9IGZ1bGxib29sO1xuICAgICAgICBmdWxsYm9vbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgYSBjYWxsYmFjayB3YXMgcGFzc2VkIHdpdGggdGhlIGZ1bmN0aW9uLlxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHRtcHRoaXMsIGZ1bGxib29sKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIG1hdHJpeCBhbmQgcnVuIGNhbGN1bGF0aW9ucy5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IGZ1bGxib29sID09PSB0cnVlID8gdGhpcyA6IHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBqU3RhdFtwYXNzZnVuY10odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gICAgICAvLyBQYXNzIGZ1bGxib29sIGlmIG9ubHkgdmVjdG9yLCBub3QgYSBtYXRyaXguIGZvciB2YXJpYW5jZSBhbmQgc3RkZXYuXG4gICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHRoaXNbMF0sIGZ1bGxib29sKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgoJ2N1bXN1bSBjdW1wcm9kJykuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIG1ldGhvZHMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBhcmd1bWVudHMgYW5kIHdvcmsgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICAvLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvblxuICAgIC8vIHRoZSBjb2x1bW5zLlxuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdWxsYm9vbCwgZnVuYykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgLy8gQXNzaWdubWVudCByZWFzc2lnbmF0aW9uIGRlcGVuZGluZyBvbiBob3cgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCBpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bGxib29sKSkge1xuICAgICAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgICAgIGZ1bGxib29sID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2l0aCB0aGUgZnVuY3Rpb24uXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgZnVsbGJvb2wpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAocGFzc2Z1bmMgIT09ICdzdW1yb3cnKVxuICAgICAgICAgIHRtcHRoaXMgPSBmdWxsYm9vbCA9PT0gdHJ1ZSA/IHRoaXMgOiB0aGlzLnRyYW5zcG9zZSgpO1xuICAgICAgICBmb3IgKDsgaSA8IHRtcHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYXJyW2ldID0galN0YXRbcGFzc2Z1bmNdKHRtcHRoaXNbaV0pO1xuICAgICAgICByZXR1cm4gZnVsbGJvb2wgPT09IHRydWVcbiAgICAgICAgICAgID8galN0YXRbcGFzc2Z1bmNdKGpTdGF0LnV0aWxzLnRvVmVjdG9yKGFycikpXG4gICAgICAgICAgICA6IGFycjtcbiAgICAgIH1cbiAgICAgIC8vIFBhc3MgZnVsbGJvb2wgaWYgb25seSB2ZWN0b3IsIG5vdCBhIG1hdHJpeC4gZm9yIHZhcmlhbmNlIGFuZCBzdGRldi5cbiAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10odGhpc1swXSwgZnVsbGJvb2wpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCgnc3VtIHN1bXNxcmQgc3Vtc3FlcnIgc3Vtcm93IHByb2R1Y3QgbWluIG1heCB1bmlxdWUgbWVhbiBtZWFuc3FlcnIgJyArXG4gICAgJ2dlb21lYW4gbWVkaWFuIGRpZmYgcmFuayBtb2RlIHJhbmdlIHZhcmlhbmNlIGRldmlhdGlvbiBzdGRldiBtZWFuZGV2ICcgK1xuICAgICdtZWRkZXYgY29lZmZ2YXIgcXVhcnRpbGVzIGhpc3RvZ3JhbSBza2V3bmVzcyBrdXJ0b3NpcycpLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFyZ3VtZW50cy4gT3BlcmF0aW9ucyBvbiBtYXRyaWNlcyBhcmVcbi8vIGRvbmUgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgY2FsbGJhY2tGdW5jdGlvbjtcblxuICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiwgd2UgYXNzdW1lIGl0J3MgYSBjYWxsYmFjazsgd2VcbiAgICAgIC8vIHN0cmlwIHRoZSBjYWxsYmFjayBvdXQgYW5kIGNhbGwgdGhlIGZ1bmN0aW9uIGFnYWluLlxuICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBjYWxsYmFja0Z1bmN0aW9uID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgYXJnc1RvUGFzcyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24uY2FsbCh0bXB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUHJvdG9bcGFzc2Z1bmNdLmFwcGx5KHRtcHRoaXMsIGFyZ3NUb1Bhc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBPdGhlcndpc2Ugd2UgY3VycnkgdGhlIGZ1bmN0aW9uIGFyZ3MgYW5kIGNhbGwgbm9ybWFsbHkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY3VycmllZEZ1bmN0aW9uID0gZnVuY3Rpb24gY3VycmllZEZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10uYXBwbHkodG1wdGhpcywgW3ZlY3Rvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbWF0cml4LCBydW4gY29sdW1uLWJ5LWNvbHVtbi5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IHRtcHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBjdXJyaWVkRnVuY3Rpb24odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBydW4gb24gdGhlIHZlY3Rvci5cbiAgICAgIHJldHVybiBjdXJyaWVkRnVuY3Rpb24odGhpc1swXSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3F1YW50aWxlcyBwZXJjZW50aWxlT2ZTY29yZScuc3BsaXQoJyAnKSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbi8vIFNwZWNpYWwgZnVuY3Rpb25zIC8vXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gTG9nLWdhbW1hIGZ1bmN0aW9uXG5qU3RhdC5nYW1tYWxuID0gZnVuY3Rpb24gZ2FtbWFsbih4KSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGNvZiA9IFtcbiAgICA3Ni4xODAwOTE3Mjk0NzE0NiwgLTg2LjUwNTMyMDMyOTQxNjc3LCAyNC4wMTQwOTgyNDA4MzA5MSxcbiAgICAtMS4yMzE3Mzk1NzI0NTAxNTUsIDAuMTIwODY1MDk3Mzg2NjE3OWUtMiwgLTAuNTM5NTIzOTM4NDk1M2UtNVxuICBdO1xuICB2YXIgc2VyID0gMS4wMDAwMDAwMDAxOTAwMTU7XG4gIHZhciB4eCwgeSwgdG1wO1xuICB0bXAgPSAoeSA9IHh4ID0geCkgKyA1LjU7XG4gIHRtcCAtPSAoeHggKyAwLjUpICogTWF0aC5sb2codG1wKTtcbiAgZm9yICg7IGogPCA2OyBqKyspXG4gICAgc2VyICs9IGNvZltqXSAvICsreTtcbiAgcmV0dXJuIE1hdGgubG9nKDIuNTA2NjI4Mjc0NjMxMDAwNSAqIHNlciAvIHh4KSAtIHRtcDtcbn07XG5cbi8qXG4gKiBsb2ctZ2FtbWEgZnVuY3Rpb24gdG8gc3VwcG9ydCBwb2lzc29uIGRpc3RyaWJ1dGlvbiBzYW1wbGluZy4gVGhlXG4gKiBhbGdvcml0aG0gY29tZXMgZnJvbSBTUEVDRlVOIGJ5IFNoYW5qaWUgWmhhbmcgYW5kIEppYW5taW5nIEppbiBhbmQgdGhlaXJcbiAqIGJvb2sgXCJDb21wdXRhdGlvbiBvZiBTcGVjaWFsIEZ1bmN0aW9uc1wiLCAxOTk2LCBKb2huIFdpbGV5ICYgU29ucywgSW5jLlxuICovXG5qU3RhdC5sb2dnYW0gPSBmdW5jdGlvbiBsb2dnYW0oeCkge1xuICB2YXIgeDAsIHgyLCB4cCwgZ2wsIGdsMDtcbiAgdmFyIGssIG47XG5cbiAgdmFyIGEgPSBbOC4zMzMzMzMzMzMzMzMzMzNlLTAyLCAtMi43Nzc3Nzc3Nzc3Nzc3NzhlLTAzLFxuICAgICAgICAgIDcuOTM2NTA3OTM2NTA3OTM3ZS0wNCwgLTUuOTUyMzgwOTUyMzgwOTUyZS0wNCxcbiAgICAgICAgICA4LjQxNzUwODQxNzUwODQxOGUtMDQsIC0xLjkxNzUyNjkxNzUyNjkxOGUtMDMsXG4gICAgICAgICAgNi40MTAyNTY0MTAyNTY0MTBlLTAzLCAtMi45NTUwNjUzNTk0NzcxMjRlLTAyLFxuICAgICAgICAgIDEuNzk2NDQzNzIzNjg4MzA3ZS0wMSwgLTEuMzkyNDMyMjE2OTA1OTBlKzAwXTtcbiAgeDAgPSB4O1xuICBuID0gMDtcbiAgaWYgKCh4ID09IDEuMCkgfHwgKHggPT0gMi4wKSkge1xuICAgICAgcmV0dXJuIDAuMDtcbiAgfVxuICBpZiAoeCA8PSA3LjApIHtcbiAgICAgIG4gPSBNYXRoLmZsb29yKDcgLSB4KTtcbiAgICAgIHgwID0geCArIG47XG4gIH1cbiAgeDIgPSAxLjAgLyAoeDAgKiB4MCk7XG4gIHhwID0gMiAqIE1hdGguUEk7XG4gIGdsMCA9IGFbOV07XG4gIGZvciAoayA9IDg7IGsgPj0gMDsgay0tKSB7XG4gICAgICBnbDAgKj0geDI7XG4gICAgICBnbDAgKz0gYVtrXTtcbiAgfVxuICBnbCA9IGdsMCAvIHgwICsgMC41ICogTWF0aC5sb2coeHApICsgKHgwIC0gMC41KSAqIE1hdGgubG9nKHgwKSAtIHgwO1xuICBpZiAoeCA8PSA3LjApIHtcbiAgICAgIGZvciAoayA9IDE7IGsgPD0gbjsgaysrKSB7XG4gICAgICAgICAgZ2wgLT0gTWF0aC5sb2coeDAgLSAxLjApO1xuICAgICAgICAgIHgwIC09IDEuMDtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZ2w7XG59XG5cbi8vIGdhbW1hIG9mIHhcbmpTdGF0LmdhbW1hZm4gPSBmdW5jdGlvbiBnYW1tYWZuKHgpIHtcbiAgdmFyIHAgPSBbLTEuNzE2MTg1MTM4ODY1NDk1LCAyNC43NjU2NTA4MDU1NzU5MiwgLTM3OS44MDQyNTY0NzA5NDU2MyxcbiAgICAgICAgICAgNjI5LjMzMTE1NTMxMjgxODQsIDg2Ni45NjYyMDI3OTA0MTMzLCAtMzE0NTEuMjcyOTY4ODQ4MzY3LFxuICAgICAgICAgICAtMzYxNDQuNDEzNDE4NjkxMTc2LCA2NjQ1Ni4xNDM4MjAyNDA1NFxuICBdO1xuICB2YXIgcSA9IFstMzAuODQwMjMwMDExOTczOSwgMzE1LjM1MDYyNjk3OTYwNDE2LCAtMTAxNS4xNTYzNjc0OTAyMTkyLFxuICAgICAgICAgICAtMzEwNy43NzE2NzE1NzIzMTEsIDIyNTM4LjExODQyMDk4MDE1MSwgNDc1NS44NDYyNzc1Mjc4ODExLFxuICAgICAgICAgICAtMTM0NjU5Ljk1OTg2NDk2OTMsIC0xMTUxMzIuMjU5Njc1NTUzNV07XG4gIHZhciBmYWN0ID0gZmFsc2U7XG4gIHZhciBuID0gMDtcbiAgdmFyIHhkZW4gPSAwO1xuICB2YXIgeG51bSA9IDA7XG4gIHZhciB5ID0geDtcbiAgdmFyIGksIHosIHlpLCByZXM7XG4gIGlmICh4ID4gMTcxLjYyNDM3Njk1MzYwNzYpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKHkgPD0gMCkge1xuICAgIHJlcyA9IHkgJSAxICsgMy42ZS0xNjtcbiAgICBpZiAocmVzKSB7XG4gICAgICBmYWN0ID0gKCEoeSAmIDEpID8gMSA6IC0xKSAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJICogcmVzKTtcbiAgICAgIHkgPSAxIC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuICB5aSA9IHk7XG4gIGlmICh5IDwgMSkge1xuICAgIHogPSB5Kys7XG4gIH0gZWxzZSB7XG4gICAgeiA9ICh5IC09IG4gPSAoeSB8IDApIC0gMSkgLSAxO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB4bnVtID0gKHhudW0gKyBwW2ldKSAqIHo7XG4gICAgeGRlbiA9IHhkZW4gKiB6ICsgcVtpXTtcbiAgfVxuICByZXMgPSB4bnVtIC8geGRlbiArIDE7XG4gIGlmICh5aSA8IHkpIHtcbiAgICByZXMgLz0geWk7XG4gIH0gZWxzZSBpZiAoeWkgPiB5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmVzICo9IHk7XG4gICAgICB5Kys7XG4gICAgfVxuICB9XG4gIGlmIChmYWN0KSB7XG4gICAgcmVzID0gZmFjdCAvIHJlcztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBsb3dlciBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uLCB3aGljaCBpcyB1c3VhbGx5IHR5cGVzZXQgd2l0aCBhXG4vLyBsb3dlci1jYXNlIGdyZWVrIGdhbW1hIGFzIHRoZSBmdW5jdGlvbiBzeW1ib2xcbmpTdGF0LmdhbW1hcCA9IGZ1bmN0aW9uIGdhbW1hcChhLCB4KSB7XG4gIHJldHVybiBqU3RhdC5sb3dSZWdHYW1tYShhLCB4KSAqIGpTdGF0LmdhbW1hZm4oYSk7XG59O1xuXG5cbi8vIFRoZSBsb3dlciByZWd1bGFyaXplZCBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uLCB1c3VhbGx5IHdyaXR0ZW4gUChhLHgpXG5qU3RhdC5sb3dSZWdHYW1tYSA9IGZ1bmN0aW9uIGxvd1JlZ0dhbW1hKGEsIHgpIHtcbiAgdmFyIGFsbiA9IGpTdGF0LmdhbW1hbG4oYSk7XG4gIHZhciBhcCA9IGE7XG4gIHZhciBzdW0gPSAxIC8gYTtcbiAgdmFyIGRlbCA9IHN1bTtcbiAgdmFyIGIgPSB4ICsgMSAtIGE7XG4gIHZhciBjID0gMSAvIDEuMGUtMzA7XG4gIHZhciBkID0gMSAvIGI7XG4gIHZhciBoID0gZDtcbiAgdmFyIGkgPSAxO1xuICAvLyBjYWxjdWxhdGUgbWF4aW11bSBudW1iZXIgb2YgaXR0ZXJhdGlvbnMgcmVxdWlyZWQgZm9yIGFcbiAgdmFyIElUTUFYID0gLX4oTWF0aC5sb2coKGEgPj0gMSkgPyBhIDogMSAvIGEpICogOC41ICsgYSAqIDAuNCArIDE3KTtcbiAgdmFyIGFuO1xuXG4gIGlmICh4IDwgMCB8fCBhIDw9IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHggPCBhICsgMSkge1xuICAgIGZvciAoOyBpIDw9IElUTUFYOyBpKyspIHtcbiAgICAgIHN1bSArPSBkZWwgKj0geCAvICsrYXA7XG4gICAgfVxuICAgIHJldHVybiAoc3VtICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSAoYWxuKSkpO1xuICB9XG5cbiAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgIGFuID0gLWkgKiAoaSAtIGEpO1xuICAgIGIgKz0gMjtcbiAgICBkID0gYW4gKiBkICsgYjtcbiAgICBjID0gYiArIGFuIC8gYztcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgfVxuXG4gIHJldHVybiAoMSAtIGggKiBNYXRoLmV4cCgteCArIGEgKiBNYXRoLmxvZyh4KSAtIChhbG4pKSk7XG59O1xuXG4vLyBuYXR1cmFsIGxvZyBmYWN0b3JpYWwgb2YgblxualN0YXQuZmFjdG9yaWFsbG4gPSBmdW5jdGlvbiBmYWN0b3JpYWxsbihuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hbG4obiArIDEpO1xufTtcblxuLy8gZmFjdG9yaWFsIG9mIG5cbmpTdGF0LmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hZm4obiArIDEpO1xufTtcblxuLy8gY29tYmluYXRpb25zIG9mIG4sIG1cbmpTdGF0LmNvbWJpbmF0aW9uID0gZnVuY3Rpb24gY29tYmluYXRpb24obiwgbSkge1xuICAvLyBtYWtlIHN1cmUgbiBvciBtIGRvbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKG4gPiAxNzAgfHwgbSA+IDE3MClcbiAgICAgID8gTWF0aC5leHAoalN0YXQuY29tYmluYXRpb25sbihuLCBtKSlcbiAgICAgIDogKGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChtKSkgLyBqU3RhdC5mYWN0b3JpYWwobiAtIG0pO1xufTtcblxuXG5qU3RhdC5jb21iaW5hdGlvbmxuID0gZnVuY3Rpb24gY29tYmluYXRpb25sbihuLCBtKXtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbGxuKG4pIC0galN0YXQuZmFjdG9yaWFsbG4obSkgLSBqU3RhdC5mYWN0b3JpYWxsbihuIC0gbSk7XG59O1xuXG5cbi8vIHBlcm11dGF0aW9ucyBvZiBuLCBtXG5qU3RhdC5wZXJtdXRhdGlvbiA9IGZ1bmN0aW9uIHBlcm11dGF0aW9uKG4sIG0pIHtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChuIC0gbSk7XG59O1xuXG5cbi8vIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFmbiA9IGZ1bmN0aW9uIGJldGFmbih4LCB5KSB7XG4gIC8vIGVuc3VyZSBhcmd1bWVudHMgYXJlIHBvc2l0aXZlXG4gIGlmICh4IDw9IDAgfHwgeSA8PSAwKVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIC8vIG1ha2Ugc3VyZSB4ICsgeSBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKHggKyB5ID4gMTcwKVxuICAgICAgPyBNYXRoLmV4cChqU3RhdC5iZXRhbG4oeCwgeSkpXG4gICAgICA6IGpTdGF0LmdhbW1hZm4oeCkgKiBqU3RhdC5nYW1tYWZuKHkpIC8galN0YXQuZ2FtbWFmbih4ICsgeSk7XG59O1xuXG5cbi8vIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFsbiA9IGZ1bmN0aW9uIGJldGFsbih4LCB5KSB7XG4gIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpICsgalN0YXQuZ2FtbWFsbih5KSAtIGpTdGF0LmdhbW1hbG4oeCArIHkpO1xufTtcblxuXG4vLyBFdmFsdWF0ZXMgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbiBmb3IgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIGJ5IG1vZGlmaWVkXG4vLyBMZW50eidzIG1ldGhvZC5cbmpTdGF0LmJldGFjZiA9IGZ1bmN0aW9uIGJldGFjZih4LCBhLCBiKSB7XG4gIHZhciBmcG1pbiA9IDFlLTMwO1xuICB2YXIgbSA9IDE7XG4gIHZhciBxYWIgPSBhICsgYjtcbiAgdmFyIHFhcCA9IGEgKyAxO1xuICB2YXIgcWFtID0gYSAtIDE7XG4gIHZhciBjID0gMTtcbiAgdmFyIGQgPSAxIC0gcWFiICogeCAvIHFhcDtcbiAgdmFyIG0yLCBhYSwgZGVsLCBoO1xuXG4gIC8vIFRoZXNlIHEncyB3aWxsIGJlIHVzZWQgaW4gZmFjdG9ycyB0aGF0IG9jY3VyIGluIHRoZSBjb2VmZmljaWVudHNcbiAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgZCA9IGZwbWluO1xuICBkID0gMSAvIGQ7XG4gIGggPSBkO1xuXG4gIGZvciAoOyBtIDw9IDEwMDsgbSsrKSB7XG4gICAgbTIgPSAyICogbTtcbiAgICBhYSA9IG0gKiAoYiAtIG0pICogeCAvICgocWFtICsgbTIpICogKGEgKyBtMikpO1xuICAgIC8vIE9uZSBzdGVwICh0aGUgZXZlbiBvbmUpIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgZCA9IDEgKyBhYSAqIGQ7XG4gICAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgICBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pXG4gICAgICBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gICAgYWEgPSAtKGEgKyBtKSAqIChxYWIgKyBtKSAqIHggLyAoKGEgKyBtMikgKiAocWFwICsgbTIpKTtcbiAgICAvLyBOZXh0IHN0ZXAgb2YgdGhlIHJlY3VycmVuY2UgKHRoZSBvZGQgb25lKVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgICAgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKVxuICAgICAgYyA9IGZwbWluO1xuICAgIGQgPSAxIC8gZDtcbiAgICBkZWwgPSBkICogYztcbiAgICBoICo9IGRlbDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsIC0gMS4wKSA8IDNlLTcpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBsb3dlciByZWd1bGFyaXplZCBpbm9tcGxldGUgZ2FtbWEgZnVuY3Rpb25cbmpTdGF0LmdhbW1hcGludiA9IGZ1bmN0aW9uIGdhbW1hcGludihwLCBhKSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgZ2xuID0galN0YXQuZ2FtbWFsbihhKTtcbiAgdmFyIHgsIGVyciwgdCwgdSwgcHAsIGxuYTEsIGFmYWM7XG5cbiAgaWYgKHAgPj0gMSlcbiAgICByZXR1cm4gTWF0aC5tYXgoMTAwLCBhICsgMTAwICogTWF0aC5zcXJ0KGEpKTtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGEgPiAxKSB7XG4gICAgbG5hMSA9IE1hdGgubG9nKGExKTtcbiAgICBhZmFjID0gTWF0aC5leHAoYTEgKiAobG5hMSAtIDEpIC0gZ2xuKTtcbiAgICBwcCA9IChwIDwgMC41KSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIHggPSBNYXRoLm1heCgxZS0zLFxuICAgICAgICAgICAgICAgICBhICogTWF0aC5wb3coMSAtIDEgLyAoOSAqIGEpIC0geCAvICgzICogTWF0aC5zcXJ0KGEpKSwgMykpO1xuICB9IGVsc2Uge1xuICAgIHQgPSAxIC0gYSAqICgwLjI1MyArIGEgKiAwLjEyKTtcbiAgICBpZiAocCA8IHQpXG4gICAgICB4ID0gTWF0aC5wb3cocCAvIHQsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgubG9nKDEgLSAocCAtIHQpIC8gKDEgLSB0KSk7XG4gIH1cblxuICBmb3IoOyBqIDwgMTI7IGorKykge1xuICAgIGlmICh4IDw9IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBlcnIgPSBqU3RhdC5sb3dSZWdHYW1tYShhLCB4KSAtIHA7XG4gICAgaWYgKGEgPiAxKVxuICAgICAgdCA9IGFmYWMgKiBNYXRoLmV4cCgtKHggLSBhMSkgKyBhMSAqIChNYXRoLmxvZyh4KSAtIGxuYTEpKTtcbiAgICBlbHNlXG4gICAgICB0ID0gTWF0aC5leHAoLXggKyBhMSAqIE1hdGgubG9nKHgpIC0gZ2xuKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqICgoYSAtIDEpIC8geCAtIDEpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4KVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZXJyb3IgZnVuY3Rpb24gZXJmKHgpXG5qU3RhdC5lcmYgPSBmdW5jdGlvbiBlcmYoeCkge1xuICB2YXIgY29mID0gWy0xLjMwMjY1MzcxOTc4MTcwOTQsIDYuNDE5Njk3OTIzNTY0OTAyNmUtMSwgMS45NDc2NDczMjA0MTg1ODM2ZS0yLFxuICAgICAgICAgICAgIC05LjU2MTUxNDc4NjgwODYzMWUtMywgLTkuNDY1OTUzNDQ0ODIwMzZlLTQsIDMuNjY4Mzk0OTc4NTI3NjFlLTQsXG4gICAgICAgICAgICAgNC4yNTIzMzI0ODA2OTA3ZS01LCAtMi4wMjc4NTc4MTEyNTM0ZS01LCAtMS42MjQyOTAwMDQ2NDdlLTYsXG4gICAgICAgICAgICAgMS4zMDM2NTU4MzU1ODBlLTYsIDEuNTYyNjQ0MTcyMmUtOCwgLTguNTIzODA5NTkxNWUtOCxcbiAgICAgICAgICAgICA2LjUyOTA1NDQzOWUtOSwgNS4wNTkzNDM0OTVlLTksIC05LjkxMzY0MTU2ZS0xMCxcbiAgICAgICAgICAgICAtMi4yNzM2NTEyMmUtMTAsIDkuNjQ2NzkxMWUtMTEsIDIuMzk0MDM4ZS0xMixcbiAgICAgICAgICAgICAtNi44ODYwMjdlLTEyLCA4Ljk0NDg3ZS0xMywgMy4xMzA5MmUtMTMsXG4gICAgICAgICAgICAgLTEuMTI3MDhlLTEzLCAzLjgxZS0xNiwgNy4xMDZlLTE1LFxuICAgICAgICAgICAgIC0xLjUyM2UtMTUsIC05LjRlLTE3LCAxLjIxZS0xNixcbiAgICAgICAgICAgICAtMi44ZS0xN107XG4gIHZhciBqID0gY29mLmxlbmd0aCAtIDE7XG4gIHZhciBpc25lZyA9IGZhbHNlO1xuICB2YXIgZCA9IDA7XG4gIHZhciBkZCA9IDA7XG4gIHZhciB0LCB0eSwgdG1wLCByZXM7XG5cbiAgaWYgKHggPCAwKSB7XG4gICAgeCA9IC14O1xuICAgIGlzbmVnID0gdHJ1ZTtcbiAgfVxuXG4gIHQgPSAyIC8gKDIgKyB4KTtcbiAgdHkgPSA0ICogdCAtIDI7XG5cbiAgZm9yKDsgaiA+IDA7IGotLSkge1xuICAgIHRtcCA9IGQ7XG4gICAgZCA9IHR5ICogZCAtIGRkICsgY29mW2pdO1xuICAgIGRkID0gdG1wO1xuICB9XG5cbiAgcmVzID0gdCAqIE1hdGguZXhwKC14ICogeCArIDAuNSAqIChjb2ZbMF0gKyB0eSAqIGQpIC0gZGQpO1xuICByZXR1cm4gaXNuZWcgPyByZXMgLSAxIDogMSAtIHJlcztcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcGxtZW50YXJ5IGVycm9yIGZ1bmN0aW9uIGVyZmMoeClcbmpTdGF0LmVyZmMgPSBmdW5jdGlvbiBlcmZjKHgpIHtcbiAgcmV0dXJuIDEgLSBqU3RhdC5lcmYoeCk7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb25cbmpTdGF0LmVyZmNpbnYgPSBmdW5jdGlvbiBlcmZjaW52KHApIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgeCwgZXJyLCB0LCBwcDtcbiAgaWYgKHAgPj0gMilcbiAgICByZXR1cm4gLTEwMDtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMTAwO1xuICBwcCA9IChwIDwgMSkgPyBwIDogMiAtIHA7XG4gIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCAvIDIpKTtcbiAgeCA9IC0wLjcwNzExICogKCgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC9cbiAgICAgICAgICAgICAgICAgICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQpO1xuICBmb3IgKDsgaiA8IDI7IGorKykge1xuICAgIGVyciA9IGpTdGF0LmVyZmMoeCkgLSBwcDtcbiAgICB4ICs9IGVyciAvICgxLjEyODM3OTE2NzA5NTUxMjU3ICogTWF0aC5leHAoLXggKiB4KSAtIHggKiBlcnIpO1xuICB9XG4gIHJldHVybiAocCA8IDEpID8geCA6IC14O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb25cbmpTdGF0LmliZXRhaW52ID0gZnVuY3Rpb24gaWJldGFpbnYocCwgYSwgYikge1xuICB2YXIgRVBTID0gMWUtODtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBiMSA9IGIgLSAxO1xuICB2YXIgaiA9IDA7XG4gIHZhciBsbmEsIGxuYiwgcHAsIHQsIHUsIGVyciwgeCwgYWwsIGgsIHcsIGFmYWM7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChwID49IDEpXG4gICAgcmV0dXJuIDE7XG4gIGlmIChhID49IDEgJiYgYiA+PSAxKSB7XG4gICAgcHAgPSAocCA8IDAuNSkgPyBwIDogMSAtIHA7XG4gICAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwKSk7XG4gICAgeCA9ICgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC8gKDEgKyB0KiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIGFsID0gKHggKiB4IC0gMykgLyA2O1xuICAgIGggPSAyIC8gKDEgLyAoMiAqIGEgLSAxKSAgKyAxIC8gKDIgKiBiIC0gMSkpO1xuICAgIHcgPSAoeCAqIE1hdGguc3FydChhbCArIGgpIC8gaCkgLSAoMSAvICgyICogYiAtIDEpIC0gMSAvICgyICogYSAtIDEpKSAqXG4gICAgICAgIChhbCArIDUgLyA2IC0gMiAvICgzICogaCkpO1xuICAgIHggPSBhIC8gKGEgKyBiICogTWF0aC5leHAoMiAqIHcpKTtcbiAgfSBlbHNlIHtcbiAgICBsbmEgPSBNYXRoLmxvZyhhIC8gKGEgKyBiKSk7XG4gICAgbG5iID0gTWF0aC5sb2coYiAvIChhICsgYikpO1xuICAgIHQgPSBNYXRoLmV4cChhICogbG5hKSAvIGE7XG4gICAgdSA9IE1hdGguZXhwKGIgKiBsbmIpIC8gYjtcbiAgICB3ID0gdCArIHU7XG4gICAgaWYgKHAgPCB0IC8gdylcbiAgICAgIHggPSBNYXRoLnBvdyhhICogdyAqIHAsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgucG93KGIgKiB3ICogKDEgLSBwKSwgMSAvIGIpO1xuICB9XG4gIGFmYWMgPSAtalN0YXQuZ2FtbWFsbihhKSAtIGpTdGF0LmdhbW1hbG4oYikgKyBqU3RhdC5nYW1tYWxuKGEgKyBiKTtcbiAgZm9yKDsgaiA8IDEwOyBqKyspIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKVxuICAgICAgcmV0dXJuIHg7XG4gICAgZXJyID0galN0YXQuaWJldGEoeCwgYSwgYikgLSBwO1xuICAgIHQgPSBNYXRoLmV4cChhMSAqIE1hdGgubG9nKHgpICsgYjEgKiBNYXRoLmxvZygxIC0geCkgKyBhZmFjKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqIChhMSAvIHggLSBiMSAvICgxIC0geCkpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoeCA+PSAxKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCArIDEpO1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQUyAqIHggJiYgaiA+IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIElfeChhLGIpXG5qU3RhdC5pYmV0YSA9IGZ1bmN0aW9uIGliZXRhKHgsIGEsIGIpIHtcbiAgLy8gRmFjdG9ycyBpbiBmcm9udCBvZiB0aGUgY29udGludWVkIGZyYWN0aW9uLlxuICB2YXIgYnQgPSAoeCA9PT0gMCB8fCB4ID09PSAxKSA/ICAwIDpcbiAgICBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKGEgKyBiKSAtIGpTdGF0LmdhbW1hbG4oYSkgLVxuICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oYikgKyBhICogTWF0aC5sb2coeCkgKyBiICpcbiAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCkpO1xuICBpZiAoeCA8IDAgfHwgeCA+IDEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoeCA8IChhICsgMSkgLyAoYSArIGIgKyAyKSlcbiAgICAvLyBVc2UgY29udGludWVkIGZyYWN0aW9uIGRpcmVjdGx5LlxuICAgIHJldHVybiBidCAqIGpTdGF0LmJldGFjZih4LCBhLCBiKSAvIGE7XG4gIC8vIGVsc2UgdXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBhZnRlciBtYWtpbmcgdGhlIHN5bW1ldHJ5IHRyYW5zZm9ybWF0aW9uLlxuICByZXR1cm4gMSAtIGJ0ICogalN0YXQuYmV0YWNmKDEgLSB4LCBiLCBhKSAvIGI7XG59O1xuXG5cbi8vIFJldHVybnMgYSBub3JtYWwgZGV2aWF0ZSAobXU9MCwgc2lnbWE9MSkuXG4vLyBJZiBuIGFuZCBtIGFyZSBzcGVjaWZpZWQgaXQgcmV0dXJucyBhIG9iamVjdCBvZiBub3JtYWwgZGV2aWF0ZXMuXG5qU3RhdC5yYW5kbiA9IGZ1bmN0aW9uIHJhbmRuKG4sIG0pIHtcbiAgdmFyIHUsIHYsIHgsIHksIHE7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIGpTdGF0LmNyZWF0ZShuLCBtLCBmdW5jdGlvbigpIHsgcmV0dXJuIGpTdGF0LnJhbmRuKCk7IH0pO1xuICBkbyB7XG4gICAgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgICB2ID0gMS43MTU2ICogKGpTdGF0Ll9yYW5kb21fZm4oKSAtIDAuNSk7XG4gICAgeCA9IHUgLSAwLjQ0OTg3MTtcbiAgICB5ID0gTWF0aC5hYnModikgKyAwLjM4NjU5NTtcbiAgICBxID0geCAqIHggKyB5ICogKDAuMTk2MDAgKiB5IC0gMC4yNTQ3MiAqIHgpO1xuICB9IHdoaWxlIChxID4gMC4yNzU5NyAmJiAocSA+IDAuMjc4NDYgfHwgdiAqIHYgPiAtNCAqIE1hdGgubG9nKHUpICogdSAqIHUpKTtcbiAgcmV0dXJuIHYgLyB1O1xufTtcblxuXG4vLyBSZXR1cm5zIGEgZ2FtbWEgZGV2aWF0ZSBieSB0aGUgbWV0aG9kIG9mIE1hcnNhZ2xpYSBhbmQgVHNhbmcuXG5qU3RhdC5yYW5kZyA9IGZ1bmN0aW9uIHJhbmRnKHNoYXBlLCBuLCBtKSB7XG4gIHZhciBvYWxwaCA9IHNoYXBlO1xuICB2YXIgYTEsIGEyLCB1LCB2LCB4LCBtYXQ7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKCFzaGFwZSlcbiAgICBzaGFwZSA9IDE7XG4gIGlmIChuKSB7XG4gICAgbWF0ID0galN0YXQuemVyb3MobixtKTtcbiAgICBtYXQuYWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSk7IH0pO1xuICAgIHJldHVybiBtYXQ7XG4gIH1cbiAgaWYgKHNoYXBlIDwgMSlcbiAgICBzaGFwZSArPSAxO1xuICBhMSA9IHNoYXBlIC0gMSAvIDM7XG4gIGEyID0gMSAvIE1hdGguc3FydCg5ICogYTEpO1xuICBkbyB7XG4gICAgZG8ge1xuICAgICAgeCA9IGpTdGF0LnJhbmRuKCk7XG4gICAgICB2ID0gMSArIGEyICogeDtcbiAgICB9IHdoaWxlKHYgPD0gMCk7XG4gICAgdiA9IHYgKiB2ICogdjtcbiAgICB1ID0galN0YXQuX3JhbmRvbV9mbigpO1xuICB9IHdoaWxlKHUgPiAxIC0gMC4zMzEgKiBNYXRoLnBvdyh4LCA0KSAmJlxuICAgICAgICAgIE1hdGgubG9nKHUpID4gMC41ICogeCp4ICsgYTEgKiAoMSAtIHYgKyBNYXRoLmxvZyh2KSkpO1xuICAvLyBhbHBoYSA+IDFcbiAgaWYgKHNoYXBlID09IG9hbHBoKVxuICAgIHJldHVybiBhMSAqIHY7XG4gIC8vIGFscGhhIDwgMVxuICBkbyB7XG4gICAgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgfSB3aGlsZSh1ID09PSAwKTtcbiAgcmV0dXJuIE1hdGgucG93KHUsIDEgLyBvYWxwaCkgKiBhMSAqIHY7XG59O1xuXG5cbi8vIG1ha2luZyB1c2Ugb2Ygc3RhdGljIG1ldGhvZHMgb24gdGhlIGluc3RhbmNlXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galN0YXQoXG4gICAgICAgICAgalN0YXQubWFwKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBqU3RhdFtwYXNzZnVuY10odmFsdWUpOyB9KSk7XG4gICAgfVxuICB9KShmdW5jc1tpXSk7XG59KSgnZ2FtbWFsbiBnYW1tYWZuIGZhY3RvcmlhbCBmYWN0b3JpYWxsbicuc3BsaXQoJyAnKSk7XG5cblxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncmFuZG4nLnNwbGl0KCcgJykpO1xuXG59KGpTdGF0LCBNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gZ2VuZXJhdGUgYWxsIGRpc3RyaWJ1dGlvbiBpbnN0YW5jZSBtZXRob2RzXG4oZnVuY3Rpb24obGlzdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gZGlzdHJpYnV0aW9uIGluc3RhbmNlIG1ldGhvZFxuICAgIGpTdGF0W2Z1bmNdID0gZnVuY3Rpb24gZihhLCBiLCBjKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZikpXG4gICAgICAgIHJldHVybiBuZXcgZihhLCBiLCBjKTtcbiAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gZGlzdHJpYnV0aW9uIG1ldGhvZCB0byBiZSB1c2VkIG9uIGEgalN0YXQgaW5zdGFuY2VcbiAgICBqU3RhdC5mbltmdW5jXSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHZhciBuZXd0aGlzID0galN0YXRbZnVuY10oYSwgYiwgYyk7XG4gICAgICBuZXd0aGlzLmRhdGEgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ld3RoaXM7XG4gICAgfTtcbiAgICAvLyBzYW1wbGUgaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10ucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hO1xuICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgdmFyIGMgPSB0aGlzLl9jO1xuICAgICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdLnNhbXBsZShhLCBiLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqU3RhdFtmdW5jXS5zYW1wbGUoYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgcGRmLCBjZGYgYW5kIGludiBpbnN0YW5jZSBtZXRob2RzXG4gICAgKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZuZnVuYykge1xuICAgICAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGVbZm5mdW5jXSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuX2E7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fYztcbiAgICAgICAgICBpZiAoIXggJiYgeCAhPT0gMClcbiAgICAgICAgICAgIHggPSB0aGlzLmRhdGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGpTdGF0LmZuLm1hcC5jYWxsKHgsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgncGRmIGNkZiBpbnYnLnNwbGl0KCcgJykpO1xuICAgIC8vIGdlbmVyYXRlIHRoZSBtZWFuLCBtZWRpYW4sIG1vZGUgYW5kIHZhcmlhbmNlIGluc3RhbmNlIG1ldGhvZHNcbiAgICAoZnVuY3Rpb24odmFscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZm5mdW5jKSB7XG4gICAgICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZVtmbmZ1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgnbWVhbiBtZWRpYW4gbW9kZSB2YXJpYW5jZScuc3BsaXQoJyAnKSk7XG4gIH0pKGxpc3RbaV0pO1xufSkoKFxuICAnYmV0YSBjZW50cmFsRiBjYXVjaHkgY2hpc3F1YXJlIGV4cG9uZW50aWFsIGdhbW1hIGludmdhbW1hIGt1bWFyYXN3YW15ICcgK1xuICAnbGFwbGFjZSBsb2dub3JtYWwgbm9uY2VudHJhbHQgbm9ybWFsIHBhcmV0byBzdHVkZW50dCB3ZWlidWxsIHVuaWZvcm0gJyArXG4gICdiaW5vbWlhbCBuZWdiaW4gaHlwZ2VvbSBwb2lzc29uIHRyaWFuZ3VsYXIgdHVrZXkgYXJjc2luZSdcbikuc3BsaXQoJyAnKSk7XG5cblxuXG4vLyBleHRlbmQgYmV0YSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYmV0YSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIC8vIFBERiBpcyB6ZXJvIG91dHNpZGUgdGhlIHN1cHBvcnRcbiAgICBpZiAoeCA+IDEgfHwgeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICAvLyBQREYgaXMgb25lIGZvciB0aGUgdW5pZm9ybSBjYXNlXG4gICAgaWYgKGFscGhhID09IDEgJiYgYmV0YSA9PSAxKVxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBpZiAoYWxwaGEgPCA1MTIgJiYgYmV0YSA8IDUxMikge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCBhbHBoYSAtIDEpICogTWF0aC5wb3coMSAtIHgsIGJldGEgLSAxKSkgL1xuICAgICAgICAgIGpTdGF0LmJldGFmbihhbHBoYSwgYmV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cCgoYWxwaGEgLSAxKSAqIE1hdGgubG9nKHgpICtcbiAgICAgICAgICAgICAgICAgICAgICAoYmV0YSAtIDEpICogTWF0aC5sb2coMSAtIHgpIC1cbiAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5iZXRhbG4oYWxwaGEsIGJldGEpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKHggPiAxIHx8IHggPCAwKSA/ICh4ID4gMSkgKiAxIDogalN0YXQuaWJldGEoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhaW52KHgsIGFscGhhLCBiZXRhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGFscGhhIC8gKGFscGhhICsgYmV0YSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4galN0YXQuaWJldGFpbnYoMC41LCBhbHBoYSwgYmV0YSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgLSAxICkgLyAoIGFscGhhICsgYmV0YSAtIDIpO1xuICB9LFxuXG4gIC8vIHJldHVybiBhIHJhbmRvbSBzYW1wbGVcbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYWxwaGEsIGJldGEpIHtcbiAgICB2YXIgdSA9IGpTdGF0LnJhbmRnKGFscGhhKTtcbiAgICByZXR1cm4gdSAvICh1ICsgalN0YXQucmFuZGcoYmV0YSkpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgKiBiZXRhKSAvIChNYXRoLnBvdyhhbHBoYSArIGJldGEsIDIpICogKGFscGhhICsgYmV0YSArIDEpKTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBGIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jZW50cmFsRiwge1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwZGYgZnVuY3Rpb24gYXZvaWRzIGZsb2F0IG92ZXJmbG93XG4gIC8vIFNlZSB0aGUgd2F5IHRoYXQgUiBjYWxjdWxhdGVzIHRoaXMgdmFsdWU6XG4gIC8vIGh0dHBzOi8vc3ZuLnItcHJvamVjdC5vcmcvUi90cnVuay9zcmMvbm1hdGgvZGYuY1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkZjEsIGRmMikge1xuICAgIHZhciBwLCBxLCBmO1xuXG4gICAgaWYgKHggPCAwKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBpZiAoZGYxIDw9IDIpIHtcbiAgICAgIGlmICh4ID09PSAwICYmIGRmMSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IDAgJiYgZGYxID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgxIC8galN0YXQuYmV0YWZuKGRmMSAvIDIsIGRmMiAvIDIpKSAqXG4gICAgICAgICAgICAgIE1hdGgucG93KGRmMSAvIGRmMiwgZGYxIC8gMikgKlxuICAgICAgICAgICAgICBNYXRoLnBvdyh4LCAoZGYxLzIpIC0gMSkgKlxuICAgICAgICAgICAgICBNYXRoLnBvdygoMSArIChkZjEgLyBkZjIpICogeCksIC0oZGYxICsgZGYyKSAvIDIpO1xuICAgIH1cblxuICAgIHAgPSAoZGYxICogeCkgLyAoZGYyICsgeCAqIGRmMSk7XG4gICAgcSA9IGRmMiAvIChkZjIgKyB4ICogZGYxKTtcbiAgICBmID0gZGYxICogcSAvIDIuMDtcbiAgICByZXR1cm4gZiAqIGpTdGF0LmJpbm9taWFsLnBkZigoZGYxIC0gMikgLyAyLCAoZGYxICsgZGYyIC0gMikgLyAyLCBwKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkZjEsIGRmMikge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBqU3RhdC5pYmV0YSgoZGYxICogeCkgLyAoZGYxICogeCArIGRmMiksIGRmMSAvIDIsIGRmMiAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIGRmMiAvIChkZjEgKiAoMSAvIGpTdGF0LmliZXRhaW52KHgsIGRmMSAvIDIsIGRmMiAvIDIpIC0gMSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMiA+IDIpID8gZGYyIC8gKGRmMiAtIDIpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMSA+IDIpID8gKGRmMiAqIChkZjEgLSAyKSkgLyAoZGYxICogKGRmMiArIDIpKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRmMSwgZGYyKSB7XG4gICAgdmFyIHgxID0galN0YXQucmFuZGcoZGYxIC8gMikgKiAyO1xuICAgIHZhciB4MiA9IGpTdGF0LnJhbmRnKGRmMiAvIDIpICogMjtcbiAgICByZXR1cm4gKHgxIC8gZGYxKSAvICh4MiAvIGRmMik7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRmMSwgZGYyKSB7XG4gICAgaWYgKGRmMiA8PSA0KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gMiAqIGRmMiAqIGRmMiAqIChkZjEgKyBkZjIgLSAyKSAvXG4gICAgICAgIChkZjEgKiAoZGYyIC0gMikgKiAoZGYyIC0gMikgKiAoZGYyIC0gNCkpO1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgY2F1Y2h5IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jYXVjaHksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlIDwgMCkgeyByZXR1cm4gMDsgfVxuXG4gICAgcmV0dXJuIChzY2FsZSAvIChNYXRoLnBvdyh4IC0gbG9jYWwsIDIpICsgTWF0aC5wb3coc2NhbGUsIDIpKSkgLyBNYXRoLlBJO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4oKHggLSBsb2NhbCkgLyBzY2FsZSkgLyBNYXRoLlBJICsgMC41O1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsICsgc2NhbGUgKiBNYXRoLnRhbihNYXRoLlBJICogKHAgLSAwLjUpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihsb2NhbC8qLCBzY2FsZSovKSB7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUobG9jYWwvKiwgc2NhbGUqLykge1xuICAgIHJldHVybiBsb2NhbDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqXG4gICAgICAgIE1hdGguc3FydCgxIC8gKDIgKiBqU3RhdC5yYW5kZygwLjUpKSkgKiBzY2FsZSArIGxvY2FsO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBjaGlzcXVhcmUgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmNoaXNxdWFyZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHggPT09IDAgJiYgZG9mID09PSAyKSA/IDAuNSA6XG4gICAgICAgIE1hdGguZXhwKChkb2YgLyAyIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyAyIC0gKGRvZiAvIDIpICpcbiAgICAgICAgICAgICAgICAgTWF0aC5sb2coMikgLSBqU3RhdC5nYW1tYWxuKGRvZiAvIDIpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkb2YpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4galN0YXQubG93UmVnR2FtbWEoZG9mIC8gMiwgeCAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBqU3RhdC5nYW1tYXBpbnYocCwgMC41ICogZG9mKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oZG9mKSB7XG4gICAgcmV0dXJuIGRvZjtcbiAgfSxcblxuICAvLyBUT0RPOiB0aGlzIGlzIGFuIGFwcHJveGltYXRpb24gKGlzIHRoZXJlIGEgYmV0dGVyIHdheT8pXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGRvZikge1xuICAgIHJldHVybiBkb2YgKiBNYXRoLnBvdygxIC0gKDIgLyAoOSAqIGRvZikpLCAzKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGRvZikge1xuICAgIHJldHVybiAoZG9mIC0gMiA+IDApID8gZG9mIC0gMiA6IDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRnKGRvZiAvIDIpICogMjtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBkb2Y7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGV4cG9uZW50aWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5leHBvbmVudGlhbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCByYXRlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IHJhdGUgKiBNYXRoLmV4cCgtcmF0ZSAqIHgpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHJhdGUpIHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogMSAtIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCByYXRlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmxvZygxIC0gcCkgLyByYXRlO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIDEgLyByYXRlO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gKHJhdGUpIHtcbiAgICByZXR1cm4gKDEgLyByYXRlKSAqIE1hdGgubG9nKDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoLypyYXRlKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShyYXRlKSB7XG4gICAgcmV0dXJuIC0xIC8gcmF0ZSAqIE1hdGgubG9nKGpTdGF0Ll9yYW5kb21fZm4oKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHJhdGUsIC0yKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgZ2FtbWEgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmdhbW1hLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAoeCA9PT0gMCAmJiBzaGFwZSA9PT0gMSkgPyAxIC8gc2NhbGUgOlxuICAgICAgICAgICAgTWF0aC5leHAoKHNoYXBlIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyBzY2FsZSAtXG4gICAgICAgICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oc2hhcGUpIC0gc2hhcGUgKiBNYXRoLmxvZyhzY2FsZSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBqU3RhdC5sb3dSZWdHYW1tYShzaGFwZSwgeCAvIHNjYWxlKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXBpbnYocCwgc2hhcGUpICogc2NhbGU7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzaGFwZSAqIHNjYWxlO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYoc2hhcGUgPiAxKSByZXR1cm4gKHNoYXBlIC0gMSkgKiBzY2FsZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSkgKiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNoYXBlICogc2NhbGUgKiBzY2FsZTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBpbnZlcnNlIGdhbW1hIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5pbnZnYW1tYSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICBpZiAoeCA8PSAwKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0oc2hhcGUgKyAxKSAqIE1hdGgubG9nKHgpIC0gc2NhbGUgLyB4IC1cbiAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihzaGFwZSkgKyBzaGFwZSAqIE1hdGgubG9nKHNjYWxlKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAxIC0galN0YXQubG93UmVnR2FtbWEoc2hhcGUsIHNjYWxlIC8geCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyBqU3RhdC5nYW1tYXBpbnYoMSAtIHAsIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzaGFwZSA+IDEpID8gc2NhbGUgLyAoc2hhcGUgLSAxKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIChzaGFwZSArIDEpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIGpTdGF0LnJhbmRnKHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIHNjYWxlIC8gKChzaGFwZSAtIDEpICogKHNoYXBlIC0gMSkgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cbi8vIGV4dGVuZCBrdW1hcmFzd2FteSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQua3VtYXJhc3dhbXksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICBpZiAoeCA9PT0gMCAmJiBhbHBoYSA9PT0gMSlcbiAgICAgIHJldHVybiBiZXRhO1xuICAgIGVsc2UgaWYgKHggPT09IDEgJiYgYmV0YSA9PT0gMSlcbiAgICAgIHJldHVybiBhbHBoYTtcbiAgICByZXR1cm4gTWF0aC5leHAoTWF0aC5sb2coYWxwaGEpICsgTWF0aC5sb2coYmV0YSkgKyAoYWxwaGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHgpICsgKGJldGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSBNYXRoLnBvdyh4LCBhbHBoYSkpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKHggPiAxKVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuICgxIC0gTWF0aC5wb3coMSAtIE1hdGgucG93KHgsIGFscGhhKSwgYmV0YSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSBNYXRoLnBvdygxIC0gcCwgMSAvIGJldGEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYmV0YSAqIGpTdGF0LmdhbW1hZm4oMSArIDEgLyBhbHBoYSkgKlxuICAgICAgICAgICAgalN0YXQuZ2FtbWFmbihiZXRhKSkgLyAoalN0YXQuZ2FtbWFmbigxICsgMSAvIGFscGhhICsgYmV0YSkpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSBNYXRoLnBvdygyLCAtMSAvIGJldGEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYWxwaGEsIGJldGEpIHtcbiAgICBpZiAoIShhbHBoYSA+PSAxICYmIGJldGEgPj0gMSAmJiAoYWxwaGEgIT09IDEgJiYgYmV0YSAhPT0gMSkpKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTWF0aC5wb3coKGFscGhhIC0gMSkgLyAoYWxwaGEgKiBiZXRhIC0gMSksIDEgLyBhbHBoYSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKC8qYWxwaGEsIGJldGEqLykge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFuY2Ugbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIC8vIFRPRE86IGNvbXBsZXRlIHRoaXNcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbG9nbm9ybWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5sb2dub3JtYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLmV4cCgtTWF0aC5sb2coeCkgLSAwLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyhzaWdtYSkgLSBNYXRoLnBvdyhNYXRoLmxvZyh4KSAtIG11LCAyKSAvXG4gICAgICAgICAgICAgICAgICAgICgyICogc2lnbWEgKiBzaWdtYSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG11LCBzaWdtYSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAwLjUgK1xuICAgICAgICAoMC41ICogalN0YXQuZXJmKChNYXRoLmxvZyh4KSAtIG11KSAvIE1hdGguc3FydCgyICogc2lnbWEgKiBzaWdtYSkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHNpZ21hICogalN0YXQuZXJmY2ludigyICogcCkgKyBtdSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgKyBzaWdtYSAqIHNpZ21hIC8gMik7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obXUvKiwgc2lnbWEqLykge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgLSBzaWdtYSAqIHNpZ21hKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoalN0YXQucmFuZG4oKSAqIHNpZ21hICsgbXUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gKE1hdGguZXhwKHNpZ21hICogc2lnbWEpIC0gMSkgKiBNYXRoLmV4cCgyICogbXUgKyBzaWdtYSAqIHNpZ21hKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbm9uY2VudHJhbHQgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lm5vbmNlbnRyYWx0LCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGRvZiwgbmNwKSB7XG4gICAgdmFyIHRvbCA9IDFlLTE0O1xuICAgIGlmIChNYXRoLmFicyhuY3ApIDwgdG9sKSAgLy8gbmNwIGFwcHJveCAwOyB1c2Ugc3R1ZGVudC10XG4gICAgICByZXR1cm4galN0YXQuc3R1ZGVudHQucGRmKHgsIGRvZilcblxuICAgIGlmIChNYXRoLmFicyh4KSA8IHRvbCkgeyAgLy8gZGlmZmVyZW50IGZvcm11bGEgZm9yIHggPT0gMFxuICAgICAgcmV0dXJuIE1hdGguZXhwKGpTdGF0LmdhbW1hbG4oKGRvZiArIDEpIC8gMikgLSBuY3AgKiBuY3AgLyAyIC1cbiAgICAgICAgICAgICAgICAgICAgICAwLjUgKiBNYXRoLmxvZyhNYXRoLlBJICogZG9mKSAtIGpTdGF0LmdhbW1hbG4oZG9mIC8gMikpO1xuICAgIH1cblxuICAgIC8vIGZvcm11bGEgZm9yIHggIT0gMFxuICAgIHJldHVybiBkb2YgLyB4ICpcbiAgICAgICAgKGpTdGF0Lm5vbmNlbnRyYWx0LmNkZih4ICogTWF0aC5zcXJ0KDEgKyAyIC8gZG9mKSwgZG9mKzIsIG5jcCkgLVxuICAgICAgICAgalN0YXQubm9uY2VudHJhbHQuY2RmKHgsIGRvZiwgbmNwKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mLCBuY3ApIHtcbiAgICB2YXIgdG9sID0gMWUtMTQ7XG4gICAgdmFyIG1pbl9pdGVyYXRpb25zID0gMjAwO1xuXG4gICAgaWYgKE1hdGguYWJzKG5jcCkgPCB0b2wpICAvLyBuY3AgYXBwcm94IDA7IHVzZSBzdHVkZW50LXRcbiAgICAgIHJldHVybiBqU3RhdC5zdHVkZW50dC5jZGYoeCwgZG9mKTtcblxuICAgIC8vIHR1cm4gbmVnYXRpdmUgeCBpbnRvIHBvc2l0aXZlIGFuZCBmbGlwIHJlc3VsdCBhZnRlcndhcmRzXG4gICAgdmFyIGZsaXAgPSBmYWxzZTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGZsaXAgPSB0cnVlO1xuICAgICAgbmNwID0gLW5jcDtcbiAgICB9XG5cbiAgICB2YXIgcHJvYiA9IGpTdGF0Lm5vcm1hbC5jZGYoLW5jcCwgMCwgMSk7XG4gICAgdmFyIHZhbHVlID0gdG9sICsgMTtcbiAgICAvLyB1c2UgdmFsdWUgYXQgbGFzdCB0d28gc3RlcHMgdG8gZGV0ZXJtaW5lIGNvbnZlcmdlbmNlXG4gICAgdmFyIGxhc3R2YWx1ZSA9IHZhbHVlO1xuICAgIHZhciB5ID0geCAqIHggLyAoeCAqIHggKyBkb2YpO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgcCA9IE1hdGguZXhwKC1uY3AgKiBuY3AgLyAyKTtcbiAgICB2YXIgcSA9IE1hdGguZXhwKC1uY3AgKiBuY3AgLyAyIC0gMC41ICogTWF0aC5sb2coMikgLVxuICAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbigzIC8gMikpICogbmNwO1xuICAgIHdoaWxlIChqIDwgbWluX2l0ZXJhdGlvbnMgfHwgbGFzdHZhbHVlID4gdG9sIHx8IHZhbHVlID4gdG9sKSB7XG4gICAgICBsYXN0dmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBwICo9IChuY3AgKiBuY3ApIC8gKDIgKiBqKTtcbiAgICAgICAgcSAqPSAobmNwICogbmNwKSAvICgyICogKGogKyAxIC8gMikpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwICogalN0YXQuYmV0YS5jZGYoeSwgaiArIDAuNSwgZG9mIC8gMikgK1xuICAgICAgICAgIHEgKiBqU3RhdC5iZXRhLmNkZih5LCBqKzEsIGRvZi8yKTtcbiAgICAgIHByb2IgKz0gMC41ICogdmFsdWU7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsaXAgPyAoMSAtIHByb2IpIDogcHJvYjtcbiAgfVxufSk7XG5cblxuLy8gZXh0ZW5kIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubm9ybWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5sb2coMiAqIE1hdGguUEkpIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coc3RkKSAtIE1hdGgucG93KHggLSBtZWFuLCAyKSAvICgyICogc3RkICogc3RkKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxICsgalN0YXQuZXJmKCh4IC0gbWVhbikgLyBNYXRoLnNxcnQoMiAqIHN0ZCAqIHN0ZCkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiAtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHN0ZCAqIGpTdGF0LmVyZmNpbnYoMiAqIHApICsgbWVhbjtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24obWVhbi8qLCBzdGQqLykge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKG1lYW4vKiwgc3RkKi8pIHtcbiAgICByZXR1cm4gbWVhbjtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiAobWVhbi8qLCBzdGQqLykge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICogc3RkICsgbWVhbjtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBzdGQgKiBzdGQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHBhcmV0byBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucGFyZXRvLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgc2NhbGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHNoYXBlICogTWF0aC5wb3coc2NhbGUsIHNoYXBlKSkgLyBNYXRoLnBvdyh4LCBzaGFwZSArIDEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgc2NhbGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KHNjYWxlIC8geCwgc2hhcGUpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAvIE1hdGgucG93KDEgLSBwLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDEpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoc2hhcGUgKiBNYXRoLnBvdyhzY2FsZSwgc2hhcGUpKSAvIChzaGFwZSAtIDEpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIChzaGFwZSAqIE1hdGguU1FSVDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2NhbGUvKiwgc2hhcGUqLykge1xuICAgIHJldHVybiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAyKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNjYWxlKnNjYWxlICogc2hhcGUpIC8gKE1hdGgucG93KHNoYXBlIC0gMSwgMikgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHN0dWRlbnR0IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5zdHVkZW50dCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICBkb2YgPSBkb2YgPiAxZTEwMCA/IDFlMTAwIDogZG9mO1xuICAgIHJldHVybiAoMS8oTWF0aC5zcXJ0KGRvZikgKiBqU3RhdC5iZXRhZm4oMC41LCBkb2YvMikpKSAqXG4gICAgICAgIE1hdGgucG93KDEgKyAoKHggKiB4KSAvIGRvZiksIC0oKGRvZiArIDEpIC8gMikpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRvZikge1xuICAgIHZhciBkb2YyID0gZG9mIC8gMjtcbiAgICByZXR1cm4galN0YXQuaWJldGEoKHggKyBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICgyICogTWF0aC5zcXJ0KHggKiB4ICsgZG9mKSksIGRvZjIsIGRvZjIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgdmFyIHggPSBqU3RhdC5pYmV0YWludigyICogTWF0aC5taW4ocCwgMSAtIHApLCAwLjUgKiBkb2YsIDAuNSk7XG4gICAgeCA9IE1hdGguc3FydChkb2YgKiAoMSAtIHgpIC8geCk7XG4gICAgcmV0dXJuIChwID4gMC41KSA/IHggOiAteDtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGRvZikge1xuICAgIHJldHVybiAoZG9mID4gMSkgPyAwIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKC8qZG9mKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKC8qZG9mKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShkb2YpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqIE1hdGguc3FydChkb2YgLyAoMiAqIGpTdGF0LnJhbmRnKGRvZiAvIDIpKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRvZikge1xuICAgIHJldHVybiAoZG9mICA+IDIpID8gZG9mIC8gKGRvZiAtIDIpIDogKGRvZiA+IDEpID8gSW5maW5pdHkgOiB1bmRlZmluZWQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHdlaWJ1bGwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LndlaWJ1bGwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHggPCAwIHx8IHNjYWxlIDwgMCB8fCBzaGFwZSA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHNoYXBlIC8gc2NhbGUpICogTWF0aC5wb3coKHggLyBzY2FsZSksIChzaGFwZSAtIDEpKSAqXG4gICAgICAgIE1hdGguZXhwKC0oTWF0aC5wb3coKHggLyBzY2FsZSksIHNoYXBlKSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiAxIC0gTWF0aC5leHAoLU1hdGgucG93KCh4IC8gc2NhbGUpLCBzaGFwZSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coLU1hdGgubG9nKDEgLSBwKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogalN0YXQuZ2FtbWFmbigxICsgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdyhNYXRoLmxvZygyKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAxKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coKHNoYXBlIC0gMSkgLyBzaGFwZSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygtTWF0aC5sb2coalN0YXQuX3JhbmRvbV9mbigpKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogc2NhbGUgKiBqU3RhdC5nYW1tYWZuKDEgKyAyIC8gc2hhcGUpIC1cbiAgICAgICAgTWF0aC5wb3coalN0YXQud2VpYnVsbC5tZWFuKHNjYWxlLCBzaGFwZSksIDIpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC51bmlmb3JtLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIpIHtcbiAgICByZXR1cm4gKHggPCBhIHx8IHggPiBiKSA/IDAgOiAxIC8gKGIgLSBhKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhLCBiKSB7XG4gICAgaWYgKHggPCBhKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoeCA8IGIpXG4gICAgICByZXR1cm4gKHggLSBhKSAvIChiIC0gYSk7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyAocCAqIChiIC0gYSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oYSwgYikge1xuICAgIHJldHVybiAwLjUgKiAoYSArIGIpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIpIHtcbiAgICByZXR1cm4galN0YXQubWVhbihhLCBiKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKC8qYSwgYiovKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gMiArIGIgLyAyKSArIChiIC8gMiAtIGEgLyAyKSAqICgyICogalN0YXQuX3JhbmRvbV9mbigpIC0gMSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYiAtIGEsIDIpIC8gMTI7XG4gIH1cbn0pO1xuXG5cbi8vIEdvdCB0aGlzIGZyb20gaHR0cDovL3d3dy5tYXRoLnVjbGEuZWR1L350b20vZGlzdHJpYnV0aW9ucy9iaW5vbWlhbC5odG1sXG5mdW5jdGlvbiBiZXRpbmMoeCwgYSwgYiwgZXBzKSB7XG4gIHZhciBhMCA9IDA7XG4gIHZhciBiMCA9IDE7XG4gIHZhciBhMSA9IDE7XG4gIHZhciBiMSA9IDE7XG4gIHZhciBtOSA9IDA7XG4gIHZhciBhMiA9IDA7XG4gIHZhciBjOTtcblxuICB3aGlsZSAoTWF0aC5hYnMoKGExIC0gYTIpIC8gYTEpID4gZXBzKSB7XG4gICAgYTIgPSBhMTtcbiAgICBjOSA9IC0oYSArIG05KSAqIChhICsgYiArIG05KSAqIHggLyAoYSArIDIgKiBtOSkgLyAoYSArIDIgKiBtOSArIDEpO1xuICAgIGEwID0gYTEgKyBjOSAqIGEwO1xuICAgIGIwID0gYjEgKyBjOSAqIGIwO1xuICAgIG05ID0gbTkgKyAxO1xuICAgIGM5ID0gbTkgKiAoYiAtIG05KSAqIHggLyAoYSArIDIgKiBtOSAtIDEpIC8gKGEgKyAyICogbTkpO1xuICAgIGExID0gYTAgKyBjOSAqIGExO1xuICAgIGIxID0gYjAgKyBjOSAqIGIxO1xuICAgIGEwID0gYTAgLyBiMTtcbiAgICBiMCA9IGIwIC8gYjE7XG4gICAgYTEgPSBhMSAvIGIxO1xuICAgIGIxID0gMTtcbiAgfVxuXG4gIHJldHVybiBhMSAvIGE7XG59XG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmJpbm9taWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIG4sIHApIHtcbiAgICByZXR1cm4gKHAgPT09IDAgfHwgcCA9PT0gMSkgP1xuICAgICAgKChuICogcCkgPT09IGsgPyAxIDogMCkgOlxuICAgICAgalN0YXQuY29tYmluYXRpb24obiwgaykgKiBNYXRoLnBvdyhwLCBrKSAqIE1hdGgucG93KDEgLSBwLCBuIC0gayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbiwgcCkge1xuICAgIHZhciBiZXRhY2RmO1xuICAgIHZhciBlcHMgPSAxZS0xMDtcblxuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmICh4ID49IG4pXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAocCA8IDAgfHwgcCA+IDEgfHwgbiA8PSAwKVxuICAgICAgcmV0dXJuIE5hTjtcblxuICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgIHZhciB6ID0gcDtcbiAgICB2YXIgYSA9IHggKyAxO1xuICAgIHZhciBiID0gbiAtIHg7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgYnQgPSBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKHMpIC0galN0YXQuZ2FtbWFsbihiKSAtXG4gICAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihhKSArIGEgKiBNYXRoLmxvZyh6KSArIGIgKiBNYXRoLmxvZygxIC0geikpO1xuXG4gICAgaWYgKHogPCAoYSArIDEpIC8gKHMgKyAyKSlcbiAgICAgIGJldGFjZGYgPSBidCAqIGJldGluYyh6LCBhLCBiLCBlcHMpO1xuICAgIGVsc2VcbiAgICAgIGJldGFjZGYgPSAxIC0gYnQgKiBiZXRpbmMoMSAtIHosIGIsIGEsIGVwcyk7XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoMSAtIGJldGFjZGYpICogKDEgLyBlcHMpKSAvICgxIC8gZXBzKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubmVnYmluLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIHIsIHApIHtcbiAgICBpZiAoayAhPT0gayA+Pj4gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoayA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4galN0YXQuY29tYmluYXRpb24oayArIHIgLSAxLCByIC0gMSkgKlxuICAgICAgICBNYXRoLnBvdygxIC0gcCwgaykgKiBNYXRoLnBvdyhwLCByKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByLCBwKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gMDtcbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bSArPSBqU3RhdC5uZWdiaW4ucGRmKGssIHIsIHApO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5oeXBnZW9tLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBQREYuXG5cbiAgICAvLyBBIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSBDREYgYWxnb3JpdGhtIGJlbG93LlxuXG4gICAgLy8gayA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG5cbiAgICBpZihrICE9PSBrIHwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZihrIDwgMCB8fCBrIDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZihrID4gbiB8fCBrID4gbSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBtYW55IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobSAqIDIgPiBOKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIGlmKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihOIC0gbSAtIG4gKyBrLCBOLCBOIC0gbSwgTiAtIG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYobiAtIGssIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZihuICogMiA+IE4pIHtcbiAgICAgIC8vIEhhbGYgb3IgbGVzcyBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihtIC0gaywgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKGssIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgcHJvZHVjdCB0byBrZWVwIGl0IGluIGEgbnVtZXJpY2FsbHkgZ29vZCByZWdpb24sIGFuZCB0aGVuXG4gICAgICAvLyBmaW5pc2ggdGhlIG5vcm1hbGl6YXRpb24gYXQgdGhlIGVuZC5cblxuICAgICAgLy8gVGhpcyB2YXJpYWJsZSBob2xkcyB0aGUgc2NhbGVkIHByb2JhYmlsaXR5IG9mIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgLy8gc3VjY2Vzc2VzLlxuICAgICAgdmFyIHNjYWxlZFBERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAvLyBGb3IgZXZlcnkgcG9zc2libGUgbnVtYmVyIG9mIHN1Y2Nlc3NlcyB1cCB0byB0aGF0IG9ic2VydmVkLi4uXG5cbiAgICAgICAgd2hpbGUoc2NhbGVkUERGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuXG4gICAgICAgICAgc2NhbGVkUERGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcblxuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcbiAgICAgIH1cblxuICAgICAgZm9yKDsgc2FtcGxlc0RvbmUgPCBuOyBzYW1wbGVzRG9uZSsrKSB7XG4gICAgICAgIC8vIEFwcGx5IGFsbCB0aGUgcmVzdCBvZiB0aGUgbm9ybWFsaXphdGlvblxuICAgICAgICBzY2FsZWRQREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb3VuZCBhbnN3ZXIgc2FuZWx5IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgc2NhbGVkUERGKSk7XG4gICAgfVxuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBDREYuXG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBpcyBkdWUgdG8gUHJvZi4gVGhvbWFzIFMuIEZlcmd1c29uLCA8dG9tQG1hdGgudWNsYS5lZHU+LFxuICAgIC8vIGFuZCBjb21lcyBmcm9tIGhpcyBoeXBlcmdlb21ldHJpYyB0ZXN0IGNhbGN1bGF0b3IgYXRcbiAgICAvLyA8aHR0cDovL3d3dy5tYXRoLnVjbGEuZWR1L350b20vZGlzdHJpYnV0aW9ucy9IeXBlcmdlb21ldHJpYy5odG1sPi5cblxuICAgIC8vIHggPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGRyYXduXG4gICAgLy8gTiA9IHBvcHVsYXRpb24gc2l6ZVxuICAgIC8vIG0gPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIHBvcHVsYXRpb25cbiAgICAvLyBuID0gbnVtYmVyIG9mIGl0ZW1zIGRyYXduIGZyb20gcG9wdWxhdGlvblxuXG4gICAgaWYoeCA8IDAgfHwgeCA8IG0gLSAoTiAtIG4pKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIGZldyBzdWNjZXNzZXMgZHJhd24gb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYoeCA+PSBuIHx8IHggPj0gbSkge1xuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgaGF2ZSB0aGlzIG1hbnkgc3VjY2Vzc2VzIG9yIGZld2VyLlxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtICogMiA+IE4pIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgaWYobiAqIDIgPiBOKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKE4gLSBtIC0gbiArIHgsIE4sIE4gLSBtLCBOIC0gbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiAxIC0galN0YXQuaHlwZ2VvbS5jZGYobiAtIHggLSAxLCBOLCBOIC0gbSwgbik7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYobiAqIDIgPiBOKSB7XG4gICAgICAvLyBIYWxmIG9yIGxlc3MgaXMgc3VjY2Vzc2VzLlxuXG4gICAgICByZXR1cm4gMSAtIGpTdGF0Lmh5cGdlb20uY2RmKG0gLSB4IC0gMSwgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKHgsIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgc3VtIHRvIGtlZXAgaXQgaW4gYSBudW1lcmljYWxseSBnb29kIHJlZ2lvbiwgYW5kIHRoZW5cbiAgICAgIC8vIGZpbmlzaCB0aGUgbm9ybWFsaXphdGlvbiBhdCB0aGUgZW5kLlxuXG4gICAgICAvLyBIb2xkcyB0aGUgaW50ZXJtZWRpYXRlLCBzY2FsZWQgdG90YWwgQ0RGLlxuICAgICAgdmFyIHNjYWxlZENERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgdGhlIHNjYWxlZCBwcm9iYWJpbGl0eSBvZiB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgIC8vIHN1Y2Nlc3Nlcy5cbiAgICAgIHZhciBzY2FsZWRQREYgPSAxO1xuXG4gICAgICAvLyBUaGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtdWNoIHdlIGhhdmUgbm9ybWFsaXplZC5cbiAgICAgIHZhciBzYW1wbGVzRG9uZSA9IDA7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4OyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGV2ZXJ5IHBvc3NpYmxlIG51bWJlciBvZiBzdWNjZXNzZXMgdXAgdG8gdGhhdCBvYnNlcnZlZC4uLlxuXG4gICAgICAgIHdoaWxlKHNjYWxlZENERiA+IDEgJiYgc2FtcGxlc0RvbmUgPCBuKSB7XG4gICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHJlc3VsdCBpcyBncm93aW5nIHRvbyBiaWcuIEFwcGx5IHNvbWUgb2YgdGhlXG4gICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB0byBzaHJpbmsgZXZlcnl0aGluZy5cblxuICAgICAgICAgIHZhciBmYWN0b3IgPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG5cbiAgICAgICAgICBzY2FsZWRQREYgKj0gZmFjdG9yO1xuICAgICAgICAgIHNjYWxlZENERiAqPSBmYWN0b3I7XG5cbiAgICAgICAgICAvLyBTYXkgd2UndmUgbm9ybWFsaXplZCBieSB0aGlzIHNhbXBsZSBhbHJlYWR5LlxuICAgICAgICAgIHNhbXBsZXNEb25lKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgcGFydGlhbGx5LW5vcm1hbGl6ZWQgaHlwZXJnZW9tZXRyaWMgUERGIGZvciB0aGUgbmV4dFxuICAgICAgICAvLyBudW1iZXIgb2Ygc3VjY2Vzc2VzXG4gICAgICAgIHNjYWxlZFBERiAqPSAobiAtIGkpICogKG0gLSBpKSAvICgoaSArIDEpICogKE4gLSBtIC0gbiArIGkgKyAxKSk7XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSBDREYgYW5zd2VyLlxuICAgICAgICBzY2FsZWRDREYgKz0gc2NhbGVkUERGO1xuICAgICAgfVxuXG4gICAgICBmb3IoOyBzYW1wbGVzRG9uZSA8IG47IHNhbXBsZXNEb25lKyspIHtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHRoZSByZXN0IG9mIHRoZSBub3JtYWxpemF0aW9uXG4gICAgICAgIHNjYWxlZENERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRDREYpKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnBvaXNzb24sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgbCkge1xuICAgIGlmIChsIDwgMCB8fCAoayAlIDEpICE9PSAwIHx8IGsgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5wb3cobCwgaykgKiBNYXRoLmV4cCgtbCkgLyBqU3RhdC5mYWN0b3JpYWwoayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbCkge1xuICAgIHZhciBzdW1hcnIgPSBbXSxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHJldHVybiAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtYXJyLnB1c2goalN0YXQucG9pc3Nvbi5wZGYoaywgbCkpO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQuc3VtKHN1bWFycik7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICBzYW1wbGVTbWFsbDogZnVuY3Rpb24gc2FtcGxlU21hbGwobCkge1xuICAgIHZhciBwID0gMSwgayA9IDAsIEwgPSBNYXRoLmV4cCgtbCk7XG4gICAgZG8ge1xuICAgICAgaysrO1xuICAgICAgcCAqPSBqU3RhdC5fcmFuZG9tX2ZuKCk7XG4gICAgfSB3aGlsZSAocCA+IEwpO1xuICAgIHJldHVybiBrIC0gMTtcbiAgfSxcblxuICBzYW1wbGVMYXJnZTogZnVuY3Rpb24gc2FtcGxlTGFyZ2UobCkge1xuICAgIHZhciBsYW0gPSBsO1xuICAgIHZhciBrO1xuICAgIHZhciBVLCBWLCBzbGFtLCBsb2dsYW0sIGEsIGIsIGludmFscGhhLCB2ciwgdXM7XG5cbiAgICBzbGFtID0gTWF0aC5zcXJ0KGxhbSk7XG4gICAgbG9nbGFtID0gTWF0aC5sb2cobGFtKTtcbiAgICBiID0gMC45MzEgKyAyLjUzICogc2xhbTtcbiAgICBhID0gLTAuMDU5ICsgMC4wMjQ4MyAqIGI7XG4gICAgaW52YWxwaGEgPSAxLjEyMzkgKyAxLjEzMjggLyAoYiAtIDMuNCk7XG4gICAgdnIgPSAwLjkyNzcgLSAzLjYyMjQgLyAoYiAtIDIpO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIFUgPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgViA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB1cyA9IDAuNSAtIE1hdGguYWJzKFUpO1xuICAgICAgayA9IE1hdGguZmxvb3IoKDIgKiBhIC8gdXMgKyBiKSAqIFUgKyBsYW0gKyAwLjQzKTtcbiAgICAgIGlmICgodXMgPj0gMC4wNykgJiYgKFYgPD0gdnIpKSB7XG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9XG4gICAgICBpZiAoKGsgPCAwKSB8fCAoKHVzIDwgMC4wMTMpICYmIChWID4gdXMpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogbG9nKFYpID09IGxvZygwLjApIG9rIGhlcmUgKi9cbiAgICAgIC8qIGlmIFU9PTAuMCBzbyB0aGF0IHVzPT0wLjAsIGxvZyBpcyBvayBzaW5jZSBhbHdheXMgcmV0dXJucyAqL1xuICAgICAgaWYgKChNYXRoLmxvZyhWKSArIE1hdGgubG9nKGludmFscGhhKSAtIE1hdGgubG9nKGEgLyAodXMgKiB1cykgKyBiKSkgPD0gKC1sYW0gKyBrICogbG9nbGFtIC0galN0YXQubG9nZ2FtKGsgKyAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobCkge1xuICAgIGlmIChsIDwgMTApXG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVTbWFsbChsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVMYXJnZShsKTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCB0cmlhbmd1bGFyIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC50cmlhbmd1bGFyLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeCA8IGEgfHwgeCA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHggPCBjKSB7XG4gICAgICAgICAgcmV0dXJuICgyICogKHggLSBhKSkgLyAoKGIgLSBhKSAqIChjIC0gYSkpO1xuICAgICAgfSBlbHNlIGlmICh4ID09PSBjKSB7XG4gICAgICAgICAgcmV0dXJuICgyIC8gKGIgLSBhKSk7XG4gICAgICB9IGVsc2UgeyAvLyB4ID4gY1xuICAgICAgICAgIHJldHVybiAoMiAqIChiIC0geCkpIC8gKChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYSwgYiwgYykge1xuICAgIGlmIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICByZXR1cm4gTmFOO1xuICAgIGlmICh4IDw9IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4ID49IGIpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAoeCA8PSBjKVxuICAgICAgcmV0dXJuIE1hdGgucG93KHggLSBhLCAyKSAvICgoYiAtIGEpICogKGMgLSBhKSk7XG4gICAgZWxzZSAvLyB4ID4gY1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdyhiIC0geCwgMikgLyAoKGIgLSBhKSAqIChiIC0gYykpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocCA8PSAoKGMgLSBhKSAvIChiIC0gYSkpKSB7XG4gICAgICAgIHJldHVybiBhICsgKGIgLSBhKSAqIE1hdGguc3FydChwICogKChjIC0gYSkgLyAoYiAtIGEpKSk7XG4gICAgICB9IGVsc2UgeyAvLyBwID4gKChjIC0gYSkgLyAoYiAtIGEpKVxuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiAoMSAtIE1hdGguc3FydCgoMSAtIHApICogKDEgLSAoKGMgLSBhKSAvIChiIC0gYSkpKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgKyBiICsgYykgLyAzO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIsIGMpIHtcbiAgICBpZiAoYyA8PSAoYSArIGIpIC8gMikge1xuICAgICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKGIgLSBhKSAqIChiIC0gYykpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH0gZWxzZSBpZiAoYyA+IChhICsgYikgLyAyKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCgoYiAtIGEpICogKGMgLSBhKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfVxuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYSwgYiwgYykge1xuICAgIHJldHVybiBjO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGEsIGIsIGMpIHtcbiAgICB2YXIgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgICBpZiAodSA8ICgoYyAtIGEpIC8gKGIgLSBhKSkpXG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCh1ICogKGIgLSBhKSAqIChjIC0gYSkpXG4gICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKDEgLSB1KSAqIChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAqIGEgKyBiICogYiArIGMgKiBjIC0gYSAqIGIgLSBhICogYyAtIGIgKiBjKSAvIDE4O1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgYXJjc2luZSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYXJjc2luZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhLCBiKSB7XG4gICAgaWYgKGIgPD0gYSkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiAoeCA8PSBhIHx8IHggPj0gYikgPyAwIDpcbiAgICAgICgyIC8gTWF0aC5QSSkgKlxuICAgICAgICBNYXRoLnBvdyhNYXRoLnBvdyhiIC0gYSwgMikgLVxuICAgICAgICAgICAgICAgICAgTWF0aC5wb3coMiAqIHggLSBhIC0gYiwgMiksIC0wLjUpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGEsIGIpIHtcbiAgICBpZiAoeCA8IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4IDwgYilcbiAgICAgIHJldHVybiAoMiAvIE1hdGguUEkpICogTWF0aC5hc2luKE1hdGguc3FydCgoeCAtIGEpLyhiIC0gYSkpKTtcbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGEsIGIpIHtcbiAgICByZXR1cm4gYSArICgwLjUgLSAwLjUgKiBNYXRoLmNvcyhNYXRoLlBJICogcCkpICogKGIgLSBhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIpIHtcbiAgICBpZiAoYiA8PSBhKSByZXR1cm4gTmFOO1xuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiKSB7XG4gICAgaWYgKGIgPD0gYSkgcmV0dXJuIE5hTjtcbiAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZSgvKmEsIGIqLykge1xuICAgIHRocm93IG5ldyBFcnJvcignbW9kZSBpcyBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYSwgYikge1xuICAgIHJldHVybiAoKGEgKyBiKSAvIDIpICsgKChiIC0gYSkgLyAyKSAqXG4gICAgICBNYXRoLnNpbigyICogTWF0aC5QSSAqIGpTdGF0LnVuaWZvcm0uc2FtcGxlKDAsIDEpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYikge1xuICAgIGlmIChiIDw9IGEpIHJldHVybiBOYU47XG4gICAgcmV0dXJuIE1hdGgucG93KGIgLSBhLCAyKSAvIDg7XG4gIH1cbn0pO1xuXG5cbmZ1bmN0aW9uIGxhcGxhY2VTaWduKHgpIHsgcmV0dXJuIHggLyBNYXRoLmFicyh4KTsgfVxuXG5qU3RhdC5leHRlbmQoalN0YXQubGFwbGFjZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBtdSwgYikge1xuICAgIHJldHVybiAoYiA8PSAwKSA/IDAgOiAoTWF0aC5leHAoLU1hdGguYWJzKHggLSBtdSkgLyBiKSkgLyAoMiAqIGIpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG11LCBiKSB7XG4gICAgaWYgKGIgPD0gMCkgeyByZXR1cm4gMDsgfVxuXG4gICAgaWYoeCA8IG11KSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5leHAoKHggLSBtdSkgLyBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDEgLSAwLjUgKiBNYXRoLmV4cCgtICh4IC0gbXUpIC8gYik7XG4gICAgfVxuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uKG11LyosIGIqLykge1xuICAgIHJldHVybiBtdTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uKG11LyosIGIqLykge1xuICAgIHJldHVybiBtdTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbihtdS8qLCBiKi8pIHtcbiAgICByZXR1cm4gbXU7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uKG11LCBiKSB7XG4gICAgcmV0dXJuIDIgKiBiICogYjtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtdSwgYikge1xuICAgIHZhciB1ID0galN0YXQuX3JhbmRvbV9mbigpIC0gMC41O1xuXG4gICAgcmV0dXJuIG11IC0gKGIgKiBsYXBsYWNlU2lnbih1KSAqIE1hdGgubG9nKDEgLSAoMiAqIE1hdGguYWJzKHUpKSkpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHVrZXlXcHJvYih3LCByciwgY2MpIHtcbiAgdmFyIG5sZWcgPSAxMjtcbiAgdmFyIGloYWxmID0gNjtcblxuICB2YXIgQzEgPSAtMzA7XG4gIHZhciBDMiA9IC01MDtcbiAgdmFyIEMzID0gNjA7XG4gIHZhciBiYiAgID0gODtcbiAgdmFyIHdsYXIgPSAzO1xuICB2YXIgd2luY3IxID0gMjtcbiAgdmFyIHdpbmNyMiA9IDM7XG4gIHZhciB4bGVnID0gW1xuICAgIDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MDkwMTQ5LFxuICAgIDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1ODY2MTE5LFxuICAgIDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzODMzMjEzLFxuICAgIDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNDE4OTQxLFxuICAgIDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNTM2NjQ0LFxuICAgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxMzY5NDY0XG4gIF07XG4gIHZhciBhbGVnID0gW1xuICAgIDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE1OTYxNDg1LFxuICAgIDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NzE4MTk0LFxuICAgIDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNTI5NTQzLFxuICAgIDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NDU1ODEwLFxuICAgIDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5ODk4OTI1LFxuICAgIDAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNDM2MDQzXG4gIF07XG5cbiAgdmFyIHFzcXogPSB3ICogMC41O1xuXG4gIC8vIGlmIHcgPj0gMTYgdGhlbiB0aGUgaW50ZWdyYWwgbG93ZXIgYm91bmQgKG9jY3VycyBmb3IgYz0yMClcbiAgLy8gaXMgMC45OTk5OTk5OTk5OTk5NSBzbyByZXR1cm4gYSB2YWx1ZSBvZiAxLlxuXG4gIGlmIChxc3F6ID49IGJiKVxuICAgIHJldHVybiAxLjA7XG5cbiAgLy8gZmluZCAoZih3LzIpIC0gMSkgXiBjY1xuICAvLyAoZmlyc3QgdGVybSBpbiBpbnRlZ3JhbCBvZiBoYXJ0bGV5J3MgZm9ybSkuXG5cbiAgdmFyIHByX3cgPSAyICogalN0YXQubm9ybWFsLmNkZihxc3F6LCAwLCAxLCAxLCAwKSAtIDE7IC8vIGVyZihxc3F6IC8gTV9TUVJUMilcbiAgLy8gaWYgcHJfdyBeIGNjIDwgMmUtMjIgdGhlbiBzZXQgcHJfdyA9IDBcbiAgaWYgKHByX3cgPj0gTWF0aC5leHAoQzIgLyBjYykpXG4gICAgcHJfdyA9IE1hdGgucG93KHByX3csIGNjKTtcbiAgZWxzZVxuICAgIHByX3cgPSAwLjA7XG5cbiAgLy8gaWYgdyBpcyBsYXJnZSB0aGVuIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIHRoZVxuICAvLyBpbnRlZ3JhbCBpcyBzbWFsbCwgc28gZmV3ZXIgaW50ZXJ2YWxzIGFyZSBuZWVkZWQuXG5cbiAgdmFyIHdpbmNyO1xuICBpZiAodyA+IHdsYXIpXG4gICAgd2luY3IgPSB3aW5jcjE7XG4gIGVsc2VcbiAgICB3aW5jciA9IHdpbmNyMjtcblxuICAvLyBmaW5kIHRoZSBpbnRlZ3JhbCBvZiBzZWNvbmQgdGVybSBvZiBoYXJ0bGV5J3MgZm9ybVxuICAvLyBmb3IgdGhlIGludGVncmFsIG9mIHRoZSByYW5nZSBmb3IgZXF1YWwtbGVuZ3RoXG4gIC8vIGludGVydmFscyB1c2luZyBsZWdlbmRyZSBxdWFkcmF0dXJlLiAgbGltaXRzIG9mXG4gIC8vIGludGVncmF0aW9uIGFyZSBmcm9tICh3LzIsIDgpLiAgdHdvIG9yIHRocmVlXG4gIC8vIGVxdWFsLWxlbmd0aCBpbnRlcnZhbHMgYXJlIHVzZWQuXG5cbiAgLy8gYmxiIGFuZCBidWIgYXJlIGxvd2VyIGFuZCB1cHBlciBsaW1pdHMgb2YgaW50ZWdyYXRpb24uXG5cbiAgdmFyIGJsYiA9IHFzcXo7XG4gIHZhciBiaW5jID0gKGJiIC0gcXNxeikgLyB3aW5jcjtcbiAgdmFyIGJ1YiA9IGJsYiArIGJpbmM7XG4gIHZhciBlaW5zdW0gPSAwLjA7XG5cbiAgLy8gaW50ZWdyYXRlIG92ZXIgZWFjaCBpbnRlcnZhbFxuXG4gIHZhciBjYzEgPSBjYyAtIDEuMDtcbiAgZm9yICh2YXIgd2kgPSAxOyB3aSA8PSB3aW5jcjsgd2krKykge1xuICAgIHZhciBlbHN1bSA9IDAuMDtcbiAgICB2YXIgYSA9IDAuNSAqIChidWIgKyBibGIpO1xuXG4gICAgLy8gbGVnZW5kcmUgcXVhZHJhdHVyZSB3aXRoIG9yZGVyID0gbmxlZ1xuXG4gICAgdmFyIGIgPSAwLjUgKiAoYnViIC0gYmxiKTtcblxuICAgIGZvciAodmFyIGpqID0gMTsgamogPD0gbmxlZzsgamorKykge1xuICAgICAgdmFyIGosIHh4O1xuICAgICAgaWYgKGloYWxmIDwgamopIHtcbiAgICAgICAgaiA9IChubGVnIC0gamopICsgMTtcbiAgICAgICAgeHggPSB4bGVnW2otMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqID0gamo7XG4gICAgICAgIHh4ID0gLXhsZWdbai0xXTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0gYiAqIHh4O1xuICAgICAgdmFyIGFjID0gYSArIGM7XG5cbiAgICAgIC8vIGlmIGV4cCgtcWV4cG8vMikgPCA5ZS0xNCxcbiAgICAgIC8vIHRoZW4gZG9lc24ndCBjb250cmlidXRlIHRvIGludGVncmFsXG5cbiAgICAgIHZhciBxZXhwbyA9IGFjICogYWM7XG4gICAgICBpZiAocWV4cG8gPiBDMylcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIHZhciBwcGx1cyA9IDIgKiBqU3RhdC5ub3JtYWwuY2RmKGFjLCAwLCAxLCAxLCAwKTtcbiAgICAgIHZhciBwbWludXM9IDIgKiBqU3RhdC5ub3JtYWwuY2RmKGFjLCB3LCAxLCAxLCAwKTtcblxuICAgICAgLy8gaWYgcmluc3VtIF4gKGNjLTEpIDwgOWUtMTQsXG4gICAgICAvLyB0aGVuIGRvZXNuJ3QgY29udHJpYnV0ZSB0byBpbnRlZ3JhbFxuXG4gICAgICB2YXIgcmluc3VtID0gKHBwbHVzICogMC41KSAtIChwbWludXMgKiAwLjUpO1xuICAgICAgaWYgKHJpbnN1bSA+PSBNYXRoLmV4cChDMSAvIGNjMSkpIHtcbiAgICAgICAgcmluc3VtID0gKGFsZWdbai0xXSAqIE1hdGguZXhwKC0oMC41ICogcWV4cG8pKSkgKiBNYXRoLnBvdyhyaW5zdW0sIGNjMSk7XG4gICAgICAgIGVsc3VtICs9IHJpbnN1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzdW0gKj0gKCgoMi4wICogYikgKiBjYykgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkpKTtcbiAgICBlaW5zdW0gKz0gZWxzdW07XG4gICAgYmxiID0gYnViO1xuICAgIGJ1YiArPSBiaW5jO1xuICB9XG5cbiAgLy8gaWYgcHJfdyBeIHJyIDwgOWUtMTQsIHRoZW4gcmV0dXJuIDBcbiAgcHJfdyArPSBlaW5zdW07XG4gIGlmIChwcl93IDw9IE1hdGguZXhwKEMxIC8gcnIpKVxuICAgIHJldHVybiAwO1xuXG4gIHByX3cgPSBNYXRoLnBvdyhwcl93LCBycik7XG4gIGlmIChwcl93ID49IDEpIC8vIDEgd2FzIGlNYXggd2FzIGVwc1xuICAgIHJldHVybiAxO1xuICByZXR1cm4gcHJfdztcbn1cblxuZnVuY3Rpb24gdHVrZXlRaW52KHAsIGMsIHYpIHtcbiAgdmFyIHAwID0gMC4zMjIyMzI0MjEwODg7XG4gIHZhciBxMCA9IDAuOTkzNDg0NjI2MDYwZS0wMTtcbiAgdmFyIHAxID0gLTEuMDtcbiAgdmFyIHExID0gMC41ODg1ODE1NzA0OTU7XG4gIHZhciBwMiA9IC0wLjM0MjI0MjA4ODU0NztcbiAgdmFyIHEyID0gMC41MzExMDM0NjIzNjY7XG4gIHZhciBwMyA9IC0wLjIwNDIzMTIxMDEyNTtcbiAgdmFyIHEzID0gMC4xMDM1Mzc3NTI4NTA7XG4gIHZhciBwNCA9IC0wLjQ1MzY0MjIxMDE0OGUtMDQ7XG4gIHZhciBxNCA9IDAuMzg1NjA3MDA2MzRlLTAyO1xuICB2YXIgYzEgPSAwLjg4MzI7XG4gIHZhciBjMiA9IDAuMjM2ODtcbiAgdmFyIGMzID0gMS4yMTQ7XG4gIHZhciBjNCA9IDEuMjA4O1xuICB2YXIgYzUgPSAxLjQxNDI7XG4gIHZhciB2bWF4ID0gMTIwLjA7XG5cbiAgdmFyIHBzID0gMC41IC0gMC41ICogcDtcbiAgdmFyIHlpID0gTWF0aC5zcXJ0KE1hdGgubG9nKDEuMCAvIChwcyAqIHBzKSkpO1xuICB2YXIgdCA9IHlpICsgKCgoKCB5aSAqIHA0ICsgcDMpICogeWkgKyBwMikgKiB5aSArIHAxKSAqIHlpICsgcDApXG4gICAgIC8gKCgoKCB5aSAqIHE0ICsgcTMpICogeWkgKyBxMikgKiB5aSArIHExKSAqIHlpICsgcTApO1xuICBpZiAodiA8IHZtYXgpIHQgKz0gKHQgKiB0ICogdCArIHQpIC8gdiAvIDQuMDtcbiAgdmFyIHEgPSBjMSAtIGMyICogdDtcbiAgaWYgKHYgPCB2bWF4KSBxICs9IC1jMyAvIHYgKyBjNCAqIHQgLyB2O1xuICByZXR1cm4gdCAqIChxICogTWF0aC5sb2coYyAtIDEuMCkgKyBjNSk7XG59XG5cbmpTdGF0LmV4dGVuZChqU3RhdC50dWtleSwge1xuICBjZGY6IGZ1bmN0aW9uIGNkZihxLCBubWVhbnMsIGRmKSB7XG4gICAgLy8gSWRlbnRpY2FsIGltcGxlbWVudGF0aW9uIGFzIHRoZSBSIHB0dWtleSgpIGZ1bmN0aW9uIGFzIG9mIGNvbW1pdCA2ODk0N1xuICAgIHZhciByciA9IDE7XG4gICAgdmFyIGNjID0gbm1lYW5zO1xuXG4gICAgdmFyIG5sZWdxID0gMTY7XG4gICAgdmFyIGloYWxmcSA9IDg7XG5cbiAgICB2YXIgZXBzMSA9IC0zMC4wO1xuICAgIHZhciBlcHMyID0gMS4wZS0xNDtcbiAgICB2YXIgZGhhZiAgPSAxMDAuMDtcbiAgICB2YXIgZHF1YXIgPSA4MDAuMDtcbiAgICB2YXIgZGVpZ2ggPSA1MDAwLjA7XG4gICAgdmFyIGRsYXJnID0gMjUwMDAuMDtcbiAgICB2YXIgdWxlbjEgPSAxLjA7XG4gICAgdmFyIHVsZW4yID0gMC41O1xuICAgIHZhciB1bGVuMyA9IDAuMjU7XG4gICAgdmFyIHVsZW40ID0gMC4xMjU7XG4gICAgdmFyIHhsZWdxID0gW1xuICAgICAgMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQxNzM0NTAsXG4gICAgICAwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQxNTUzNSxcbiAgICAgIDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3ODk3NzEyLFxuICAgICAgMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDExOTQ4NDcsXG4gICAgICAwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTc2NDA0OSxcbiAgICAgIDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NDQyOTg0LFxuICAgICAgMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1MDE0NjAsXG4gICAgICAwLjk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MzM1NDI1MGUtMVxuICAgIF07XG4gICAgdmFyIGFsZWdxID0gW1xuICAgICAgMC4yNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDU3MjQ1NjBlLTEsXG4gICAgICAwLjYyMjUzNTIzOTM4NjQ3ODkyODYyODQzODM2OTk0NGUtMSxcbiAgICAgIDAuOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxMDc2MDIyZS0xLFxuICAgICAgMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYyODIxOTIsXG4gICAgICAwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTczMDU0NyxcbiAgICAgIDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMDc5MDMwLFxuICAgICAgMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM2Njc5NjksXG4gICAgICAwLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcyMzIwOFxuICAgIF07XG5cbiAgICBpZiAocSA8PSAwKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICAvLyBkZiBtdXN0IGJlID4gMVxuICAgIC8vIHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgdHdvIHZhbHVlc1xuXG4gICAgaWYgKGRmIDwgMiB8fCByciA8IDEgfHwgY2MgPCAyKSByZXR1cm4gTmFOO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocSkpXG4gICAgICByZXR1cm4gMTtcblxuICAgIGlmIChkZiA+IGRsYXJnKVxuICAgICAgcmV0dXJuIHR1a2V5V3Byb2IocSwgcnIsIGNjKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBsZWFkaW5nIGNvbnN0YW50XG5cbiAgICB2YXIgZjIgPSBkZiAqIDAuNTtcbiAgICB2YXIgZjJsZiA9ICgoZjIgKiBNYXRoLmxvZyhkZikpIC0gKGRmICogTWF0aC5sb2coMikpKSAtIGpTdGF0LmdhbW1hbG4oZjIpO1xuICAgIHZhciBmMjEgPSBmMiAtIDEuMDtcblxuICAgIC8vIGludGVncmFsIGlzIGRpdmlkZWQgaW50byB1bml0LCBoYWxmLXVuaXQsIHF1YXJ0ZXItdW5pdCwgb3JcbiAgICAvLyBlaWdodGgtdW5pdCBsZW5ndGggaW50ZXJ2YWxzIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgLy8gZGVncmVlcyBvZiBmcmVlZG9tLlxuXG4gICAgdmFyIGZmNCA9IGRmICogMC4yNTtcbiAgICB2YXIgdWxlbjtcbiAgICBpZiAgICAgIChkZiA8PSBkaGFmKSAgdWxlbiA9IHVsZW4xO1xuICAgIGVsc2UgaWYgKGRmIDw9IGRxdWFyKSB1bGVuID0gdWxlbjI7XG4gICAgZWxzZSBpZiAoZGYgPD0gZGVpZ2gpIHVsZW4gPSB1bGVuMztcbiAgICBlbHNlICAgICAgICAgICAgICAgICAgdWxlbiA9IHVsZW40O1xuXG4gICAgZjJsZiArPSBNYXRoLmxvZyh1bGVuKTtcblxuICAgIC8vIGludGVncmF0ZSBvdmVyIGVhY2ggc3ViaW50ZXJ2YWxcblxuICAgIHZhciBhbnMgPSAwLjA7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSA1MDsgaSsrKSB7XG4gICAgICB2YXIgb3RzdW0gPSAwLjA7XG5cbiAgICAgIC8vIGxlZ2VuZHJlIHF1YWRyYXR1cmUgd2l0aCBvcmRlciA9IG5sZWdxXG4gICAgICAvLyBub2RlcyAoc3RvcmVkIGluIHhsZWdxKSBhcmUgc3ltbWV0cmljIGFyb3VuZCB6ZXJvLlxuXG4gICAgICB2YXIgdHdhMSA9ICgyICogaSAtIDEpICogdWxlbjtcblxuICAgICAgZm9yICh2YXIgamogPSAxOyBqaiA8PSBubGVncTsgamorKykge1xuICAgICAgICB2YXIgaiwgdDE7XG4gICAgICAgIGlmIChpaGFsZnEgPCBqaikge1xuICAgICAgICAgIGogPSBqaiAtIGloYWxmcSAtIDE7XG4gICAgICAgICAgdDEgPSAoZjJsZiArIChmMjEgKiBNYXRoLmxvZyh0d2ExICsgKHhsZWdxW2pdICogdWxlbikpKSlcbiAgICAgICAgICAgICAgLSAoKCh4bGVncVtqXSAqIHVsZW4pICsgdHdhMSkgKiBmZjQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGogPSBqaiAtIDE7XG4gICAgICAgICAgdDEgPSAoZjJsZiArIChmMjEgKiBNYXRoLmxvZyh0d2ExIC0gKHhsZWdxW2pdICogdWxlbikpKSlcbiAgICAgICAgICAgICAgKyAoKCh4bGVncVtqXSAqIHVsZW4pIC0gdHdhMSkgKiBmZjQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXhwKHQxKSA8IDllLTE0LCB0aGVuIGRvZXNuJ3QgY29udHJpYnV0ZSB0byBpbnRlZ3JhbFxuICAgICAgICB2YXIgcXNxejtcbiAgICAgICAgaWYgKHQxID49IGVwczEpIHtcbiAgICAgICAgICBpZiAoaWhhbGZxIDwgamopIHtcbiAgICAgICAgICAgIHFzcXogPSBxICogTWF0aC5zcXJ0KCgoeGxlZ3Fbal0gKiB1bGVuKSArIHR3YTEpICogMC41KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXNxeiA9IHEgKiBNYXRoLnNxcnQoKCgtKHhsZWdxW2pdICogdWxlbikpICsgdHdhMSkgKiAwLjUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhbGwgd3Byb2IgdG8gZmluZCBpbnRlZ3JhbCBvZiByYW5nZSBwb3J0aW9uXG5cbiAgICAgICAgICB2YXIgd3ByYiA9IHR1a2V5V3Byb2IocXNxeiwgcnIsIGNjKTtcbiAgICAgICAgICB2YXIgcm90c3VtID0gKHdwcmIgKiBhbGVncVtqXSkgKiBNYXRoLmV4cCh0MSk7XG4gICAgICAgICAgb3RzdW0gKz0gcm90c3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBsZWdlbmRyZSBpbnRlZ3JhbCBmb3IgaW50ZXJ2YWwgaVxuICAgICAgICAvLyBMMjAwOlxuICAgICAgfVxuXG4gICAgICAvLyBpZiBpbnRlZ3JhbCBmb3IgaW50ZXJ2YWwgaSA8IDFlLTE0LCB0aGVuIHN0b3AuXG4gICAgICAvLyBIb3dldmVyLCBpbiBvcmRlciB0byBhdm9pZCBzbWFsbCBhcmVhIHVuZGVyIGxlZnQgdGFpbCxcbiAgICAgIC8vIGF0IGxlYXN0ICAxIC8gdWxlbiAgaW50ZXJ2YWxzIGFyZSBjYWxjdWxhdGVkLlxuICAgICAgaWYgKGkgKiB1bGVuID49IDEuMCAmJiBvdHN1bSA8PSBlcHMyKVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gZW5kIG9mIGludGVydmFsIGlcbiAgICAgIC8vIEwzMzA6XG5cbiAgICAgIGFucyArPSBvdHN1bTtcbiAgICB9XG5cbiAgICBpZiAob3RzdW0gPiBlcHMyKSB7IC8vIG5vdCBjb252ZXJnZWRcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHVrZXkuY2RmIGZhaWxlZCB0byBjb252ZXJnZScpO1xuICAgIH1cbiAgICBpZiAoYW5zID4gMSlcbiAgICAgIGFucyA9IDE7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG5tZWFucywgZGYpIHtcbiAgICAvLyBJZGVudGljYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIFIgcXR1a2V5KCkgZnVuY3Rpb24gYXMgb2YgY29tbWl0IDY4OTQ3XG4gICAgdmFyIHJyID0gMTtcbiAgICB2YXIgY2MgPSBubWVhbnM7XG5cbiAgICB2YXIgZXBzID0gMC4wMDAxO1xuICAgIHZhciBtYXhpdGVyID0gNTA7XG5cbiAgICAvLyBkZiBtdXN0IGJlID4gMSA7IHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgdHdvIHZhbHVlc1xuICAgIGlmIChkZiA8IDIgfHwgcnIgPCAxIHx8IGNjIDwgMikgcmV0dXJuIE5hTjtcblxuICAgIGlmIChwIDwgMCB8fCBwID4gMSkgcmV0dXJuIE5hTjtcbiAgICBpZiAocCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHAgPT09IDEpIHJldHVybiBJbmZpbml0eTtcblxuICAgIC8vIEluaXRpYWwgdmFsdWVcblxuICAgIHZhciB4MCA9IHR1a2V5UWludihwLCBjYywgZGYpO1xuXG4gICAgLy8gRmluZCBwcm9iKHZhbHVlIDwgeDApXG5cbiAgICB2YXIgdmFseDAgPSBqU3RhdC50dWtleS5jZGYoeDAsIG5tZWFucywgZGYpIC0gcDtcblxuICAgIC8vIEZpbmQgdGhlIHNlY29uZCBpdGVyYXRlIGFuZCBwcm9iKHZhbHVlIDwgeDEpLlxuICAgIC8vIElmIHRoZSBmaXJzdCBpdGVyYXRlIGhhcyBwcm9iYWJpbGl0eSB2YWx1ZVxuICAgIC8vIGV4Y2VlZGluZyBwIHRoZW4gc2Vjb25kIGl0ZXJhdGUgaXMgMSBsZXNzIHRoYW5cbiAgICAvLyBmaXJzdCBpdGVyYXRlOyBvdGhlcndpc2UgaXQgaXMgMSBncmVhdGVyLlxuXG4gICAgdmFyIHgxO1xuICAgIGlmICh2YWx4MCA+IDAuMClcbiAgICAgIHgxID0gTWF0aC5tYXgoMC4wLCB4MCAtIDEuMCk7XG4gICAgZWxzZVxuICAgICAgeDEgPSB4MCArIDEuMDtcbiAgICB2YXIgdmFseDEgPSBqU3RhdC50dWtleS5jZGYoeDEsIG5tZWFucywgZGYpIC0gcDtcblxuICAgIC8vIEZpbmQgbmV3IGl0ZXJhdGVcblxuICAgIHZhciBhbnM7XG4gICAgZm9yKHZhciBpdGVyID0gMTsgaXRlciA8IG1heGl0ZXI7IGl0ZXIrKykge1xuICAgICAgYW5zID0geDEgLSAoKHZhbHgxICogKHgxIC0geDApKSAvICh2YWx4MSAtIHZhbHgwKSk7XG4gICAgICB2YWx4MCA9IHZhbHgxO1xuXG4gICAgICAvLyBOZXcgaXRlcmF0ZSBtdXN0IGJlID49IDBcblxuICAgICAgeDAgPSB4MTtcbiAgICAgIGlmIChhbnMgPCAwLjApIHtcbiAgICAgICAgYW5zID0gMC4wO1xuICAgICAgICB2YWx4MSA9IC1wO1xuICAgICAgfVxuICAgICAgLy8gRmluZCBwcm9iKHZhbHVlIDwgbmV3IGl0ZXJhdGUpXG5cbiAgICAgIHZhbHgxID0galN0YXQudHVrZXkuY2RmKGFucywgbm1lYW5zLCBkZikgLSBwO1xuICAgICAgeDEgPSBhbnM7XG5cbiAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHN1Y2Nlc3NpdmVcbiAgICAgIC8vIGl0ZXJhdGVzIGlzIGxlc3MgdGhhbiBlcHMsIHN0b3BcblxuICAgICAgdmFyIHhhYnMgPSBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICAgIGlmICh4YWJzIDwgZXBzKVxuICAgICAgICByZXR1cm4gYW5zO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndHVrZXkuaW52IGZhaWxlZCB0byBjb252ZXJnZScpO1xuICB9XG59KTtcblxufShqU3RhdCwgTWF0aCkpO1xuLyogUHJvdmlkZXMgZnVuY3Rpb25zIGZvciB0aGUgc29sdXRpb24gb2YgbGluZWFyIHN5c3RlbSBvZiBlcXVhdGlvbnMsIGludGVncmF0aW9uLCBleHRyYXBvbGF0aW9uLFxuICogaW50ZXJwb2xhdGlvbiwgZWlnZW52YWx1ZSBwcm9ibGVtcywgZGlmZmVyZW50aWFsIGVxdWF0aW9ucyBhbmQgUENBIGFuYWx5c2lzLiAqL1xuXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBpc0FycmF5ID0galN0YXQudXRpbHMuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNVc2FibGUoYXJnKSB7XG4gIHJldHVybiBpc0FycmF5KGFyZykgfHwgYXJnIGluc3RhbmNlb2YgalN0YXQ7XG59XG5cbmpTdGF0LmV4dGVuZCh7XG5cbiAgLy8gYWRkIGEgdmVjdG9yL21hdHJpeCB0byBhIHZlY3Rvci9tYXRyaXggb3Igc2NhbGFyXG4gIGFkZDogZnVuY3Rpb24gYWRkKGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc1VzYWJsZShhcmcpKSB7XG4gICAgICBpZiAoIWlzVXNhYmxlKGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUsIHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGFyZ1tyb3ddW2NvbF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gc3VidHJhY3QgYSB2ZWN0b3Igb3Igc2NhbGFyIGZyb20gdGhlIHZlY3RvclxuICBzdWJ0cmFjdDogZnVuY3Rpb24gc3VidHJhY3QoYXJyLCBhcmcpIHtcbiAgICAvLyBjaGVjayBpZiBhcmcgaXMgYSB2ZWN0b3Igb3Igc2NhbGFyXG4gICAgaWYgKGlzVXNhYmxlKGFyZykpIHtcbiAgICAgIGlmICghaXNVc2FibGUoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gYXJnW3Jvd11bY29sXSB8fCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLSBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBkaXZpc2lvblxuICBkaXZpZGU6IGZ1bmN0aW9uIGRpdmlkZShhcnIsIGFyZykge1xuICAgIGlmIChpc1VzYWJsZShhcmcpKSB7XG4gICAgICBpZiAoIWlzVXNhYmxlKGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubXVsdGlwbHkoYXJyLCBqU3RhdC5pbnYoYXJnKSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkoYXJyLCBhcmcpIHtcbiAgICB2YXIgcm93LCBjb2wsIG5yZXNjb2xzLCBzdW0sIG5yb3csIG5jb2wsIHJlcywgcmVzY29scztcbiAgICAvLyBlZzogYXJyID0gMiBhcmcgPSAzIC0+IDYgZm9yIHJlc1swXVswXSBzdGF0ZW1lbnQgY2xvc3VyZVxuICAgIGlmIChhcnIubGVuZ3RoID09PSB1bmRlZmluZWQgJiYgYXJnLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXJyICogYXJnO1xuICAgIH1cbiAgICBucm93ID0gYXJyLmxlbmd0aCxcbiAgICBuY29sID0gYXJyWzBdLmxlbmd0aCxcbiAgICByZXMgPSBqU3RhdC56ZXJvcyhucm93LCBucmVzY29scyA9IChpc1VzYWJsZShhcmcpKSA/IGFyZ1swXS5sZW5ndGggOiBuY29sKSxcbiAgICByZXNjb2xzID0gMDtcbiAgICBpZiAoaXNVc2FibGUoYXJnKSkge1xuICAgICAgZm9yICg7IHJlc2NvbHMgPCBucmVzY29sczsgcmVzY29scysrKSB7XG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICAgICAgc3VtICs9IGFycltyb3ddW2NvbF0gKiBhcmdbY29sXVtyZXNjb2xzXTtcbiAgICAgICAgICByZXNbcm93XVtyZXNjb2xzXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChucm93ID09PSAxICYmIHJlc2NvbHMgPT09IDEpID8gcmVzWzBdWzBdIDogcmVzO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlICogYXJnOyB9KTtcbiAgfSxcblxuICAvLyBvdXRlcihbMSwyLDNdLFs0LDUsNl0pXG4gIC8vID09PVxuICAvLyBbWzFdLFsyXSxbM11dIHRpbWVzIFtbNCw1LDZdXVxuICAvLyAtPlxuICAvLyBbWzQsNSw2XSxbOCwxMCwxMl0sWzEyLDE1LDE4XV1cbiAgb3V0ZXI6ZnVuY3Rpb24gb3V0ZXIoQSwgQikge1xuICAgIHJldHVybiBqU3RhdC5tdWx0aXBseShBLm1hcChmdW5jdGlvbih0KXsgcmV0dXJuIFt0XSB9KSwgW0JdKTtcbiAgfSxcblxuXG4gIC8vIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBtYXRyaWNpZXNcbiAgZG90OiBmdW5jdGlvbiBkb3QoYXJyLCBhcmcpIHtcbiAgICBpZiAoIWlzVXNhYmxlKGFyclswXSkpIGFyciA9IFsgYXJyIF07XG4gICAgaWYgKCFpc1VzYWJsZShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgIC8vIGNvbnZlcnQgY29sdW1uIHRvIHJvdyB2ZWN0b3JcbiAgICB2YXIgbGVmdCA9IChhcnJbMF0ubGVuZ3RoID09PSAxICYmIGFyci5sZW5ndGggIT09IDEpID8galN0YXQudHJhbnNwb3NlKGFycikgOiBhcnIsXG4gICAgcmlnaHQgPSAoYXJnWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmcubGVuZ3RoICE9PSAxKSA/IGpTdGF0LnRyYW5zcG9zZShhcmcpIDogYXJnLFxuICAgIHJlcyA9IFtdLFxuICAgIHJvdyA9IDAsXG4gICAgbnJvdyA9IGxlZnQubGVuZ3RoLFxuICAgIG5jb2wgPSBsZWZ0WzBdLmxlbmd0aCxcbiAgICBzdW0sIGNvbDtcbiAgICBmb3IgKDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgIHJlc1tyb3ddID0gW107XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHN1bSArPSBsZWZ0W3Jvd11bY29sXSAqIHJpZ2h0W3Jvd11bY29sXTtcbiAgICAgIHJlc1tyb3ddID0gc3VtO1xuICAgIH1cbiAgICByZXR1cm4gKHJlcy5sZW5ndGggPT09IDEpID8gcmVzWzBdIDogcmVzO1xuICB9LFxuXG4gIC8vIHJhaXNlIGV2ZXJ5IGVsZW1lbnQgYnkgYSBzY2FsYXJcbiAgcG93OiBmdW5jdGlvbiBwb3coYXJyLCBhcmcpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGgucG93KHZhbHVlLCBhcmcpOyB9KTtcbiAgfSxcblxuICAvLyBleHBvbmVudGlhdGUgZXZlcnkgZWxlbWVudFxuICBleHA6IGZ1bmN0aW9uIGV4cChhcnIpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGguZXhwKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgLy8gZ2VuZXJhdGUgdGhlIG5hdHVyYWwgbG9nIG9mIGV2ZXJ5IGVsZW1lbnRcbiAgbG9nOiBmdW5jdGlvbiBleHAoYXJyKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBNYXRoLmxvZyh2YWx1ZSk7IH0pO1xuICB9LFxuXG4gIC8vIGdlbmVyYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgb2YgdGhlIHZlY3RvclxuICBhYnM6IGZ1bmN0aW9uIGFicyhhcnIpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGguYWJzKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgLy8gY29tcHV0ZXMgdGhlIHAtbm9ybSBvZiB0aGUgdmVjdG9yXG4gIC8vIEluIHRoZSBjYXNlIHRoYXQgYSBtYXRyaXggaXMgcGFzc2VkLCB1c2VzIHRoZSBmaXJzdCByb3cgYXMgdGhlIHZlY3RvclxuICBub3JtOiBmdW5jdGlvbiBub3JtKGFyciwgcCkge1xuICAgIHZhciBubm9ybSA9IDAsXG4gICAgaSA9IDA7XG4gICAgLy8gY2hlY2sgdGhlIHAtdmFsdWUgb2YgdGhlIG5vcm0sIGFuZCBzZXQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgICBpZiAoaXNOYU4ocCkpIHAgPSAyO1xuICAgIC8vIGNoZWNrIGlmIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5LCBhbmQgbWFrZSB2ZWN0b3IgY29ycmVjdGlvblxuICAgIGlmIChpc1VzYWJsZShhcnJbMF0pKSBhcnIgPSBhcnJbMF07XG4gICAgLy8gdmVjdG9yIG5vcm1cbiAgICBmb3IgKDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbm5vcm0gKz0gTWF0aC5wb3coTWF0aC5hYnMoYXJyW2ldKSwgcCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnBvdyhubm9ybSwgMSAvIHApO1xuICB9LFxuXG4gIC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZHNcbiAgLy8gSW4gY2FzZSBhIG1hdHJpeCBpcyBwYXNzZWQsIHRoaXMgdXNlcyB0aGUgZmlyc3Qgcm93IGFzIHRoZSB2ZWN0b3JcbiAgYW5nbGU6IGZ1bmN0aW9uIGFuZ2xlKGFyciwgYXJnKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhqU3RhdC5kb3QoYXJyLCBhcmcpIC8gKGpTdGF0Lm5vcm0oYXJyKSAqIGpTdGF0Lm5vcm0oYXJnKSkpO1xuICB9LFxuXG4gIC8vIGF1Z21lbnQgb25lIG1hdHJpeCBieSBhbm90aGVyXG4gIC8vIE5vdGU6IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG1hdHJpeCwgbm90IGEgalN0YXQgb2JqZWN0XG4gIGF1ZzogZnVuY3Rpb24gYXVnKGEsIGIpIHtcbiAgICB2YXIgbmV3YXJyID0gW107XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld2Fyci5wdXNoKGFbaV0uc2xpY2UoKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXdhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2guYXBwbHkobmV3YXJyW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2FycjtcbiAgfSxcblxuICAvLyBUaGUgaW52KCkgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxuICAvLyBDcmVhdGUgdGhlIGludmVyc2UgYnkgYXVnbWVudGluZyB0aGUgbWF0cml4IGJ5IHRoZSBpZGVudGl0eSBtYXRyaXggb2YgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIHNpemUsIGFuZCB0aGVuIHVzZSBHLUogZWxpbWluYXRpb24gb24gdGhlIGF1Z21lbnRlZCBtYXRyaXguXG4gIGludjogZnVuY3Rpb24gaW52KGEpIHtcbiAgICB2YXIgcm93cyA9IGEubGVuZ3RoO1xuICAgIHZhciBjb2xzID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGIgPSBqU3RhdC5pZGVudGl0eShyb3dzLCBjb2xzKTtcbiAgICB2YXIgYyA9IGpTdGF0LmdhdXNzX2pvcmRhbihhLCBiKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqO1xuXG4gICAgLy9XZSBuZWVkIHRvIGNvcHkgdGhlIGludmVyc2UgcG9ydGlvbiB0byBhIG5ldyBtYXRyaXggdG8gcmlkIEctSiBhcnRpZmFjdHNcbiAgICBmb3IgKDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICBmb3IgKGogPSBjb2xzOyBqIDwgY1swXS5sZW5ndGg7IGorKylcbiAgICAgICAgcmVzdWx0W2ldW2ogLSBjb2xzXSA9IGNbaV1bal07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICBkZXQ6IGZ1bmN0aW9uIGRldChhKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gYVswXVswXSAqIGFbMV1bMV0gLSBhWzBdWzFdICogYVsxXVswXTtcbiAgICB9XG5cbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gYnVpbGQgYSBzdWIgbWF0cml4IHdpdGhvdXQgY29sdW1uIGBpYFxuICAgICAgdmFyIHN1Ym1hdHJpeCA9IFtdO1xuICAgICAgZm9yICh2YXIgcm93ID0gMTsgcm93IDwgYS5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgIHN1Ym1hdHJpeFtyb3cgLSAxXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBhLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICBpZiAoY29sIDwgaSkge1xuICAgICAgICAgICAgc3VibWF0cml4W3JvdyAtIDFdW2NvbF0gPSBhW3Jvd11bY29sXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA+IGkpIHtcbiAgICAgICAgICAgIHN1Ym1hdHJpeFtyb3cgLSAxXVtjb2wgLSAxXSA9IGFbcm93XVtjb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhbHRlcm5hdGUgYmV0d2VlbiArIGFuZCAtIGJldHdlZW4gZGV0ZXJtaW5hbnRzXG4gICAgICB2YXIgc2lnbiA9IGkgJSAyID8gLTEgOiAxO1xuICAgICAgZGV0ZXJtaW5hbnQgKz0gZGV0KHN1Ym1hdHJpeCkgKiBhWzBdW2ldICogc2lnbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV0ZXJtaW5hbnRcbiAgfSxcblxuICBnYXVzc19lbGltaW5hdGlvbjogZnVuY3Rpb24gZ2F1c3NfZWxpbWluYXRpb24oYSwgYikge1xuICAgIHZhciBpID0gMCxcbiAgICBqID0gMCxcbiAgICBuID0gYS5sZW5ndGgsXG4gICAgbSA9IGFbMF0ubGVuZ3RoLFxuICAgIGZhY3RvciA9IDEsXG4gICAgc3VtID0gMCxcbiAgICB4ID0gW10sXG4gICAgbWF1ZywgcGl2b3QsIHRlbXAsIGs7XG4gICAgYSA9IGpTdGF0LmF1ZyhhLCBiKTtcbiAgICBtYXVnID0gYVswXS5sZW5ndGg7XG4gICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBwaXZvdCA9IGFbaV1baV07XG4gICAgICBqID0gaTtcbiAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbTsgaysrKSB7XG4gICAgICAgIGlmIChwaXZvdCA8IE1hdGguYWJzKGFba11baV0pKSB7XG4gICAgICAgICAgcGl2b3QgPSBhW2tdW2ldO1xuICAgICAgICAgIGogPSBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiAhPSBpKSB7XG4gICAgICAgIGZvcihrID0gMDsgayA8IG1hdWc7IGsrKykge1xuICAgICAgICAgIHRlbXAgPSBhW2ldW2tdO1xuICAgICAgICAgIGFbaV1ba10gPSBhW2pdW2tdO1xuICAgICAgICAgIGFbal1ba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBmYWN0b3IgPSBhW2pdW2ldIC8gYVtpXVtpXTtcbiAgICAgICAgZm9yKGsgPSBpOyBrIDwgbWF1ZzsgaysrKSB7XG4gICAgICAgICAgYVtqXVtrXSA9IGFbal1ba10gLSBmYWN0b3IgKiBhW2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqPD0gbiAtIDE7IGorKykge1xuICAgICAgICBzdW0gPSBzdW0gKyB4W2pdICogYVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIHhbaV0gPShhW2ldW21hdWcgLSAxXSAtIHN1bSkgLyBhW2ldW2ldO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBnYXVzc19qb3JkYW46IGZ1bmN0aW9uIGdhdXNzX2pvcmRhbihhLCBiKSB7XG4gICAgdmFyIG0gPSBqU3RhdC5hdWcoYSwgYik7XG4gICAgdmFyIGggPSBtLmxlbmd0aDtcbiAgICB2YXIgdyA9IG1bMF0ubGVuZ3RoO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgeCwgeSwgeTI7XG4gICAgLy8gZmluZCBtYXggcGl2b3RcbiAgICBmb3IgKHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgbWF4cm93ID0geTtcbiAgICAgIGZvciAoeTIgPSB5KzE7IHkyIDwgaDsgeTIrKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMobVt5Ml1beV0pID4gTWF0aC5hYnMobVttYXhyb3ddW3ldKSlcbiAgICAgICAgICBtYXhyb3cgPSB5MjtcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBtW3ldO1xuICAgICAgbVt5XSA9IG1bbWF4cm93XTtcbiAgICAgIG1bbWF4cm93XSA9IHRtcFxuICAgICAgZm9yICh5MiA9IHkrMTsgeTIgPCBoOyB5MisrKSB7XG4gICAgICAgIGMgPSBtW3kyXVt5XSAvIG1beV1beV07XG4gICAgICAgIGZvciAoeCA9IHk7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICBtW3kyXVt4XSAtPSBtW3ldW3hdICogYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBiYWNrc3Vic3RpdHV0ZVxuICAgIGZvciAoeSA9IGgtMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGMgPSBtW3ldW3ldO1xuICAgICAgZm9yICh5MiA9IDA7IHkyIDwgeTsgeTIrKykge1xuICAgICAgICBmb3IgKHggPSB3LTE7IHggPiB5LTE7IHgtLSkge1xuICAgICAgICAgIG1beTJdW3hdIC09IG1beV1beF0gKiBtW3kyXVt5XSAvIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1beV1beV0gLz0gYztcbiAgICAgIGZvciAoeCA9IGg7IHggPCB3OyB4KyspIHtcbiAgICAgICAgbVt5XVt4XSAvPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICAvLyBzb2x2ZSBlcXVhdGlvblxuICAvLyBBeD1iXG4gIC8vIEEgaXMgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgLy8gQT1bWzEsMiwzXSxbMCw0LDVdLFswLDYsN11dXG4gIC8vIGI9WzEsMiwzXVxuICAvLyB0cmlhVXBTb2x2ZShBLGIpIC8vIC0+IFsyLjY2NiwwLjE2NjYsMS42NjZdXG4gIC8vIGlmIHlvdSB1c2UgbWF0cml4IHN0eWxlXG4gIC8vIEE9W1sxLDIsM10sWzAsNCw1XSxbMCw2LDddXVxuICAvLyBiPVtbMV0sWzJdLFszXV1cbiAgLy8gd2lsbCByZXR1cm4gW1syLjY2Nl0sWzAuMTY2Nl0sWzEuNjY2XV1cbiAgdHJpYVVwU29sdmU6IGZ1bmN0aW9uIHRyaWFVcFNvbHZlKEEsIGIpIHtcbiAgICB2YXIgc2l6ZSA9IEFbMF0ubGVuZ3RoO1xuICAgIHZhciB4ID0galN0YXQuemVyb3MoMSwgc2l6ZSlbMF07XG4gICAgdmFyIHBhcnRzO1xuICAgIHZhciBtYXRyaXhfbW9kZSA9IGZhbHNlO1xuXG4gICAgaWYgKGJbMF0ubGVuZ3RoICE9IHVuZGVmaW5lZCkge1xuICAgICAgYiA9IGIubWFwKGZ1bmN0aW9uKGkpeyByZXR1cm4gaVswXSB9KTtcbiAgICAgIG1hdHJpeF9tb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBqU3RhdC5hcmFuZ2Uoc2l6ZSAtIDEsIC0xLCAtMSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpICsgMSwgc2l6ZSkubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgcmV0dXJuIHhbal0gKiBBW2ldW2pdO1xuICAgICAgfSk7XG4gICAgICB4W2ldID0gKGJbaV0gLSBqU3RhdC5zdW0ocGFydHMpKSAvIEFbaV1baV07XG4gICAgfSk7XG5cbiAgICBpZiAobWF0cml4X21vZGUpXG4gICAgICByZXR1cm4geC5tYXAoZnVuY3Rpb24oaSl7IHJldHVybiBbaV0gfSk7XG4gICAgcmV0dXJuIHg7XG4gIH0sXG5cbiAgdHJpYUxvd1NvbHZlOiBmdW5jdGlvbiB0cmlhTG93U29sdmUoQSwgYikge1xuICAgIC8vIGxpa2UgdG8gdHJpYVVwU29sdmUgYnV0IEEgaXMgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICB2YXIgc2l6ZSA9IEFbMF0ubGVuZ3RoO1xuICAgIHZhciB4ID0galN0YXQuemVyb3MoMSwgc2l6ZSlbMF07XG4gICAgdmFyIHBhcnRzO1xuXG4gICAgdmFyIG1hdHJpeF9tb2RlPWZhbHNlO1xuICAgIGlmIChiWzBdLmxlbmd0aCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGIgPSBiLm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIGlbMF0gfSk7XG4gICAgICBtYXRyaXhfbW9kZSA9IHRydWU7XG4gICAgfVxuXG4gICAgalN0YXQuYXJhbmdlKHNpemUpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgcGFydHMgPSBqU3RhdC5hcmFuZ2UoaSkubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgcmV0dXJuIEFbaV1bal0gKiB4W2pdO1xuICAgICAgfSk7XG4gICAgICB4W2ldID0gKGJbaV0gLSBqU3RhdC5zdW0ocGFydHMpKSAvIEFbaV1baV07XG4gICAgfSlcblxuICAgIGlmIChtYXRyaXhfbW9kZSlcbiAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIFtpXSB9KTtcbiAgICByZXR1cm4geDtcbiAgfSxcblxuXG4gIC8vIEEgLT4gW0wsVV1cbiAgLy8gQT1MVVxuICAvLyBMIGlzIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gIC8vIFUgaXMgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgbHU6IGZ1bmN0aW9uIGx1KEEpIHtcbiAgICB2YXIgc2l6ZSA9IEEubGVuZ3RoO1xuICAgIC8vdmFyIEw9alN0YXQuZGlhZ29uYWwoalN0YXQub25lcygxLHNpemUpWzBdKTtcbiAgICB2YXIgTCA9IGpTdGF0LmlkZW50aXR5KHNpemUpO1xuICAgIHZhciBSID0galN0YXQuemVyb3MoQS5sZW5ndGgsIEFbMF0ubGVuZ3RoKTtcbiAgICB2YXIgcGFydHM7XG4gICAgalN0YXQuYXJhbmdlKHNpemUpLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgUlswXVt0XSA9IEFbMF1bdF07XG4gICAgfSk7XG4gICAgalN0YXQuYXJhbmdlKDEsIHNpemUpLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgalN0YXQuYXJhbmdlKGwpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24oamopIHtcbiAgICAgICAgICByZXR1cm4gTFtsXVtqal0gKiBSW2pqXVtpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIExbbF1baV0gPSAoQVtsXVtpXSAtIGpTdGF0LnN1bShwYXJ0cykpIC8gUltpXVtpXTtcbiAgICAgIH0pO1xuICAgICAgalN0YXQuYXJhbmdlKGwsIHNpemUpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShsKS5tYXAoZnVuY3Rpb24oamopIHtcbiAgICAgICAgICByZXR1cm4gTFtsXVtqal0gKiBSW2pqXVtqXTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJbbF1bal0gPSBBW3BhcnRzLmxlbmd0aF1bal0gLSBqU3RhdC5zdW0ocGFydHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtMLCBSXTtcbiAgfSxcblxuICAvLyBBIC0+IFRcbiAgLy8gQT1UVCdcbiAgLy8gVCBpcyBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICBjaG9sZXNreTogZnVuY3Rpb24gY2hvbGVza3koQSkge1xuICAgIHZhciBzaXplID0gQS5sZW5ndGg7XG4gICAgdmFyIFQgPSBqU3RhdC56ZXJvcyhBLmxlbmd0aCwgQVswXS5sZW5ndGgpO1xuICAgIHZhciBwYXJ0cztcbiAgICBqU3RhdC5hcmFuZ2Uoc2l6ZSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coVFtpXVt0XSwyKTtcbiAgICAgIH0pO1xuICAgICAgVFtpXVtpXSA9IE1hdGguc3FydChBW2ldW2ldIC0galN0YXQuc3VtKHBhcnRzKSk7XG4gICAgICBqU3RhdC5hcmFuZ2UoaSArIDEsIHNpemUpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBUW2ldW3RdICogVFtqXVt0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIFRbal1baV0gPSAoQVtpXVtqXSAtIGpTdGF0LnN1bShwYXJ0cykpIC8gVFtpXVtpXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBUO1xuICB9LFxuXG5cbiAgZ2F1c3NfamFjb2JpOiBmdW5jdGlvbiBnYXVzc19qYWNvYmkoYSwgYiwgeCwgcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihkKSwgalN0YXQuYWRkKGwsIHUpKSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoZCksIGIpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGsseHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIGdhdXNzX3NlaWRlbDogZnVuY3Rpb24gZ2F1c3Nfc2VpZGVsKGEsIGIsIHgsIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgbCkpLCB1KSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGwpKSwgYik7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4aywgeHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIFNPUjogZnVuY3Rpb24gU09SKGEsIGIsIHgsIHIsIHcpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgalN0YXQubXVsdGlwbHkobCwgdykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3VidHJhY3QoalN0YXQubXVsdGlwbHkoZCwgMSAtIHcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5tdWx0aXBseSh1LCB3KSkpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsXG4gICAgICAgIGpTdGF0Lm11bHRpcGx5KGwsIHcpKSksIGIpLCB3KTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLCB4dikpKSA+IHIpIHtcbiAgICAgIHh2ID0geGs7XG4gICAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4diksIGMpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG4gIH0sXG5cbiAgaG91c2Vob2xkZXI6IGZ1bmN0aW9uIGhvdXNlaG9sZGVyKGEpIHtcbiAgICB2YXIgbSA9IGEubGVuZ3RoO1xuICAgIHZhciBuID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciB3ID0gW107XG4gICAgdmFyIHAgPSBbXTtcbiAgICB2YXIgYWxwaGEsIHIsIGssIGosIGZhY3RvcjtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIGFscGhhID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKVxuICAgICAgYWxwaGEgKz0gKGFbal1baV0gKiBhW2pdW2ldKTtcbiAgICAgIGZhY3RvciA9IChhW2kgKyAxXVtpXSA+IDApID8gLTEgOiAxO1xuICAgICAgYWxwaGEgPSBmYWN0b3IgKiBNYXRoLnNxcnQoYWxwaGEpO1xuICAgICAgciA9IE1hdGguc3FydCgoKChhbHBoYSAqIGFscGhhKSAtIGFbaSArIDFdW2ldICogYWxwaGEpIC8gMikpO1xuICAgICAgdyA9IGpTdGF0Lnplcm9zKG0sIDEpO1xuICAgICAgd1tpICsgMV1bMF0gPSAoYVtpICsgMV1baV0gLSBhbHBoYSkgLyAoMiAqIHIpO1xuICAgICAgZm9yIChrID0gaSArIDI7IGsgPCBtOyBrKyspIHdba11bMF0gPSBhW2tdW2ldIC8gKDIgKiByKTtcbiAgICAgIHAgPSBqU3RhdC5zdWJ0cmFjdChqU3RhdC5pZGVudGl0eShtLCBuKSxcbiAgICAgICAgICBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseSh3LCBqU3RhdC50cmFuc3Bvc2UodykpLCAyKSk7XG4gICAgICBhID0galN0YXQubXVsdGlwbHkocCwgalN0YXQubXVsdGlwbHkoYSwgcCkpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSxcblxuICAvLyBBIC0+IFtRLFJdXG4gIC8vIFEgaXMgb3J0aG9nb25hbCBtYXRyaXhcbiAgLy8gUiBpcyB1cHBlciB0cmlhbmd1bGFyXG4gIFFSOiAoZnVuY3Rpb24oKSB7XG4gICAgLy8geCAtPiBRXG4gICAgLy8gZmluZCBhIG9ydGhvZ29uYWwgbWF0cml4IFEgc3QuXG4gICAgLy8gUXg9eVxuICAgIC8vIHkgaXMgW3x8eHx8LDAsMCwuLi5dXG5cbiAgICAvLyBxdWljayByZWZcbiAgICB2YXIgc3VtICAgPSBqU3RhdC5zdW07XG4gICAgdmFyIHJhbmdlID0galN0YXQuYXJhbmdlO1xuXG4gICAgZnVuY3Rpb24gcXIyKHgpIHtcbiAgICAgIC8vIHF1aWNrIGltcGxldGF0aW9uXG4gICAgICAvLyBodHRwczovL3d3dy5zdGF0Lndpc2MuZWR1L35sYXJnZXQvbWF0aDQ5Ni9xci5odG1sXG5cbiAgICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgICB2YXIgcCA9IHhbMF0ubGVuZ3RoO1xuXG4gICAgICB2YXIgciA9IGpTdGF0Lnplcm9zKHAsIHApO1xuICAgICAgeCA9IGpTdGF0LmNvcHkoeCk7XG5cbiAgICAgIHZhciBpLGosaztcbiAgICAgIGZvcihqID0gMDsgaiA8IHA7IGorKyl7XG4gICAgICAgIHJbal1bal0gPSBNYXRoLnNxcnQoc3VtKHJhbmdlKG4pLm1hcChmdW5jdGlvbihpKXtcbiAgICAgICAgICByZXR1cm4geFtpXVtqXSAqIHhbaV1bal07XG4gICAgICAgIH0pKSk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyl7XG4gICAgICAgICAgeFtpXVtqXSA9IHhbaV1bal0gLyByW2pdW2pdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihrID0gaisxOyBrIDwgcDsgaysrKXtcbiAgICAgICAgICByW2pdW2tdID0gc3VtKHJhbmdlKG4pLm1hcChmdW5jdGlvbihpKXtcbiAgICAgICAgICAgIHJldHVybiB4W2ldW2pdICogeFtpXVtrXTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKXtcbiAgICAgICAgICAgIHhbaV1ba10gPSB4W2ldW2tdIC0geFtpXVtqXSpyW2pdW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt4LCByXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXIyO1xuICB9KCkpLFxuXG4gIGxzdHNxOiAoZnVuY3Rpb24oKSB7XG4gICAgLy8gc29sdmUgbGVhc3Qgc3F1YXJkIHByb2JsZW0gZm9yIEF4PWIgYXMgUVIgZGVjb21wb3NpdGlvbiB3YXkgaWYgYiBpc1xuICAgIC8vIFtbYjFdLFtiMl0sW2IzXV0gZm9ybSB3aWxsIHJldHVybiBbW3gxXSxbeDJdLFt4M11dIGFycmF5IGZvcm0gc29sdXRpb25cbiAgICAvLyBlbHNlIGIgaXMgW2IxLGIyLGIzXSBmb3JtIHdpbGwgcmV0dXJuIFt4MSx4Mix4M10gYXJyYXkgZm9ybSBzb2x1dGlvblxuICAgIGZ1bmN0aW9uIFJfSShBKSB7XG4gICAgICBBID0galN0YXQuY29weShBKTtcbiAgICAgIHZhciBzaXplID0gQS5sZW5ndGg7XG4gICAgICB2YXIgSSA9IGpTdGF0LmlkZW50aXR5KHNpemUpO1xuICAgICAgalN0YXQuYXJhbmdlKHNpemUgLSAxLCAtMSwgLTEpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihcbiAgICAgICAgICAgIEksIHsgcm93OiBpIH0sIGpTdGF0LmRpdmlkZShqU3RhdC5zbGljZShJLCB7IHJvdzogaSB9KSwgQVtpXVtpXSkpO1xuICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihcbiAgICAgICAgICAgIEEsIHsgcm93OiBpIH0sIGpTdGF0LmRpdmlkZShqU3RhdC5zbGljZShBLCB7IHJvdzogaSB9KSwgQVtpXVtpXSkpO1xuICAgICAgICBqU3RhdC5hcmFuZ2UoaSkuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgdmFyIGMgPSBqU3RhdC5tdWx0aXBseShBW2pdW2ldLCAtMSk7XG4gICAgICAgICAgdmFyIEFqID0galN0YXQuc2xpY2UoQSwgeyByb3c6IGogfSk7XG4gICAgICAgICAgdmFyIGNBaSA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LnNsaWNlKEEsIHsgcm93OiBpIH0pLCBjKTtcbiAgICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihBLCB7IHJvdzogaiB9LCBqU3RhdC5hZGQoQWosIGNBaSkpO1xuICAgICAgICAgIHZhciBJaiA9IGpTdGF0LnNsaWNlKEksIHsgcm93OiBqIH0pO1xuICAgICAgICAgIHZhciBjSWkgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5zbGljZShJLCB7IHJvdzogaSB9KSwgYyk7XG4gICAgICAgICAgalN0YXQuc2xpY2VBc3NpZ24oSSwgeyByb3c6IGogfSwgalN0YXQuYWRkKElqLCBjSWkpKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXJfc29sdmUoQSwgYil7XG4gICAgICB2YXIgYXJyYXlfbW9kZSA9IGZhbHNlO1xuICAgICAgaWYgKGJbMF0ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gW2MxLGMyLGMzXSBtb2RlXG4gICAgICAgIGIgPSBiLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIFt4XSB9KTtcbiAgICAgICAgYXJyYXlfbW9kZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgUVIgPSBqU3RhdC5RUihBKTtcbiAgICAgIHZhciBRID0gUVJbMF07XG4gICAgICB2YXIgUiA9IFFSWzFdO1xuICAgICAgdmFyIGF0dHJzID0gQVswXS5sZW5ndGg7XG4gICAgICB2YXIgUTEgPSBqU3RhdC5zbGljZShRLHtjb2w6e2VuZDphdHRyc319KTtcbiAgICAgIHZhciBSMSA9IGpTdGF0LnNsaWNlKFIse3Jvdzp7ZW5kOmF0dHJzfX0pO1xuICAgICAgdmFyIFJJID0gUl9JKFIxKTtcbiAgICAgIHZhciBRMiA9IGpTdGF0LnRyYW5zcG9zZShRMSk7XG5cbiAgICAgIGlmKFEyWzBdLmxlbmd0aCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgUTIgPSBbUTJdOyAvLyBUaGUgY29uZnVzaW5nIGpTdGF0Lm11bHRpZmx5IGltcGxlbWVudGF0aW9uIHRocmVhdCBuYXR1cmUgcHJvY2VzcyBhZ2Fpbi5cbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShSSSwgUTIpLCBiKTtcblxuICAgICAgaWYoeC5sZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHggPSBbW3hdXTsgLy8gVGhlIGNvbmZ1c2luZyBqU3RhdC5tdWx0aWZseSBpbXBsZW1lbnRhdGlvbiB0aHJlYXQgbmF0dXJlIHByb2Nlc3MgYWdhaW4uXG4gICAgICB9XG5cblxuICAgICAgaWYgKGFycmF5X21vZGUpXG4gICAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIGlbMF0gfSk7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXJfc29sdmU7XG4gIH0oKSksXG5cbiAgamFjb2JpOiBmdW5jdGlvbiBqYWNvYmkoYSkge1xuICAgIHZhciBjb25kaXRpb24gPSAxO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGUgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICB2YXIgZXYgPSBbXTtcbiAgICB2YXIgYiwgaSwgaiwgcCwgcSwgbWF4aW0sIHRoZXRhLCBzO1xuICAgIC8vIGNvbmRpdGlvbiA9PT0gMSBvbmx5IGlmIHRvbGVyYW5jZSBpcyBub3QgcmVhY2hlZFxuICAgIHdoaWxlIChjb25kaXRpb24gPT09IDEpIHtcbiAgICAgIG1heGltID0gYVswXVsxXTtcbiAgICAgIHAgPSAwO1xuICAgICAgcSA9IDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgICBpZiAobWF4aW0gPCBNYXRoLmFicyhhW2ldW2pdKSkge1xuICAgICAgICAgICAgICBtYXhpbSA9IE1hdGguYWJzKGFbaV1bal0pO1xuICAgICAgICAgICAgICBwID0gaTtcbiAgICAgICAgICAgICAgcSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYVtwXVtwXSA9PT0gYVtxXVtxXSlcbiAgICAgICAgdGhldGEgPSAoYVtwXVtxXSA+IDApID8gTWF0aC5QSSAvIDQgOiAtTWF0aC5QSSAvIDQ7XG4gICAgICBlbHNlXG4gICAgICAgIHRoZXRhID0gTWF0aC5hdGFuKDIgKiBhW3BdW3FdIC8gKGFbcF1bcF0gLSBhW3FdW3FdKSkgLyAyO1xuICAgICAgcyA9IGpTdGF0LmlkZW50aXR5KG4sIG4pO1xuICAgICAgc1twXVtwXSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHNbcF1bcV0gPSAtTWF0aC5zaW4odGhldGEpO1xuICAgICAgc1txXVtwXSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHNbcV1bcV0gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAvLyBlaWdlbiB2ZWN0b3IgbWF0cml4XG4gICAgICBlID0galN0YXQubXVsdGlwbHkoZSwgcyk7XG4gICAgICBiID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KHMpLCBhKSwgcyk7XG4gICAgICBhID0gYjtcbiAgICAgIGNvbmRpdGlvbiA9IDA7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqICYmIE1hdGguYWJzKGFbaV1bal0pID4gMC4wMDEpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGV2LnB1c2goYVtpXVtpXSk7XG4gICAgLy9yZXR1cm5zIGJvdGggdGhlIGVpZ2VudmFsdWUgYW5kIGVpZ2VubWF0cml4XG4gICAgcmV0dXJuIFtlLCBldl07XG4gIH0sXG5cbiAgcnVuZ2VrdXR0YTogZnVuY3Rpb24gcnVuZ2VrdXR0YShmLCBoLCBwLCB0X2osIHVfaiwgb3JkZXIpIHtcbiAgICB2YXIgazEsIGsyLCB1X2oxLCBrMywgazQ7XG4gICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCwgdV9qICsgazEpO1xuICAgICAgICB1X2oxID0gdV9qICsgKGsxICsgazIpIC8gMjtcbiAgICAgICAgdV9qID0gdV9qMTtcbiAgICAgICAgdF9qID0gdF9qICsgaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyID09PSA0KSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsxIC8gMik7XG4gICAgICAgIGszID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsyIC8gMik7XG4gICAgICAgIGs0ID0gaCAqIGYodF9qICtoLCB1X2ogKyBrMyk7XG4gICAgICAgIHVfajEgPSB1X2ogKyAoazEgKyAyICogazIgKyAyICogazMgKyBrNCkgLyA2O1xuICAgICAgICB1X2ogPSB1X2oxO1xuICAgICAgICB0X2ogPSB0X2ogKyBoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdV9qO1xuICB9LFxuXG4gIHJvbWJlcmc6IGZ1bmN0aW9uIHJvbWJlcmcoZiwgYSwgYiwgb3JkZXIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gMjtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBoMSA9IFtdO1xuICAgIHZhciBnID0gW107XG4gICAgdmFyIG0sIGExLCBqLCBrLCBJO1xuICAgIHdoaWxlIChpIDwgb3JkZXIgLyAyKSB7XG4gICAgICBJID0gZihhKTtcbiAgICAgIGZvciAoaiA9IGEsIGsgPSAwOyBqIDw9IGI7IGogPSBqICsgaCwgaysrKSB4W2tdID0gajtcbiAgICAgIG0gPSB4Lmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBtIC0gMTsgaisrKSB7XG4gICAgICAgIEkgKz0gKCgoaiAlIDIpICE9PSAwKSA/IDQgOiAyKSAqIGYoeFtqXSk7XG4gICAgICB9XG4gICAgICBJID0gKGggLyAzKSAqIChJICsgZihiKSk7XG4gICAgICBnW2ldID0gSTtcbiAgICAgIGggLz0gMjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgYTEgPSBnLmxlbmd0aDtcbiAgICBtID0gMTtcbiAgICB3aGlsZSAoYTEgIT09IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhMSAtIDE7IGorKylcbiAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhMSA9IGgxLmxlbmd0aDtcbiAgICAgIGcgPSBoMTtcbiAgICAgIGgxID0gW107XG4gICAgICBtKys7XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9LFxuXG4gIHJpY2hhcmRzb246IGZ1bmN0aW9uIHJpY2hhcmRzb24oWCwgZiwgeCwgaCkge1xuICAgIGZ1bmN0aW9uIHBvcyhYLCB4KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgICAgdmFyIHA7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKylcbiAgICAgICAgaWYgKFhbaV0gPT09IHgpIHAgPSBpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBoX21pbiA9IE1hdGguYWJzKHggLSBYW3BvcyhYLCB4KSArIDFdKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGcgPSBbXTtcbiAgICB2YXIgaDEgPSBbXTtcbiAgICB2YXIgeTEsIHkyLCBtLCBhLCBqO1xuICAgIHdoaWxlIChoID49IGhfbWluKSB7XG4gICAgICB5MSA9IHBvcyhYLCB4ICsgaCk7XG4gICAgICB5MiA9IHBvcyhYLCB4KTtcbiAgICAgIGdbaV0gPSAoZlt5MV0gLSAyICogZlt5Ml0gKyBmWzIgKiB5MiAtIHkxXSkgLyAoaCAqIGgpO1xuICAgICAgaCAvPSAyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBhID0gZy5sZW5ndGg7XG4gICAgbSA9IDE7XG4gICAgd2hpbGUgKGEgIT0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGEgLSAxOyBqKyspXG4gICAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhID0gaDEubGVuZ3RoO1xuICAgICAgZyA9IGgxO1xuICAgICAgaDEgPSBbXTtcbiAgICAgIG0rKztcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH0sXG5cbiAgc2ltcHNvbjogZnVuY3Rpb24gc2ltcHNvbihmLCBhLCBiLCBuKSB7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gbjtcbiAgICB2YXIgSSA9IGYoYSk7XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaiA9IGE7XG4gICAgdmFyIGsgPSAwO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgbTtcbiAgICBmb3IgKDsgaiA8PSBiOyBqID0gaiArIGgsIGsrKylcbiAgICAgIHhba10gPSBqO1xuICAgIG0gPSB4Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIEkgKz0gKChpICUgMiAhPT0gMCkgPyA0IDogMikgKiBmKHhbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gKGggLyAzKSAqIChJICsgZihiKSk7XG4gIH0sXG5cbiAgaGVybWl0ZTogZnVuY3Rpb24gaGVybWl0ZShYLCBGLCBkRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgZGwgPSBbXTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGo7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSAxO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSBsW2ldICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIGRsW2ldID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaikgZGxbaV0gKz0gMSAvIChYIFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgQVtpXSA9ICgxIC0gMiAqICh2YWx1ZSAtIFhbaV0pICogZGxbaV0pICogKGxbaV0gKiBsW2ldKTtcbiAgICAgIEJbaV0gPSAodmFsdWUgLSBYW2ldKSAqIChsW2ldICogbFtpXSk7XG4gICAgICBwICs9IChBW2ldICogRltpXSArIEJbaV0gKiBkRltpXSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIGxhZ3JhbmdlOiBmdW5jdGlvbiBsYWdyYW5nZShYLCBGLCB2YWx1ZSkge1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGosIGw7XG4gICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbCA9IEZbaV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0aW5nIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFsIExfaVxuICAgICAgICBpZiAoaSAhPSBqKSBsICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZGluZyB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbHMgZm91bmQgYWJvdmVcbiAgICAgIHAgKz0gbDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgY3ViaWNfc3BsaW5lOiBmdW5jdGlvbiBjdWJpY19zcGxpbmUoWCwgRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBpID0gMCwgajtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGFscGhhID0gW107XG4gICAgdmFyIGMgPSBbXTtcbiAgICB2YXIgaCA9IFtdO1xuICAgIHZhciBiID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICBmb3IgKDsgaSA8IG4gLSAxOyBpKyspXG4gICAgICBoW2ldID0gWFtpICsgMV0gLSBYW2ldO1xuICAgIGFscGhhWzBdID0gMDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgYWxwaGFbaV0gPSAoMyAvIGhbaV0pICogKEZbaSArIDFdIC0gRltpXSkgLVxuICAgICAgICAgICgzIC8gaFtpLTFdKSAqIChGW2ldIC0gRltpLTFdKTtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIEFbaV0gPSBbXTtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIEFbaV1baS0xXSA9IGhbaS0xXTtcbiAgICAgIEFbaV1baV0gPSAyICogKGhbaSAtIDFdICsgaFtpXSk7XG4gICAgICBBW2ldW2krMV0gPSBoW2ldO1xuICAgICAgQltpXVswXSA9IGFscGhhW2ldO1xuICAgIH1cbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KEEpLCBCKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbiAtIDE7IGorKykge1xuICAgICAgYltqXSA9IChGW2ogKyAxXSAtIEZbal0pIC8gaFtqXSAtIGhbal0gKiAoY1tqICsgMV1bMF0gKyAyICogY1tqXVswXSkgLyAzO1xuICAgICAgZFtqXSA9IChjW2ogKyAxXVswXSAtIGNbal1bMF0pIC8gKDMgKiBoW2pdKTtcbiAgICB9XG4gICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKFhbal0gPiB2YWx1ZSkgYnJlYWs7XG4gICAgfVxuICAgIGogLT0gMTtcbiAgICByZXR1cm4gRltqXSArICh2YWx1ZSAtIFhbal0pICogYltqXSArIGpTdGF0LnNxKHZhbHVlLVhbal0pICpcbiAgICAgICAgY1tqXSArICh2YWx1ZSAtIFhbal0pICogalN0YXQuc3EodmFsdWUgLSBYW2pdKSAqIGRbal07XG4gIH0sXG5cbiAgZ2F1c3NfcXVhZHJhdHVyZTogZnVuY3Rpb24gZ2F1c3NfcXVhZHJhdHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhdXNzX3F1YWRyYXR1cmUgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIFBDQTogZnVuY3Rpb24gUENBKFgpIHtcbiAgICB2YXIgbSA9IFgubGVuZ3RoO1xuICAgIHZhciBuID0gWFswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqLCB0ZW1wMTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBEID0gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB0ZW1wMiA9IFtdO1xuICAgIHZhciBZID0gW107XG4gICAgdmFyIEJ0ID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgQyA9IFtdO1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIFZ0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgdVtpXSA9IGpTdGF0LnN1bShYW2ldKSAvIG47XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIGZvcihqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBCW2ldW2pdID0gWFtqXVtpXSAtIHVbal07XG4gICAgICB9XG4gICAgfVxuICAgIEIgPSBqU3RhdC50cmFuc3Bvc2UoQik7XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgQ1tpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBDW2ldW2pdID0gKGpTdGF0LmRvdChbQltpXV0sIFtCW2pdXSkpIC8gKG4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0galN0YXQuamFjb2JpKEMpO1xuICAgIFYgPSByZXN1bHRbMF07XG4gICAgRCA9IHJlc3VsdFsxXTtcbiAgICBWdCA9IGpTdGF0LnRyYW5zcG9zZShWKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgRC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gaTsgaiA8IEQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYoRFtpXSA8IERbal0pICB7XG4gICAgICAgICAgdGVtcDEgPSBEW2ldO1xuICAgICAgICAgIERbaV0gPSBEW2pdO1xuICAgICAgICAgIERbal0gPSB0ZW1wMTtcbiAgICAgICAgICB0ZW1wMiA9IFZ0W2ldO1xuICAgICAgICAgIFZ0W2ldID0gVnRbal07XG4gICAgICAgICAgVnRbal0gPSB0ZW1wMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBCdCA9IGpTdGF0LnRyYW5zcG9zZShCKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICBZW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgQnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgWVtpXVtqXSA9IGpTdGF0LmRvdChbVnRbaV1dLCBbQnRbal1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtYLCBELCBWdCwgWV07XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgalN0YXQuZm4gd2l0aCBtZXRob2RzIHRoYXQgcmVxdWlyZSBvbmUgYXJndW1lbnRcbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqU3RhdC5mbltwYXNzZnVuY10gPSBmdW5jdGlvbihhcmcsIGZ1bmMpIHtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIGNoZWNrIGZvciBjYWxsYmFja1xuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalN0YXQuZm5bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgYXJnKSk7XG4gICAgICAgIH0sIDE1KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGFyZykpO1xuICAgIH07XG4gIH0oZnVuY3NbaV0pKTtcbn0oJ2FkZCBkaXZpZGUgbXVsdGlwbHkgc3VidHJhY3QgZG90IHBvdyBleHAgbG9nIGFicyBub3JtIGFuZ2xlJy5zcGxpdCgnICcpKSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBpc051bWJlciA9IGpTdGF0LnV0aWxzLmlzTnVtYmVyO1xudmFyIGlzQXJyYXkgPSBqU3RhdC51dGlscy5pc0FycmF5O1xuXG4vLyBmbGFnPT10cnVlIGRlbm90ZXMgdXNlIG9mIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25cbi8vIFogU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkKVxuICAvLyAodmFsdWUsIGFycmF5LCBmbGFnKVxuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHJldHVybiAoYXJnc1swXSAtIGFyZ3NbMV0pIC8gYXJnc1syXTtcbiAgICB9XG4gICAgcmV0dXJuIChhcmdzWzBdIC0galN0YXQubWVhbihhcmdzWzFdKSkgLyBqU3RhdC5zdGRldihhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfSxcblxuICAvLyAzIGRpZmZlcmVudCBwYXJhbXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgc2lkZXMpXG4gIC8vICh6c2NvcmUsIHNpZGVzKVxuICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcywgZmxhZylcbiAgenRlc3Q6IGZ1bmN0aW9uIHp0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB6O1xuICAgIGlmIChpc0FycmF5KGFyZ3NbMV0pKSB7XG4gICAgICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcywgZmxhZylcbiAgICAgIHogPSBqU3RhdC56c2NvcmUoYXJnc1swXSxhcmdzWzFdLGFyZ3NbM10pO1xuICAgICAgcmV0dXJuIChhcmdzWzJdID09PSAxKSA/XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkpIDpcbiAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLCAwLCAxKSoyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAvLyAodmFsdWUsIG1lYW4sIHNkLCBzaWRlcylcbiAgICAgICAgeiA9IGpTdGF0LnpzY29yZShhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSk7XG4gICAgICAgIHJldHVybiAoYXJnc1szXSA9PT0gMSkgP1xuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKSA6XG4gICAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkqIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKHpzY29yZSwgc2lkZXMpXG4gICAgICAgIHogPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gKGFyZ3NbMV0gPT09IDEpID9cbiAgICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSkgOlxuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKjIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSh2YWx1ZSwgZmxhZykge1xuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1lYW4oKSkgLyB0aGlzLnN0ZGV2KGZsYWcpO1xuICB9LFxuXG4gIHp0ZXN0OiBmdW5jdGlvbiB6dGVzdCh2YWx1ZSwgc2lkZXMsIGZsYWcpIHtcbiAgICB2YXIgenNjb3JlID0gTWF0aC5hYnModGhpcy56c2NvcmUodmFsdWUsIGZsYWcpKTtcbiAgICByZXR1cm4gKHNpZGVzID09PSAxKSA/XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtenNjb3JlLCAwLCAxKSkgOlxuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLXpzY29yZSwgMCwgMSkgKiAyKTtcbiAgfVxufSk7XG5cbi8vIFQgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBwYXJhbWV0ZXIgbGlzdHNcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhcnJheSlcbiAgdHNjb3JlOiBmdW5jdGlvbiB0c2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIChhcmdzLmxlbmd0aCA9PT0gNCkgP1xuICAgICAgKChhcmdzWzBdIC0gYXJnc1sxXSkgLyAoYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSkpIDpcbiAgICAgICgoYXJnc1swXSAtIGpTdGF0Lm1lYW4oYXJnc1sxXSkpIC9cbiAgICAgICAoalN0YXQuc3RkZXYoYXJnc1sxXSwgdHJ1ZSkgLyBNYXRoLnNxcnQoYXJnc1sxXS5sZW5ndGgpKSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW10ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIG4sIHNpZGVzKVxuICAvLyAodHNjb3JlLCBuLCBzaWRlcylcbiAgLy8gKHZhbHVlLCBhcnJheSwgc2lkZXMpXG4gIHR0ZXN0OiBmdW5jdGlvbiB0dGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgdHNjb3JlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdHNjb3JlID0gTWF0aC5hYnMoalN0YXQudHNjb3JlKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pKTtcbiAgICAgIHJldHVybiAoYXJnc1s0XSA9PT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbM10tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzNdLTEpKjIpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHRzY29yZSA9IE1hdGguYWJzKGFyZ3NbMF0pXG4gICAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLTEpICogMik7XG4gICAgfVxuICAgIHRzY29yZSA9IE1hdGguYWJzKGpTdGF0LnRzY29yZShhcmdzWzBdLCBhcmdzWzFdKSlcbiAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSkgOlxuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSAqIDIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIHRzY29yZTogZnVuY3Rpb24gdHNjb3JlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWVhbigpKSAvICh0aGlzLnN0ZGV2KHRydWUpIC8gTWF0aC5zcXJ0KHRoaXMuY29scygpKSk7XG4gIH0sXG5cbiAgdHRlc3Q6IGZ1bmN0aW9uIHR0ZXN0KHZhbHVlLCBzaWRlcykge1xuICAgIHJldHVybiAoc2lkZXMgPT09IDEpID9cbiAgICAgICgxIC0galN0YXQuc3R1ZGVudHQuY2RmKE1hdGguYWJzKHRoaXMudHNjb3JlKHZhbHVlKSksIHRoaXMuY29scygpLTEpKSA6XG4gICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC1NYXRoLmFicyh0aGlzLnRzY29yZSh2YWx1ZSkpLCB0aGlzLmNvbHMoKS0xKSoyKTtcbiAgfVxufSk7XG5cbi8vIEYgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gUGFyYW10ZXIgbGlzdCBpcyBhcyBmb2xsb3dzOlxuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyBvciBpdCBpcyBhbiBhcnJheSBvZiBhcnJheXNcbiAgLy8gYXJyYXkgb2YgYXJyYXlzIGNvbnZlcnNpb25cbiAgYW5vdmFmc2NvcmU6IGZ1bmN0aW9uIGFub3ZhZnNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGV4cFZhciwgc2FtcGxlLCBzYW1wTWVhbiwgc2FtcFNhbXBNZWFuLCB0bXBhcmdzLCB1bmV4cFZhciwgaSwgajtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRtcGFyZ3MgPSBuZXcgQXJyYXkoYXJnc1swXS5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wYXJnc1tpXSA9IGFyZ3NbMF1baV07XG4gICAgICB9XG4gICAgICBhcmdzID0gdG1wYXJncztcbiAgICB9XG4gICAgLy8gQnVpbGRzIHNhbXBsZSBhcnJheVxuICAgIHNhbXBsZSA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGUuY29uY2F0KGFyZ3NbaV0pO1xuICAgIH1cbiAgICBzYW1wTWVhbiA9IGpTdGF0Lm1lYW4oc2FtcGxlKTtcbiAgICAvLyBDb21wdXRlcyB0aGUgZXhwbGFpbmVkIHZhcmlhbmNlXG4gICAgZXhwVmFyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwVmFyID0gZXhwVmFyICsgYXJnc1tpXS5sZW5ndGggKiBNYXRoLnBvdyhqU3RhdC5tZWFuKGFyZ3NbaV0pIC0gc2FtcE1lYW4sIDIpO1xuICAgIH1cbiAgICBleHBWYXIgLz0gKGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgLy8gQ29tcHV0ZXMgdW5leHBsYWluZWQgdmFyaWFuY2VcbiAgICB1bmV4cFZhciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBTYW1wTWVhbiA9IGpTdGF0Lm1lYW4oYXJnc1tpXSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYXJnc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICB1bmV4cFZhciArPSBNYXRoLnBvdyhhcmdzW2ldW2pdIC0gc2FtcFNhbXBNZWFuLCAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5leHBWYXIgLz0gKHNhbXBsZS5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgcmV0dXJuIGV4cFZhciAvIHVuZXhwVmFyO1xuICB9LFxuXG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtdGVyIHNldHVwc1xuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyAoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKVxuICBhbm92YWZ0ZXN0OiBmdW5jdGlvbiBhbm92YWZ0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGRmMSwgZGYyLCBuLCBpO1xuICAgIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHZhciBhbm92YWZzY29yZSA9IGpTdGF0LmFub3ZhZnNjb3JlKGFyZ3MpO1xuICAgIGRmMSA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICBuID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyBhcmdzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgZGYyID0gbiAtIGRmMSAtIDE7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKTtcbiAgfSxcblxuICBmdGVzdDogZnVuY3Rpb24gZnRlc3QoZnNjb3JlLCBkZjEsIGRmMikge1xuICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGZzY29yZSwgZGYxLCBkZjIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIGFub3ZhZnNjb3JlOiBmdW5jdGlvbiBhbm92YWZzY29yZSgpIHtcbiAgICByZXR1cm4galN0YXQuYW5vdmFmc2NvcmUodGhpcy50b0FycmF5KCkpO1xuICB9LFxuXG4gIGFub3ZhZnRlczogZnVuY3Rpb24gYW5vdmFmdGVzKCkge1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyB0aGlzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0LmZ0ZXN0KHRoaXMuYW5vdmFmc2NvcmUoKSwgdGhpcy5sZW5ndGggLSAxLCBuIC0gdGhpcy5sZW5ndGgpO1xuICB9XG59KTtcblxuLy8gVHVrZXkncyByYW5nZSB0ZXN0XG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIHBhcmFtZXRlciBsaXN0c1xuICAvLyAobWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkKVxuICAvLyAoYXJyYXkxLCBhcnJheTIsIHNkKVxuICBxc2NvcmU6IGZ1bmN0aW9uIHFzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgbWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkO1xuICAgIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgICAgICBtZWFuMSA9IGFyZ3NbMF07XG4gICAgICAgIG1lYW4yID0gYXJnc1sxXTtcbiAgICAgICAgbjEgPSBhcmdzWzJdO1xuICAgICAgICBuMiA9IGFyZ3NbM107XG4gICAgICAgIHNkID0gYXJnc1s0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtZWFuMSA9IGpTdGF0Lm1lYW4oYXJnc1swXSk7XG4gICAgICAgIG1lYW4yID0galN0YXQubWVhbihhcmdzWzFdKTtcbiAgICAgICAgbjEgPSBhcmdzWzBdLmxlbmd0aDtcbiAgICAgICAgbjIgPSBhcmdzWzFdLmxlbmd0aDtcbiAgICAgICAgc2QgPSBhcmdzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMobWVhbjEgLSBtZWFuMikgLyAoc2QgKiBNYXRoLnNxcnQoKDEgLyBuMSArIDEgLyBuMikgLyAyKSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW1ldGVyIGxpc3RzOlxuICAvLyAocXNjb3JlLCBuLCBrKVxuICAvLyAobWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkLCBuLCBrKVxuICAvLyAoYXJyYXkxLCBhcnJheTIsIHNkLCBuLCBrKVxuICBxdGVzdDogZnVuY3Rpb24gcXRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgcXNjb3JlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcXNjb3JlID0gYXJnc1swXTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDcpIHtcbiAgICAgIHFzY29yZSA9IGpTdGF0LnFzY29yZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxc2NvcmUgPSBqU3RhdC5xc2NvcmUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgzKTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IGFyZ3NbMF07XG4gICAgdmFyIGsgPSBhcmdzWzFdO1xuXG4gICAgcmV0dXJuIDEgLSBqU3RhdC50dWtleS5jZGYocXNjb3JlLCBrLCBuIC0gayk7XG4gIH0sXG5cbiAgdHVrZXloc2Q6IGZ1bmN0aW9uIHR1a2V5aHNkKGFycmF5cykge1xuICAgIHZhciBzZCA9IGpTdGF0LnBvb2xlZHN0ZGV2KGFycmF5cyk7XG4gICAgdmFyIG1lYW5zID0gYXJyYXlzLm1hcChmdW5jdGlvbiAoYXJyKSB7cmV0dXJuIGpTdGF0Lm1lYW4oYXJyKTt9KTtcbiAgICB2YXIgbiA9IGFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKG4sIGFycikge3JldHVybiBuICsgYXJyLmxlbmd0aDt9LCAwKTtcblxuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgYXJyYXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGpTdGF0LnF0ZXN0KG1lYW5zW2ldLCBtZWFuc1tqXSwgYXJyYXlzW2ldLmxlbmd0aCwgYXJyYXlzW2pdLmxlbmd0aCwgc2QsIG4sIGFycmF5cy5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtbaSwgal0sIHBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59KTtcblxuLy8gRXJyb3IgQm91bmRzXG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgc2V0dXBzXG4gIC8vICh2YWx1ZSwgYWxwaGEsIHNkLCBuKVxuICAvLyAodmFsdWUsIGFscGhhLCBhcnJheSlcbiAgbm9ybWFsY2k6IGZ1bmN0aW9uIG5vcm1hbGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5ub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQubm9ybWFsLmludihhcmdzWzFdIC8gMiwgMCwgMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3RkZXYoYXJnc1syXSkgLyBNYXRoLnNxcnQoYXJnc1syXS5sZW5ndGgpKTtcbiAgICB9XG4gICAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgICBhbnNbMV0gPSBhcmdzWzBdICsgY2hhbmdlO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIHNldHVwc1xuICAvLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhbHBoYSwgYXJyYXkpXG4gIHRjaTogZnVuY3Rpb24gdGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYoYXJnc1sxXSAvIDIsIGFyZ3NbM10gLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KGFyZ3NbMV0gLyAyLCBhcmdzWzJdLmxlbmd0aCAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN0ZGV2KGFyZ3NbMl0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gICAgfVxuICAgIGFuc1swXSA9IGFyZ3NbMF0gLSBjaGFuZ2U7XG4gICAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIHNpZ25pZmljYW50OiBmdW5jdGlvbiBzaWduaWZpY2FudChwdmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIHB2YWx1ZSA8IGFscGhhO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIG5vcm1hbGNpOiBmdW5jdGlvbiBub3JtYWxjaSh2YWx1ZSwgYWxwaGEpIHtcbiAgICByZXR1cm4galN0YXQubm9ybWFsY2kodmFsdWUsIGFscGhhLCB0aGlzLnRvQXJyYXkoKSk7XG4gIH0sXG5cbiAgdGNpOiBmdW5jdGlvbiB0Y2kodmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIGpTdGF0LnRjaSh2YWx1ZSwgYWxwaGEsIHRoaXMudG9BcnJheSgpKTtcbiAgfVxufSk7XG5cbi8vIGludGVybmFsIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHotc2NvcmUgZm9yIGEgZGlmZmVyZW5jZSBvZiBwcm9wb3J0aW9ucyB0ZXN0XG5mdW5jdGlvbiBkaWZmZXJlbmNlT2ZQcm9wb3J0aW9ucyhwMSwgbjEsIHAyLCBuMikge1xuICBpZiAocDEgPiAxIHx8IHAyID4gMSB8fCBwMSA8PSAwIHx8IHAyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wb3J0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxXCIpXG4gIH1cbiAgdmFyIHBvb2xlZCA9IChwMSAqIG4xICsgcDIgKiBuMikgLyAobjEgKyBuMik7XG4gIHZhciBzZSA9IE1hdGguc3FydChwb29sZWQgKiAoMSAtIHBvb2xlZCkgKiAoKDEvbjEpICsgKDEvbjIpKSk7XG4gIHJldHVybiAocDEgLSBwMikgLyBzZTtcbn1cblxuLy8gRGlmZmVyZW5jZSBvZiBQcm9wb3J0aW9uc1xualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIG9uZVNpZGVkRGlmZmVyZW5jZU9mUHJvcG9ydGlvbnM6IGZ1bmN0aW9uIG9uZVNpZGVkRGlmZmVyZW5jZU9mUHJvcG9ydGlvbnMocDEsIG4xLCBwMiwgbjIpIHtcbiAgICB2YXIgeiA9IGRpZmZlcmVuY2VPZlByb3BvcnRpb25zKHAxLCBuMSwgcDIsIG4yKTtcbiAgICByZXR1cm4galN0YXQuenRlc3QoeiwgMSk7XG4gIH0sXG5cbiAgdHdvU2lkZWREaWZmZXJlbmNlT2ZQcm9wb3J0aW9uczogZnVuY3Rpb24gdHdvU2lkZWREaWZmZXJlbmNlT2ZQcm9wb3J0aW9ucyhwMSwgbjEsIHAyLCBuMikge1xuICAgIHZhciB6ID0gZGlmZmVyZW5jZU9mUHJvcG9ydGlvbnMocDEsIG4xLCBwMiwgbjIpO1xuICAgIHJldHVybiBqU3RhdC56dGVzdCh6LCAyKTtcbiAgfVxufSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbmpTdGF0Lm1vZGVscyA9IChmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBzdWJfcmVncmVzcyhleG9nKSB7XG4gICAgdmFyIHZhcl9jb3VudCA9IGV4b2dbMF0ubGVuZ3RoO1xuICAgIHZhciBtb2RlbExpc3QgPSBqU3RhdC5hcmFuZ2UodmFyX2NvdW50KS5tYXAoZnVuY3Rpb24oZW5kb2dfaW5kZXgpIHtcbiAgICAgIHZhciBleG9nX2luZGV4ID1cbiAgICAgICAgICBqU3RhdC5hcmFuZ2UodmFyX2NvdW50KS5maWx0ZXIoZnVuY3Rpb24oaSl7cmV0dXJuIGkhPT1lbmRvZ19pbmRleH0pO1xuICAgICAgcmV0dXJuIG9scyhqU3RhdC5jb2woZXhvZywgZW5kb2dfaW5kZXgpLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIHhbMF0gfSksXG4gICAgICAgICAgICAgICAgIGpTdGF0LmNvbChleG9nLCBleG9nX2luZGV4KSlcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZWxMaXN0O1xuICB9XG5cbiAgLy8gZG8gT0xTIG1vZGVsIHJlZ3Jlc3NcbiAgLy8gZXhvZyBoYXZlIGluY2x1ZGUgY29uc3QgY29sdW1ucyAsaXQgd2lsbCBub3QgZ2VuZXJhdGUgaXQgLkluIGZhY3QsIGV4b2cgaXNcbiAgLy8gXCJkZXNpZ24gbWF0cml4XCIgbG9vayBhdFxuICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rlc2lnbl9tYXRyaXhcbiAgZnVuY3Rpb24gb2xzKGVuZG9nLCBleG9nKSB7XG4gICAgdmFyIG5vYnMgPSBlbmRvZy5sZW5ndGg7XG4gICAgdmFyIGRmX21vZGVsID0gZXhvZ1swXS5sZW5ndGggLSAxO1xuICAgIHZhciBkZl9yZXNpZCA9IG5vYnMtZGZfbW9kZWwgLSAxO1xuICAgIHZhciBjb2VmID0galN0YXQubHN0c3EoZXhvZywgZW5kb2cpO1xuICAgIHZhciBwcmVkaWN0ID1cbiAgICAgICAgalN0YXQubXVsdGlwbHkoZXhvZywgY29lZi5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3hdIH0pKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdIH0pO1xuICAgIHZhciByZXNpZCA9IGpTdGF0LnN1YnRyYWN0KGVuZG9nLCBwcmVkaWN0KTtcbiAgICB2YXIgeWJhciA9IGpTdGF0Lm1lYW4oZW5kb2cpO1xuICAgIC8vIGNvbnN0YW50IGNhdXNlIHByb2JsZW1cbiAgICAvLyB2YXIgU1NUID0galN0YXQuc3VtKGVuZG9nLm1hcChmdW5jdGlvbih5KSB7XG4gICAgLy8gICByZXR1cm4gTWF0aC5wb3coeS15YmFyLDIpO1xuICAgIC8vIH0pKTtcbiAgICB2YXIgU1NFID0galN0YXQuc3VtKHByZWRpY3QubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhmIC0geWJhciwgMik7XG4gICAgfSkpO1xuICAgIHZhciBTU1IgPSBqU3RhdC5zdW0oZW5kb2cubWFwKGZ1bmN0aW9uKHksIGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh5IC0gcHJlZGljdFtpXSwgMik7XG4gICAgfSkpO1xuICAgIHZhciBTU1QgPSBTU0UgKyBTU1I7XG4gICAgdmFyIFIyID0gKFNTRSAvIFNTVCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhvZzpleG9nLFxuICAgICAgICBlbmRvZzplbmRvZyxcbiAgICAgICAgbm9iczpub2JzLFxuICAgICAgICBkZl9tb2RlbDpkZl9tb2RlbCxcbiAgICAgICAgZGZfcmVzaWQ6ZGZfcmVzaWQsXG4gICAgICAgIGNvZWY6Y29lZixcbiAgICAgICAgcHJlZGljdDpwcmVkaWN0LFxuICAgICAgICByZXNpZDpyZXNpZCxcbiAgICAgICAgeWJhcjp5YmFyLFxuICAgICAgICBTU1Q6U1NULFxuICAgICAgICBTU0U6U1NFLFxuICAgICAgICBTU1I6U1NSLFxuICAgICAgICBSMjpSMlxuICAgIH07XG4gIH1cblxuICAvLyBIMDogYl9JPTBcbiAgLy8gSDE6IGJfSSE9MFxuICBmdW5jdGlvbiB0X3Rlc3QobW9kZWwpIHtcbiAgICB2YXIgc3ViTW9kZWxMaXN0ID0gc3ViX3JlZ3Jlc3MobW9kZWwuZXhvZyk7XG4gICAgLy92YXIgc2lnbWFIYXQ9alN0YXQuc3RkZXYobW9kZWwucmVzaWQpO1xuICAgIHZhciBzaWdtYUhhdCA9IE1hdGguc3FydChtb2RlbC5TU1IgLyAobW9kZWwuZGZfcmVzaWQpKTtcbiAgICB2YXIgc2VCZXRhSGF0ID0gc3ViTW9kZWxMaXN0Lm1hcChmdW5jdGlvbihtb2QpIHtcbiAgICAgIHZhciBTU1QgPSBtb2QuU1NUO1xuICAgICAgdmFyIFIyID0gbW9kLlIyO1xuICAgICAgcmV0dXJuIHNpZ21hSGF0IC8gTWF0aC5zcXJ0KFNTVCAqICgxIC0gUjIpKTtcbiAgICB9KTtcbiAgICB2YXIgdFN0YXRpc3RpYyA9IG1vZGVsLmNvZWYubWFwKGZ1bmN0aW9uKGNvZWYsIGkpIHtcbiAgICAgIHJldHVybiAoY29lZiAtIDApIC8gc2VCZXRhSGF0W2ldO1xuICAgIH0pO1xuICAgIHZhciBwVmFsdWUgPSB0U3RhdGlzdGljLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbGVmdHBwZiA9IGpTdGF0LnN0dWRlbnR0LmNkZih0LCBtb2RlbC5kZl9yZXNpZCk7XG4gICAgICByZXR1cm4gKGxlZnRwcGYgPiAwLjUgPyAxIC0gbGVmdHBwZiA6IGxlZnRwcGYpICogMjtcbiAgICB9KTtcbiAgICB2YXIgYyA9IGpTdGF0LnN0dWRlbnR0LmludigwLjk3NSwgbW9kZWwuZGZfcmVzaWQpO1xuICAgIHZhciBpbnRlcnZhbDk1ID0gbW9kZWwuY29lZi5tYXAoZnVuY3Rpb24oY29lZiwgaSkge1xuICAgICAgdmFyIGQgPSBjICogc2VCZXRhSGF0W2ldO1xuICAgICAgcmV0dXJuIFtjb2VmIC0gZCwgY29lZiArIGRdO1xuICAgIH0pXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2U6IHNlQmV0YUhhdCxcbiAgICAgICAgdDogdFN0YXRpc3RpYyxcbiAgICAgICAgcDogcFZhbHVlLFxuICAgICAgICBzaWdtYUhhdDogc2lnbWFIYXQsXG4gICAgICAgIGludGVydmFsOTU6IGludGVydmFsOTVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gRl90ZXN0KG1vZGVsKSB7XG4gICAgdmFyIEZfc3RhdGlzdGljID1cbiAgICAgICAgKG1vZGVsLlIyIC8gbW9kZWwuZGZfbW9kZWwpIC8gKCgxIC0gbW9kZWwuUjIpIC8gbW9kZWwuZGZfcmVzaWQpO1xuICAgIHZhciBmY2RmID0gZnVuY3Rpb24oeCwgbjEsIG4yKSB7XG4gICAgICByZXR1cm4galN0YXQuYmV0YS5jZGYoeCAvIChuMiAvIG4xICsgeCksIG4xIC8gMiwgbjIgLyAyKVxuICAgIH1cbiAgICB2YXIgcHZhbHVlID0gMSAtIGZjZGYoRl9zdGF0aXN0aWMsIG1vZGVsLmRmX21vZGVsLCBtb2RlbC5kZl9yZXNpZCk7XG4gICAgcmV0dXJuIHsgRl9zdGF0aXN0aWM6IEZfc3RhdGlzdGljLCBwdmFsdWU6IHB2YWx1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb2xzX3dyYXAoZW5kb2csIGV4b2cpIHtcbiAgICB2YXIgbW9kZWwgPSBvbHMoZW5kb2csZXhvZyk7XG4gICAgdmFyIHR0ZXN0ID0gdF90ZXN0KG1vZGVsKTtcbiAgICB2YXIgZnRlc3QgPSBGX3Rlc3QobW9kZWwpO1xuICAgIC8vIFByb3ZpZGUgdGhlIFdoZXJyeSAvIEV6ZWtpZWwgLyBNY05lbWFyIC8gQ29oZW4gQWRqdXN0ZWQgUl4yXG4gICAgLy8gV2hpY2ggbWF0Y2hlcyB0aGUgJ2FkanVzdGVkIFJeMicgcHJvdmlkZWQgYnkgUidzIGxtIHBhY2thZ2VcbiAgICB2YXIgYWRqdXN0X1IyID1cbiAgICAgICAgMSAtICgxIC0gbW9kZWwuUjIpICogKChtb2RlbC5ub2JzIC0gMSkgLyAobW9kZWwuZGZfcmVzaWQpKTtcbiAgICBtb2RlbC50ID0gdHRlc3Q7XG4gICAgbW9kZWwuZiA9IGZ0ZXN0O1xuICAgIG1vZGVsLmFkanVzdF9SMiA9IGFkanVzdF9SMjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICByZXR1cm4geyBvbHM6IG9sc193cmFwIH07XG59KSgpO1xuLy9UbyByZWdyZXNzLCBzaW1wbHkgYnVpbGQgWCBtYXRyaXhcbi8vKGFwcGVuZCBjb2x1bW4gb2YgMSdzKSB1c2luZ1xuLy9idWlsZHhtYXRyaXggYW5kIGJ1aWxkIHRoZSBZXG4vL21hdHJpeCB1c2luZyBidWlsZHltYXRyaXhcbi8vKHNpbXBseSB0aGUgdHJhbnNwb3NlKVxuLy9hbmQgcnVuIHJlZ3Jlc3MuXG5cblxuXG4vL1JlZ3Jlc3Npb25zXG5cbmpTdGF0LmV4dGVuZCh7XG4gIGJ1aWxkeG1hdHJpeDogZnVuY3Rpb24gYnVpbGR4bWF0cml4KCl7XG4gICAgLy9QYXJhbWV0ZXJzIHdpbGwgYmUgcGFzc2VkIGluIGFzIHN1Y2hcbiAgICAvLyhhcnJheTEsYXJyYXkyLGFycmF5MywuLi4pXG4gICAgLy9hcyAoeDEseDIseDMsLi4uKVxuICAgIC8vbmVlZHMgdG8gYmUgKDEseDEseDIseDMsLi4uKVxuICAgIHZhciBtYXRyaXhSb3dzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe1xuICAgICAgdmFyIGFycmF5ID0gWzFdO1xuICAgICAgbWF0cml4Um93c1tpXT0gYXJyYXkuY29uY2F0KGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdChtYXRyaXhSb3dzKTtcblxuICB9LFxuXG4gIGJ1aWxkZHhtYXRyaXg6IGZ1bmN0aW9uIGJ1aWxkZHhtYXRyaXgoKSB7XG4gICAgLy9QYXJhbXRlcnMgd2lsbCBiZSBwYXNzZWQgaW4gYXMgc3VjaFxuICAgIC8vKFthcnJheTEsYXJyYXkyLC4uLl1cbiAgICB2YXIgbWF0cml4Um93cyA9IG5ldyBBcnJheShhcmd1bWVudHNbMF0ubGVuZ3RoKTtcbiAgICBmb3IodmFyIGk9MDtpPGFyZ3VtZW50c1swXS5sZW5ndGg7aSsrKXtcbiAgICAgIHZhciBhcnJheSA9IFsxXVxuICAgICAgbWF0cml4Um93c1tpXT0gYXJyYXkuY29uY2F0KGFyZ3VtZW50c1swXVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdChtYXRyaXhSb3dzKTtcblxuICB9LFxuXG4gIGJ1aWxkanhtYXRyaXg6IGZ1bmN0aW9uIGJ1aWxkanhtYXRyaXgoak1hdCkge1xuICAgIC8vQnVpbGRzIGZyb20galN0YXQgTWF0cml4XG4gICAgdmFyIHBhc3MgPSBuZXcgQXJyYXkoak1hdC5sZW5ndGgpXG4gICAgZm9yKHZhciBpPTA7aTxqTWF0Lmxlbmd0aDtpKyspe1xuICAgICAgcGFzc1tpXSA9IGpNYXRbaV07XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5idWlsZGR4bWF0cml4KHBhc3MpO1xuXG4gIH0sXG5cbiAgYnVpbGR5bWF0cml4OiBmdW5jdGlvbiBidWlsZHltYXRyaXgoYXJyYXkpe1xuICAgIHJldHVybiBqU3RhdChhcnJheSkudHJhbnNwb3NlKCk7XG4gIH0sXG5cbiAgYnVpbGRqeW1hdHJpeDogZnVuY3Rpb24gYnVpbGRqeW1hdHJpeChqTWF0KXtcbiAgICByZXR1cm4gak1hdC50cmFuc3Bvc2UoKTtcbiAgfSxcblxuICBtYXRyaXhtdWx0OiBmdW5jdGlvbiBtYXRyaXhtdWx0KEEsQil7XG4gICAgdmFyIGksIGosIGssIHJlc3VsdCwgc3VtO1xuICAgIGlmIChBLmNvbHMoKSA9PSBCLnJvd3MoKSkge1xuICAgICAgaWYoQi5yb3dzKCk+MSl7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQS5yb3dzKCk7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBCLmNvbHMoKTsgaisrKSB7XG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IEEuY29scygpOyBrKyspIHtcbiAgICAgICAgICAgICAgc3VtICs9IEEudG9BcnJheSgpW2ldW2tdICogQi50b0FycmF5KClba11bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaV1bal0gPSBzdW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqU3RhdChyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgQS5yb3dzKCk7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IEIuY29scygpOyBqKyspIHtcbiAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBBLmNvbHMoKTsgaysrKSB7XG4gICAgICAgICAgICBzdW0gKz0gQS50b0FycmF5KClbaV1ba10gKiBCLnRvQXJyYXkoKVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0W2ldW2pdID0gc3VtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4galN0YXQocmVzdWx0KTtcbiAgICB9XG4gIH0sXG5cbiAgLy9yZWdyZXNzIGFuZCByZWdyZXNzdCB0byBiZSBmaXhlZFxuXG4gIHJlZ3Jlc3M6IGZ1bmN0aW9uIHJlZ3Jlc3Moak1hdFgsak1hdFkpe1xuICAgIC8vcHJpbnQoXCJyZWdyZXNzaW4hXCIpO1xuICAgIC8vcHJpbnQoak1hdFgudG9BcnJheSgpKTtcbiAgICB2YXIgaW5uZXJpbnYgPSBqU3RhdC54dHJhbnNweGludihqTWF0WCk7XG4gICAgLy9wcmludChpbm5lcmludik7XG4gICAgdmFyIHh0cmFuc3AgPSBqTWF0WC50cmFuc3Bvc2UoKTtcbiAgICB2YXIgbmV4dCA9IGpTdGF0Lm1hdHJpeG11bHQoalN0YXQoaW5uZXJpbnYpLHh0cmFuc3ApO1xuICAgIHJldHVybiBqU3RhdC5tYXRyaXhtdWx0KG5leHQsak1hdFkpO1xuXG4gIH0sXG5cbiAgcmVncmVzc3Q6IGZ1bmN0aW9uIHJlZ3Jlc3N0KGpNYXRYLGpNYXRZLHNpZGVzKXtcbiAgICB2YXIgYmV0YSA9IGpTdGF0LnJlZ3Jlc3Moak1hdFgsak1hdFkpO1xuXG4gICAgdmFyIGNvbXBpbGUgPSB7fTtcbiAgICBjb21waWxlLmFub3ZhID0ge307XG4gICAgdmFyIGpNYXRZQmFyID0galN0YXQuak1hdFlCYXIoak1hdFgsIGJldGEpO1xuICAgIGNvbXBpbGUueUJhciA9IGpNYXRZQmFyO1xuICAgIHZhciB5QXZlcmFnZSA9IGpNYXRZLm1lYW4oKTtcbiAgICBjb21waWxlLmFub3ZhLnJlc2lkdWFscyA9IGpTdGF0LnJlc2lkdWFscyhqTWF0WSwgak1hdFlCYXIpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc3IgPSBqU3RhdC5zc3Ioak1hdFlCYXIsIHlBdmVyYWdlKTtcbiAgICBjb21waWxlLmFub3ZhLm1zciA9IGNvbXBpbGUuYW5vdmEuc3NyIC8gKGpNYXRYWzBdLmxlbmd0aCAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc2UgPSBqU3RhdC5zc2Uoak1hdFksIGpNYXRZQmFyKTtcbiAgICBjb21waWxlLmFub3ZhLm1zZSA9XG4gICAgICAgIGNvbXBpbGUuYW5vdmEuc3NlIC8gKGpNYXRZLmxlbmd0aCAtIChqTWF0WFswXS5sZW5ndGggLSAxKSAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc3QgPSBqU3RhdC5zc3Qoak1hdFksIHlBdmVyYWdlKTtcbiAgICBjb21waWxlLmFub3ZhLm1zdCA9IGNvbXBpbGUuYW5vdmEuc3N0IC8gKGpNYXRZLmxlbmd0aCAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5yMiA9IDEgLSAoY29tcGlsZS5hbm92YS5zc2UgLyBjb21waWxlLmFub3ZhLnNzdCk7XG4gICAgaWYgKGNvbXBpbGUuYW5vdmEucjIgPCAwKSBjb21waWxlLmFub3ZhLnIyID0gMDtcblxuICAgIGNvbXBpbGUuYW5vdmEuZnJhdGlvID0gY29tcGlsZS5hbm92YS5tc3IgLyBjb21waWxlLmFub3ZhLm1zZTtcbiAgICBjb21waWxlLmFub3ZhLnB2YWx1ZSA9XG4gICAgICAgIGpTdGF0LmFub3ZhZnRlc3QoY29tcGlsZS5hbm92YS5mcmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgak1hdFhbMF0ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBqTWF0WS5sZW5ndGggLSAoak1hdFhbMF0ubGVuZ3RoIC0gMSkgLSAxKTtcblxuICAgIGNvbXBpbGUuYW5vdmEucm1zZSA9IE1hdGguc3FydChjb21waWxlLmFub3ZhLm1zZSk7XG5cbiAgICBjb21waWxlLmFub3ZhLnIyYWRqID0gMSAtIChjb21waWxlLmFub3ZhLm1zZSAvIGNvbXBpbGUuYW5vdmEubXN0KTtcbiAgICBpZiAoY29tcGlsZS5hbm92YS5yMmFkaiA8IDApIGNvbXBpbGUuYW5vdmEucjJhZGogPSAwO1xuXG4gICAgY29tcGlsZS5zdGF0cyA9IG5ldyBBcnJheShqTWF0WFswXS5sZW5ndGgpO1xuICAgIHZhciBjb3ZhciA9IGpTdGF0Lnh0cmFuc3B4aW52KGpNYXRYKTtcbiAgICB2YXIgc2RzLCB0cywgcHM7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxiZXRhLmxlbmd0aDtpKyspe1xuICAgICAgc2RzPU1hdGguc3FydChjb21waWxlLmFub3ZhLm1zZSAqIE1hdGguYWJzKGNvdmFyW2ldW2ldKSk7XG4gICAgICB0cz0gTWF0aC5hYnMoYmV0YVtpXSAvIHNkcyk7XG4gICAgICBwcz0galN0YXQudHRlc3QodHMsIGpNYXRZLmxlbmd0aCAtIGpNYXRYWzBdLmxlbmd0aCAtIDEsIHNpZGVzKTtcblxuICAgICAgY29tcGlsZS5zdGF0c1tpXT1bYmV0YVtpXSwgc2RzLCB0cywgcHNdO1xuICAgIH1cblxuICAgIGNvbXBpbGUucmVncmVzcyA9IGJldGE7XG4gICAgcmV0dXJuIGNvbXBpbGU7XG4gIH0sXG5cbiAgeHRyYW5zcHg6IGZ1bmN0aW9uIHh0cmFuc3B4KGpNYXRYKXtcbiAgICByZXR1cm4galN0YXQubWF0cml4bXVsdChqTWF0WC50cmFuc3Bvc2UoKSxqTWF0WCk7XG4gIH0sXG5cblxuICB4dHJhbnNweGludjogZnVuY3Rpb24geHRyYW5zcHhpbnYoak1hdFgpe1xuICAgIHZhciBpbm5lciA9IGpTdGF0Lm1hdHJpeG11bHQoak1hdFgudHJhbnNwb3NlKCksak1hdFgpO1xuICAgIHZhciBpbm5lcmludiA9IGpTdGF0Lmludihpbm5lcik7XG4gICAgcmV0dXJuIGlubmVyaW52O1xuICB9LFxuXG4gIGpNYXRZQmFyOiBmdW5jdGlvbiBqTWF0WUJhcihqTWF0WCwgYmV0YSkge1xuICAgIHZhciB5QmFyID0galN0YXQubWF0cml4bXVsdChqTWF0WCwgYmV0YSk7XG4gICAgcmV0dXJuIG5ldyBqU3RhdCh5QmFyKTtcbiAgfSxcblxuICByZXNpZHVhbHM6IGZ1bmN0aW9uIHJlc2lkdWFscyhqTWF0WSwgak1hdFlCYXIpIHtcbiAgICByZXR1cm4galN0YXQubWF0cml4c3VidHJhY3Qoak1hdFksIGpNYXRZQmFyKTtcbiAgfSxcblxuICBzc3I6IGZ1bmN0aW9uIHNzcihqTWF0WUJhciwgeUF2ZXJhZ2UpIHtcbiAgICB2YXIgc3NyID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFlCYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzciArPSBNYXRoLnBvdyhqTWF0WUJhcltpXSAtIHlBdmVyYWdlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzcjtcbiAgfSxcblxuICBzc2U6IGZ1bmN0aW9uIHNzZShqTWF0WSwgak1hdFlCYXIpIHtcbiAgICB2YXIgc3NlID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzZSArPSBNYXRoLnBvdyhqTWF0WVtpXSAtIGpNYXRZQmFyW2ldLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzZTtcbiAgfSxcblxuICBzc3Q6IGZ1bmN0aW9uIHNzdChqTWF0WSwgeUF2ZXJhZ2UpIHtcbiAgICB2YXIgc3N0ID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzdCArPSBNYXRoLnBvdyhqTWF0WVtpXSAtIHlBdmVyYWdlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzdDtcbiAgfSxcblxuICBtYXRyaXhzdWJ0cmFjdDogZnVuY3Rpb24gbWF0cml4c3VidHJhY3QoQSxCKXtcbiAgICB2YXIgYW5zID0gbmV3IEFycmF5KEEubGVuZ3RoKTtcbiAgICBmb3IodmFyIGk9MDtpPEEubGVuZ3RoO2krKyl7XG4gICAgICBhbnNbaV0gPSBuZXcgQXJyYXkoQVtpXS5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBqPTA7ajxBW2ldLmxlbmd0aDtqKyspe1xuICAgICAgICBhbnNbaV1bal09QVtpXVtqXS1CW2ldW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4galN0YXQoYW5zKTtcbiAgfVxufSk7XG4gIC8vIE1ha2UgaXQgY29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb24uXG4gIGpTdGF0LmpTdGF0ID0galN0YXQ7XG5cbiAgcmV0dXJuIGpTdGF0O1xufSk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gQHRzLWlnbm9yZVxuZXhwb3J0ICogZnJvbSBcImpzdGF0XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=